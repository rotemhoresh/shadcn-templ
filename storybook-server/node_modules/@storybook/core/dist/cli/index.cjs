"use strict";
var vE = Object.create;
var wi = Object.defineProperty;
var _E = Object.getOwnPropertyDescriptor;
var EE = Object.getOwnPropertyNames;
var CE = Object.getPrototypeOf, FE = Object.prototype.hasOwnProperty;
var n = (e, t) => wi(e, "name", { value: t, configurable: !0 });
var g = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), xE = (e, t) => {
  for (var r in t)
    wi(e, r, { get: t[r], enumerable: !0 });
}, Tf = (e, t, r, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let s of EE(t))
      !FE.call(e, s) && s !== r && wi(e, s, { get: () => t[s], enumerable: !(i = _E(t, s)) || i.enumerable });
  return e;
};
var G = (e, t, r) => (r = e != null ? vE(CE(e)) : {}, Tf(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? wi(r, "default", { value: e, enumerable: !0 }) : r,
  e
)), SE = (e) => Tf(wi({}, "__esModule", { value: !0 }), e);

// ../node_modules/prompts/node_modules/kleur/index.js
var ce = g((nq, jf) => {
  "use strict";
  var { FORCE_COLOR: OE, NODE_DISABLE_COLORS: PE, TERM: qE } = process.env, Q = {
    enabled: !PE && qE !== "dumb" && OE !== "0",
    // modifiers
    reset: Z(0, 0),
    bold: Z(1, 22),
    dim: Z(2, 22),
    italic: Z(3, 23),
    underline: Z(4, 24),
    inverse: Z(7, 27),
    hidden: Z(8, 28),
    strikethrough: Z(9, 29),
    // colors
    black: Z(30, 39),
    red: Z(31, 39),
    green: Z(32, 39),
    yellow: Z(33, 39),
    blue: Z(34, 39),
    magenta: Z(35, 39),
    cyan: Z(36, 39),
    white: Z(37, 39),
    gray: Z(90, 39),
    grey: Z(90, 39),
    // background colors
    bgBlack: Z(40, 49),
    bgRed: Z(41, 49),
    bgGreen: Z(42, 49),
    bgYellow: Z(43, 49),
    bgBlue: Z(44, 49),
    bgMagenta: Z(45, 49),
    bgCyan: Z(46, 49),
    bgWhite: Z(47, 49)
  };
  function Mf(e, t) {
    let r = 0, i, s = "", o = "";
    for (; r < e.length; r++)
      i = e[r], s += i.open, o += i.close, t.includes(i.close) && (t = t.replace(i.rgx, i.close + i.open));
    return s + t + o;
  }
  n(Mf, "run");
  function ME(e, t) {
    let r = { has: e, keys: t };
    return r.reset = Q.reset.bind(r), r.bold = Q.bold.bind(r), r.dim = Q.dim.bind(r), r.italic = Q.italic.bind(r), r.underline = Q.underline.
    bind(r), r.inverse = Q.inverse.bind(r), r.hidden = Q.hidden.bind(r), r.strikethrough = Q.strikethrough.bind(r), r.black = Q.black.bind(r),
    r.red = Q.red.bind(r), r.green = Q.green.bind(r), r.yellow = Q.yellow.bind(r), r.blue = Q.blue.bind(r), r.magenta = Q.magenta.bind(r), r.
    cyan = Q.cyan.bind(r), r.white = Q.white.bind(r), r.gray = Q.gray.bind(r), r.grey = Q.grey.bind(r), r.bgBlack = Q.bgBlack.bind(r), r.bgRed =
    Q.bgRed.bind(r), r.bgGreen = Q.bgGreen.bind(r), r.bgYellow = Q.bgYellow.bind(r), r.bgBlue = Q.bgBlue.bind(r), r.bgMagenta = Q.bgMagenta.
    bind(r), r.bgCyan = Q.bgCyan.bind(r), r.bgWhite = Q.bgWhite.bind(r), r;
  }
  n(ME, "chain");
  function Z(e, t) {
    let r = {
      open: `\x1B[${e}m`,
      close: `\x1B[${t}m`,
      rgx: new RegExp(`\\x1b\\[${t}m`, "g")
    };
    return function(i) {
      return this !== void 0 && this.has !== void 0 ? (this.has.includes(e) || (this.has.push(e), this.keys.push(r)), i === void 0 ? this : Q.
      enabled ? Mf(this.keys, i + "") : i + "") : i === void 0 ? ME([e], [r]) : Q.enabled ? Mf([r], i + "") : i + "";
    };
  }
  n(Z, "init");
  jf.exports = Q;
});

// ../node_modules/prompts/dist/util/action.js
var Lf = g((oq, If) => {
  "use strict";
  If.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/dist/util/strip.js
var Hn = g((uq, Nf) => {
  "use strict";
  Nf.exports = (e) => {
    let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/sisteransi/src/index.js
var he = g((aq, Uf) => {
  "use strict";
  var ou = "\x1B", fe = `${ou}[`, jE = "\x07", uu = {
    to(e, t) {
      return t ? `${fe}${t + 1};${e + 1}H` : `${fe}${e + 1}G`;
    },
    move(e, t) {
      let r = "";
      return e < 0 ? r += `${fe}${-e}D` : e > 0 && (r += `${fe}${e}C`), t < 0 ? r += `${fe}${-t}A` : t > 0 && (r += `${fe}${t}B`), r;
    },
    up: /* @__PURE__ */ n((e = 1) => `${fe}${e}A`, "up"),
    down: /* @__PURE__ */ n((e = 1) => `${fe}${e}B`, "down"),
    forward: /* @__PURE__ */ n((e = 1) => `${fe}${e}C`, "forward"),
    backward: /* @__PURE__ */ n((e = 1) => `${fe}${e}D`, "backward"),
    nextLine: /* @__PURE__ */ n((e = 1) => `${fe}E`.repeat(e), "nextLine"),
    prevLine: /* @__PURE__ */ n((e = 1) => `${fe}F`.repeat(e), "prevLine"),
    left: `${fe}G`,
    hide: `${fe}?25l`,
    show: `${fe}?25h`,
    save: `${ou}7`,
    restore: `${ou}8`
  }, IE = {
    up: /* @__PURE__ */ n((e = 1) => `${fe}S`.repeat(e), "up"),
    down: /* @__PURE__ */ n((e = 1) => `${fe}T`.repeat(e), "down")
  }, LE = {
    screen: `${fe}2J`,
    up: /* @__PURE__ */ n((e = 1) => `${fe}1J`.repeat(e), "up"),
    down: /* @__PURE__ */ n((e = 1) => `${fe}J`.repeat(e), "down"),
    line: `${fe}2K`,
    lineEnd: `${fe}K`,
    lineStart: `${fe}1K`,
    lines(e) {
      let t = "";
      for (let r = 0; r < e; r++)
        t += this.line + (r < e - 1 ? uu.up() : "");
      return e && (t += uu.left), t;
    }
  };
  Uf.exports = { cursor: uu, scroll: IE, erase: LE, beep: jE };
});

// ../node_modules/prompts/dist/util/clear.js
var Vf = g((cq, zf) => {
  "use strict";
  function NE(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = UE(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var i = 0, s = /* @__PURE__ */ n(function() {
        }, "F");
        return { s, n: /* @__PURE__ */ n(function() {
          return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
        }, "n"), e: /* @__PURE__ */ n(function(c) {
          throw c;
        }, "e"), f: s };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o = !0, u = !1, a;
    return { s: /* @__PURE__ */ n(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ n(function() {
      var c = r.next();
      return o = c.done, c;
    }, "n"), e: /* @__PURE__ */ n(function(c) {
      u = !0, a = c;
    }, "e"), f: /* @__PURE__ */ n(function() {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (u) throw a;
      }
    }, "f") };
  }
  n(NE, "_createForOfIteratorHelper");
  function UE(e, t) {
    if (e) {
      if (typeof e == "string") return Wf(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Wf(e, t);
    }
  }
  n(UE, "_unsupportedIterableToArray");
  function Wf(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
    return i;
  }
  n(Wf, "_arrayLikeToArray");
  var WE = Hn(), Hf = he(), $f = Hf.erase, $E = Hf.cursor, HE = /* @__PURE__ */ n((e) => [...WE(e)].length, "width");
  zf.exports = function(e, t) {
    if (!t) return $f.line + $E.to(0);
    let r = 0, i = e.split(/\r?\n/);
    var s = NE(i), o;
    try {
      for (s.s(); !(o = s.n()).done; ) {
        let u = o.value;
        r += 1 + Math.floor(Math.max(HE(u) - 1, 0) / t);
      }
    } catch (u) {
      s.e(u);
    } finally {
      s.f();
    }
    return $f.lines(r);
  };
});

// ../node_modules/prompts/dist/util/figures.js
var au = g((hq, Gf) => {
  "use strict";
  var vi = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, zE = {
    arrowUp: vi.arrowUp,
    arrowDown: vi.arrowDown,
    arrowLeft: vi.arrowLeft,
    arrowRight: vi.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, VE = process.platform === "win32" ? zE : vi;
  Gf.exports = VE;
});

// ../node_modules/prompts/dist/util/style.js
var Yf = g((dq, Jf) => {
  "use strict";
  var Tr = ce(), sr = au(), lu = Object.freeze({
    password: {
      scale: 1,
      render: /* @__PURE__ */ n((e) => "*".repeat(e.length), "render")
    },
    emoji: {
      scale: 2,
      render: /* @__PURE__ */ n((e) => "\u{1F603}".repeat(e.length), "render")
    },
    invisible: {
      scale: 0,
      render: /* @__PURE__ */ n((e) => "", "render")
    },
    default: {
      scale: 1,
      render: /* @__PURE__ */ n((e) => `${e}`, "render")
    }
  }), GE = /* @__PURE__ */ n((e) => lu[e] || lu.default, "render"), _i = Object.freeze({
    aborted: Tr.red(sr.cross),
    done: Tr.green(sr.tick),
    exited: Tr.yellow(sr.cross),
    default: Tr.cyan("?")
  }), JE = /* @__PURE__ */ n((e, t, r) => t ? _i.aborted : r ? _i.exited : e ? _i.done : _i.default, "symbol"), YE = /* @__PURE__ */ n((e) => Tr.
  gray(e ? sr.ellipsis : sr.pointerSmall), "delimiter"), KE = /* @__PURE__ */ n((e, t) => Tr.gray(e ? t ? sr.pointerSmall : "+" : sr.line), "\
item");
  Jf.exports = {
    styles: lu,
    render: GE,
    symbols: _i,
    symbol: JE,
    delimiter: YE,
    item: KE
  };
});

// ../node_modules/prompts/dist/util/lines.js
var Qf = g((Dq, Kf) => {
  "use strict";
  var QE = Hn();
  Kf.exports = function(e, t) {
    let r = String(QE(e) || "").split(/\r?\n/);
    return t ? r.map((i) => Math.ceil(i.length / t)).reduce((i, s) => i + s) : r.length;
  };
});

// ../node_modules/prompts/dist/util/wrap.js
var Zf = g((mq, Xf) => {
  "use strict";
  Xf.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", i = t.width;
    return (e || "").split(/\r?\n/g).map((s) => s.split(/\s+/g).reduce((o, u) => (u.length + r.length >= i || o[o.length - 1].length + u.length +
    1 < i ? o[o.length - 1] += ` ${u}` : o.push(`${r}${u}`), o), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/dist/util/entriesToDisplay.js
var th = g((yq, eh) => {
  "use strict";
  eh.exports = (e, t, r) => {
    r = r || t;
    let i = Math.min(t - r, e - Math.floor(r / 2));
    i < 0 && (i = 0);
    let s = Math.min(i + r, t);
    return {
      startIndex: i,
      endIndex: s
    };
  };
});

// ../node_modules/prompts/dist/util/index.js
var Ye = g((gq, rh) => {
  "use strict";
  rh.exports = {
    action: Lf(),
    clear: Vf(),
    style: Yf(),
    strip: Hn(),
    figures: au(),
    lines: Qf(),
    wrap: Zf(),
    entriesToDisplay: th()
  };
});

// ../node_modules/prompts/dist/elements/prompt.js
var mt = g((bq, sh) => {
  "use strict";
  var ih = require("readline"), XE = Ye(), ZE = XE.action, eC = require("events"), nh = he(), tC = nh.beep, rC = nh.cursor, iC = ce(), cu = class extends eC {
    static {
      n(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = ih.createInterface({
        input: this.in,
        escapeCodeTimeout: 50
      });
      ih.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, s = /* @__PURE__ */ n((o, u) => {
        let a = ZE(u, i);
        a === !1 ? this._ && this._(o, u) : typeof this[a] == "function" ? this[a](u) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(rC.show), this.in.removeListener("keypress", s), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", s);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(tC);
    }
    render() {
      this.onRender(iC), this.firstRender && (this.firstRender = !1);
    }
  };
  sh.exports = cu;
});

// ../node_modules/prompts/dist/elements/text.js
var ch = g((vq, lh) => {
  "use strict";
  function oh(e, t, r, i, s, o, u) {
    try {
      var a = e[o](u), l = a.value;
    } catch (c) {
      r(c);
      return;
    }
    a.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(oh, "asyncGeneratorStep");
  function uh(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var o = e.apply(t, r);
        function u(l) {
          oh(o, i, s, u, a, "next", l);
        }
        n(u, "_next");
        function a(l) {
          oh(o, i, s, u, a, "throw", l);
        }
        n(a, "_throw"), u(void 0);
      });
    };
  }
  n(uh, "_asyncToGenerator");
  var zn = ce(), nC = mt(), ah = he(), sC = ah.erase, Ei = ah.cursor, Vn = Ye(), fu = Vn.style, hu = Vn.clear, oC = Vn.lines, uC = Vn.figures,
  du = class extends nC {
    static {
      n(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = fu.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = hu("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = zn.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return uh(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return uh(function* () {
        if (t.value = t.value || t.initial, t.cursorOffset = 0, t.cursor = t.rendered.length, yield t.validate(), t.error) {
          t.red = !0, t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let i = this.value.slice(0, this.cursor), s = this.value.slice(this.cursor);
      this.value = `${i}${t}${s}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Ei.down(oC(this.outputError, this.out.columns) - 1) + hu(this.
      outputError, this.out.columns)), this.out.write(hu(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [fu.symbol(this.done, this.aborted), zn.bold(this.msg), fu.delimiter(this.done), this.red ? zn.red(this.rendered) : this.rendered].join(
      " "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : uC.pointerSmall} ${zn.red().italic(r)}`, "")), this.out.write(sC.line + Ei.to(0) + this.outputText + Ei.save + this.outputError +
      Ei.restore + Ei.move(this.cursorOffset, 0)));
    }
  };
  lh.exports = du;
});

// ../node_modules/prompts/dist/elements/select.js
var ph = g((Eq, dh) => {
  "use strict";
  var yt = ce(), aC = mt(), Ci = Ye(), fh = Ci.style, hh = Ci.clear, Gn = Ci.figures, lC = Ci.wrap, cC = Ci.entriesToDisplay, fC = he(), hC = fC.
  cursor, pu = class extends aC {
    static {
      n(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = hh("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(hC.hide) : this.out.write(hh(this.outputText, this.out.columns)), super.render();
      let t = cC(this.cursor, this.choices.length, this.optionsPerPage), r = t.startIndex, i = t.endIndex;
      if (this.outputText = [fh.symbol(this.done, this.aborted), yt.bold(this.msg), fh.delimiter(!1), this.done ? this.selection.title : this.
      selection.disabled ? yt.yellow(this.warn) : yt.gray(this.hint)].join(" "), !this.done) {
        this.outputText += `
`;
        for (let s = r; s < i; s++) {
          let o, u, a = "", l = this.choices[s];
          s === r && r > 0 ? u = Gn.arrowUp : s === i - 1 && i < this.choices.length ? u = Gn.arrowDown : u = " ", l.disabled ? (o = this.cursor ===
          s ? yt.gray().underline(l.title) : yt.strikethrough().gray(l.title), u = (this.cursor === s ? yt.bold().gray(Gn.pointer) + " " : "\
  ") + u) : (o = this.cursor === s ? yt.cyan().underline(l.title) : l.title, u = (this.cursor === s ? yt.cyan(Gn.pointer) + " " : "  ") + u,
          l.description && this.cursor === s && (a = ` - ${l.description}`, (u.length + o.length + a.length >= this.out.columns || l.description.
          split(/\r?\n/).length > 1) && (a = `
` + lC(l.description, {
            margin: 3,
            width: this.out.columns
          })))), this.outputText += `${u} ${o}${yt.gray(a)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  dh.exports = pu;
});

// ../node_modules/prompts/dist/elements/toggle.js
var wh = g((Fq, bh) => {
  "use strict";
  var Jn = ce(), dC = mt(), yh = Ye(), Dh = yh.style, pC = yh.clear, gh = he(), mh = gh.cursor, DC = gh.erase, Du = class extends dC {
    static {
      n(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(mh.hide) : this.out.write(pC(this.outputText, this.out.columns)), super.render(), this.
      outputText = [Dh.symbol(this.done, this.aborted), Jn.bold(this.msg), Dh.delimiter(this.done), this.value ? this.inactive : Jn.cyan().underline(
      this.inactive), Jn.gray("/"), this.value ? Jn.cyan().underline(this.active) : this.active].join(" "), this.out.write(DC.line + mh.to(0) +
      this.outputText));
    }
  };
  bh.exports = Du;
});

// ../node_modules/prompts/dist/dateparts/datepart.js
var it = g((Sq, vh) => {
  "use strict";
  var mu = class e {
    static {
      n(this, "DatePart");
    }
    constructor({
      token: t,
      date: r,
      parts: i,
      locales: s
    }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = s || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((i, s) => s > r && i instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  vh.exports = mu;
});

// ../node_modules/prompts/dist/dateparts/meridiem.js
var Eh = g((Tq, _h) => {
  "use strict";
  var mC = it(), yu = class extends mC {
    static {
      n(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  _h.exports = yu;
});

// ../node_modules/prompts/dist/dateparts/day.js
var Fh = g((kq, Ch) => {
  "use strict";
  var yC = it(), gC = /* @__PURE__ */ n((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), gu = class extends yC {
    static {
      n(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + gC(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  Ch.exports = gu;
});

// ../node_modules/prompts/dist/dateparts/hours.js
var Sh = g((Oq, xh) => {
  "use strict";
  var bC = it(), bu = class extends bC {
    static {
      n(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  xh.exports = bu;
});

// ../node_modules/prompts/dist/dateparts/milliseconds.js
var Th = g((qq, Ah) => {
  "use strict";
  var wC = it(), wu = class extends wC {
    static {
      n(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  Ah.exports = wu;
});

// ../node_modules/prompts/dist/dateparts/minutes.js
var kh = g((jq, Rh) => {
  "use strict";
  var vC = it(), vu = class extends vC {
    static {
      n(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  Rh.exports = vu;
});

// ../node_modules/prompts/dist/dateparts/month.js
var Oh = g((Lq, Bh) => {
  "use strict";
  var _C = it(), _u = class extends _C {
    static {
      n(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  Bh.exports = _u;
});

// ../node_modules/prompts/dist/dateparts/seconds.js
var qh = g((Uq, Ph) => {
  "use strict";
  var EC = it(), Eu = class extends EC {
    static {
      n(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  Ph.exports = Eu;
});

// ../node_modules/prompts/dist/dateparts/year.js
var jh = g(($q, Mh) => {
  "use strict";
  var CC = it(), Cu = class extends CC {
    static {
      n(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  Mh.exports = Cu;
});

// ../node_modules/prompts/dist/dateparts/index.js
var Lh = g((zq, Ih) => {
  "use strict";
  Ih.exports = {
    DatePart: it(),
    Meridiem: Eh(),
    Day: Fh(),
    Hours: Sh(),
    Milliseconds: Th(),
    Minutes: kh(),
    Month: Oh(),
    Seconds: qh(),
    Year: jh()
  };
});

// ../node_modules/prompts/dist/elements/date.js
var Yh = g((Vq, Jh) => {
  "use strict";
  function Nh(e, t, r, i, s, o, u) {
    try {
      var a = e[o](u), l = a.value;
    } catch (c) {
      r(c);
      return;
    }
    a.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(Nh, "asyncGeneratorStep");
  function Uh(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var o = e.apply(t, r);
        function u(l) {
          Nh(o, i, s, u, a, "next", l);
        }
        n(u, "_next");
        function a(l) {
          Nh(o, i, s, u, a, "throw", l);
        }
        n(a, "_throw"), u(void 0);
      });
    };
  }
  n(Uh, "_asyncToGenerator");
  var Fu = ce(), FC = mt(), Su = Ye(), Wh = Su.style, $h = Su.clear, xC = Su.figures, Gh = he(), SC = Gh.erase, Hh = Gh.cursor, gt = Lh(), zh = gt.
  DatePart, AC = gt.Meridiem, TC = gt.Day, RC = gt.Hours, kC = gt.Milliseconds, BC = gt.Minutes, OC = gt.Month, PC = gt.Seconds, qC = gt.Year,
  MC = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g, Vh = {
    1: ({
      token: e
    }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new TC(e),
    // Day // TODO
    3: (e) => new OC(e),
    // Month
    4: (e) => new qC(e),
    // Year
    5: (e) => new AC(e),
    // AM/PM // TODO (special)
    6: (e) => new RC(e),
    // Hours
    7: (e) => new BC(e),
    // Minutes
    8: (e) => new PC(e),
    // Seconds
    9: (e) => new kC(e)
    // Fractional seconds
  }, jC = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, xu = class extends FC {
    static {
      n(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(jC, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = $h("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = MC.exec(t); ) {
        let s = r.shift(), o = r.findIndex((u) => u != null);
        this.parts.push(o in Vh ? Vh[o]({
          token: r[o] || s,
          date: this.date,
          parts: this.parts,
          locales: this.locales
        }) : r[o] || s);
      }
      let i = this.parts.reduce((s, o) => (typeof o == "string" && typeof s[s.length - 1] == "string" ? s[s.length - 1] += o : s.push(o), s),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof zh)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    validate() {
      var t = this;
      return Uh(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return Uh(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        t.done = !0, t.aborted = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof zh)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(Hh.hide) : this.out.write($h(this.outputText, this.out.columns)), super.render(), this.
      outputText = [Wh.symbol(this.done, this.aborted), Fu.bold(this.msg), Wh.delimiter(!1), this.parts.reduce((t, r, i) => t.concat(i === this.
      cursor && !this.done ? Fu.cyan().underline(r.toString()) : r), []).join("")].join(" "), this.error && (this.outputText += this.errorMsg.
      split(`
`).reduce((t, r, i) => t + `
${i ? " " : xC.pointerSmall} ${Fu.red().italic(r)}`, "")), this.out.write(SC.line + Hh.to(0) + this.outputText));
    }
  };
  Jh.exports = xu;
});

// ../node_modules/prompts/dist/elements/number.js
var rd = g((Jq, td) => {
  "use strict";
  function Kh(e, t, r, i, s, o, u) {
    try {
      var a = e[o](u), l = a.value;
    } catch (c) {
      r(c);
      return;
    }
    a.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(Kh, "asyncGeneratorStep");
  function Qh(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var o = e.apply(t, r);
        function u(l) {
          Kh(o, i, s, u, a, "next", l);
        }
        n(u, "_next");
        function a(l) {
          Kh(o, i, s, u, a, "throw", l);
        }
        n(a, "_throw"), u(void 0);
      });
    };
  }
  n(Qh, "_asyncToGenerator");
  var Yn = ce(), IC = mt(), ed = he(), Kn = ed.cursor, LC = ed.erase, Qn = Ye(), Au = Qn.style, NC = Qn.figures, Xh = Qn.clear, UC = Qn.lines,
  WC = /[0-9]/, Tu = /* @__PURE__ */ n((e) => e !== void 0, "isDef"), Zh = /* @__PURE__ */ n((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), Ru = class extends IC {
    static {
      n(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = Au.render(t.style), this.msg = t.message, this.initial = Tu(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = Tu(t.min) ? t.min : -1 / 0, this.max = Tu(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = Yn.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${Zh(t, this.round)}`), this._value = Zh(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || WC.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    validate() {
      var t = this;
      return Qh(function* () {
        let r = yield t.validator(t.value);
        typeof r == "string" && (t.errorMsg = r, r = !1), t.error = !r;
      })();
    }
    submit() {
      var t = this;
      return Qh(function* () {
        if (yield t.validate(), t.error) {
          t.color = "red", t.fire(), t.render();
          return;
        }
        let r = t.value;
        t.value = r !== "" ? r : t.initial, t.done = !0, t.aborted = !1, t.error = !1, t.fire(), t.render(), t.out.write(`
`), t.close();
      })();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = i, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Kn.down(UC(this.outputError, this.out.columns) - 1) + Xh(this.
      outputError, this.out.columns)), this.out.write(Xh(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [Au.symbol(this.done, this.aborted), Yn.bold(this.msg), Au.delimiter(this.done), !this.done || !this.done && !this.placeholder ? Yn[this.
      color]().underline(this.rendered) : this.rendered].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : NC.pointerSmall} ${Yn.red().italic(r)}`, "")), this.out.write(LC.line + Kn.to(0) + this.outputText + Kn.save + this.outputError +
      Kn.restore));
    }
  };
  td.exports = Ru;
});

// ../node_modules/prompts/dist/elements/multiselect.js
var Bu = g((Kq, sd) => {
  "use strict";
  var nt = ce(), $C = he(), HC = $C.cursor, zC = mt(), Fi = Ye(), id = Fi.clear, Lt = Fi.figures, nd = Fi.style, VC = Fi.wrap, GC = Fi.entriesToDisplay,
  ku = class extends zC {
    static {
      n(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, i) => (typeof r == "string" && (r = {
        title: r,
        value: i
      }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = id("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Lt.arrowUp}/${Lt.arrowDown}: Highlight option
    ${Lt.arrowLeft}/${Lt.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, i, s) {
      let o = (r.selected ? nt.green(Lt.radioOn) : Lt.radioOff) + " " + s + " ", u, a;
      return r.disabled ? u = t === i ? nt.gray().underline(r.title) : nt.strikethrough().gray(r.title) : (u = t === i ? nt.cyan().underline(
      r.title) : r.title, t === i && r.description && (a = ` - ${r.description}`, (o.length + u.length + a.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (a = `
` + VC(r.description, {
        margin: o.length,
        width: this.out.columns
      })))), o + u + nt.gray(a || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return nt.red("No matches for this query.");
      let r = GC(this.cursor, t.length, this.optionsPerPage), i = r.startIndex, s = r.endIndex, o, u = [];
      for (let a = i; a < s; a++)
        a === i && i > 0 ? o = Lt.arrowUp : a === s - 1 && s < t.length ? o = Lt.arrowDown : o = " ", u.push(this.renderOption(this.cursor, t[a],
        a, o));
      return `
` + u.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [nt.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(nt.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(HC.hide), super.render();
      let t = [nd.symbol(this.done, this.aborted), nt.bold(this.msg), nd.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += nt.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = id(t, this.out.columns);
    }
  };
  sd.exports = ku;
});

// ../node_modules/prompts/dist/elements/autocomplete.js
var hd = g((Xq, fd) => {
  "use strict";
  function od(e, t, r, i, s, o, u) {
    try {
      var a = e[o](u), l = a.value;
    } catch (c) {
      r(c);
      return;
    }
    a.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(od, "asyncGeneratorStep");
  function JC(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var o = e.apply(t, r);
        function u(l) {
          od(o, i, s, u, a, "next", l);
        }
        n(u, "_next");
        function a(l) {
          od(o, i, s, u, a, "throw", l);
        }
        n(a, "_throw"), u(void 0);
      });
    };
  }
  n(JC, "_asyncToGenerator");
  var xi = ce(), YC = mt(), cd = he(), KC = cd.erase, ud = cd.cursor, Si = Ye(), Ou = Si.style, ad = Si.clear, Pu = Si.figures, QC = Si.wrap,
  XC = Si.entriesToDisplay, ld = /* @__PURE__ */ n((e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), ZC = /* @__PURE__ */ n((e, t) => e[t] &&
  (e[t].title || e[t].value || e[t]), "getTitle"), eF = /* @__PURE__ */ n((e, t) => {
    let r = e.findIndex((i) => i.value === t || i.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), qu = class extends YC {
    static {
      n(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      eF(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = {
        noMatches: t.noMatches || "no matches found"
      }, this.fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit =
      t.limit || 10, this.cursor = 0, this.transform = Ou.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(
      this), this.complete = this.complete.bind(this), this.clear = ad("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = {
        title: this._fb
      }), t || this._fb || {
        title: this.i18n.noMatches
      };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = ld(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    complete(t) {
      var r = this;
      return JC(function* () {
        let i = r.completing = r.suggest(r.input, r.choices), s = yield i;
        if (r.completing !== i) return;
        r.suggestions = s.map((u, a, l) => ({
          title: ZC(l, a),
          value: ld(l, a),
          description: u.description
        })), r.completing = !1;
        let o = Math.max(s.length - 1, 0);
        r.moveSelect(Math.min(o, r.select)), t && t();
      })();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let i = this.input.slice(0, this.cursor), s = this.input.slice(this.cursor);
      this.input = `${i}${t}${s}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, i, s) {
      let o, u = i ? Pu.arrowUp : s ? Pu.arrowDown : " ", a = r ? xi.cyan().underline(t.title) : t.title;
      return u = (r ? xi.cyan(Pu.pointer) + " " : "  ") + u, t.description && (o = ` - ${t.description}`, (u.length + a.length + o.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (o = `
` + QC(t.description, {
        margin: 3,
        width: this.out.columns
      }))), u + " " + a + xi.gray(o || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(ud.hide) : this.out.write(ad(this.outputText, this.out.columns)), super.render();
      let t = XC(this.select, this.choices.length, this.limit), r = t.startIndex, i = t.endIndex;
      if (this.outputText = [Ou.symbol(this.done, this.aborted, this.exited), xi.bold(this.msg), Ou.delimiter(this.completing), this.done &&
      this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)].join(" "), !this.
      done) {
        let s = this.suggestions.slice(r, i).map((o, u) => this.renderOption(o, this.select === u + r, u === 0 && r > 0, u + r === i - 1 && i <
        this.choices.length)).join(`
`);
        this.outputText += `
` + (s || xi.gray(this.fallback.title));
      }
      this.out.write(KC.line + ud.to(0) + this.outputText);
    }
  };
  fd.exports = qu;
});

// ../node_modules/prompts/dist/elements/autocompleteMultiselect.js
var md = g((eM, Dd) => {
  "use strict";
  var bt = ce(), tF = he(), rF = tF.cursor, iF = Bu(), ju = Ye(), dd = ju.clear, pd = ju.style, Rr = ju.figures, Mu = class extends iF {
    static {
      n(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = dd("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Rr.arrowUp}/${Rr.arrowDown}: Highlight option
    ${Rr.arrowLeft}/${Rr.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : bt.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, i) {
      let s;
      return r.disabled ? s = t === i ? bt.gray().underline(r.title) : bt.strikethrough().gray(r.title) : s = t === i ? bt.cyan().underline(
      r.title) : r.title, (r.selected ? bt.green(Rr.radioOn) : Rr.radioOff) + "  " + s;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [bt.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(bt.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(rF.hide), super.render();
      let t = [pd.symbol(this.done, this.aborted), bt.bold(this.msg), pd.delimiter(!1), this.renderDoneOrInstructions()].join(" ");
      this.showMinError && (t += bt.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = dd(t, this.out.columns);
    }
  };
  Dd.exports = Mu;
});

// ../node_modules/prompts/dist/elements/confirm.js
var Ed = g((rM, _d) => {
  "use strict";
  var yd = ce(), nF = mt(), wd = Ye(), gd = wd.style, sF = wd.clear, vd = he(), oF = vd.erase, bd = vd.cursor, Iu = class extends nF {
    static {
      n(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(bd.hide) : this.out.write(sF(this.outputText, this.out.columns)), super.render(), this.
      outputText = [gd.symbol(this.done, this.aborted), yd.bold(this.msg), gd.delimiter(this.done), this.done ? this.value ? this.yesMsg : this.
      noMsg : yd.gray(this.initialValue ? this.yesOption : this.noOption)].join(" "), this.out.write(oF.line + bd.to(0) + this.outputText));
    }
  };
  _d.exports = Iu;
});

// ../node_modules/prompts/dist/elements/index.js
var Fd = g((nM, Cd) => {
  "use strict";
  Cd.exports = {
    TextPrompt: ch(),
    SelectPrompt: ph(),
    TogglePrompt: wh(),
    DatePrompt: Yh(),
    NumberPrompt: rd(),
    MultiselectPrompt: Bu(),
    AutocompletePrompt: hd(),
    AutocompleteMultiselectPrompt: md(),
    ConfirmPrompt: Ed()
  };
});

// ../node_modules/prompts/dist/prompts.js
var Sd = g((xd) => {
  "use strict";
  var Ne = xd, uF = Fd(), Xn = /* @__PURE__ */ n((e) => e, "noop");
  function st(e, t, r = {}) {
    return new Promise((i, s) => {
      let o = new uF[e](t), u = r.onAbort || Xn, a = r.onSubmit || Xn, l = r.onExit || Xn;
      o.on("state", t.onState || Xn), o.on("submit", (c) => i(a(c))), o.on("exit", (c) => i(l(c))), o.on("abort", (c) => s(u(c)));
    });
  }
  n(st, "toPrompt");
  Ne.text = (e) => st("TextPrompt", e);
  Ne.password = (e) => (e.style = "password", Ne.text(e));
  Ne.invisible = (e) => (e.style = "invisible", Ne.text(e));
  Ne.number = (e) => st("NumberPrompt", e);
  Ne.date = (e) => st("DatePrompt", e);
  Ne.confirm = (e) => st("ConfirmPrompt", e);
  Ne.list = (e) => {
    let t = e.separator || ",";
    return st("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ n((r) => r.split(t).map((i) => i.trim()), "onSubmit")
    });
  };
  Ne.toggle = (e) => st("TogglePrompt", e);
  Ne.select = (e) => st("SelectPrompt", e);
  Ne.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return st("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  Ne.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return st("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var aF = /* @__PURE__ */ n((e, t) => Promise.resolve(t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())), "byTi\
tle");
  Ne.autocomplete = (e) => (e.suggest = e.suggest || aF, e.choices = [].concat(e.choices || []), st("AutocompletePrompt", e));
});

// ../node_modules/prompts/dist/index.js
var qd = g((uM, Pd) => {
  "use strict";
  function Ad(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(s) {
        return Object.getOwnPropertyDescriptor(e, s).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  n(Ad, "ownKeys");
  function Td(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? Ad(Object(r), !0).forEach(function(i) {
        lF(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Ad(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  n(Td, "_objectSpread");
  function lF(e, t, r) {
    return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(lF, "_defineProperty");
  function cF(e, t) {
    var r = typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
    if (!r) {
      if (Array.isArray(e) || (r = fF(e)) || t && e && typeof e.length == "number") {
        r && (e = r);
        var i = 0, s = /* @__PURE__ */ n(function() {
        }, "F");
        return { s, n: /* @__PURE__ */ n(function() {
          return i >= e.length ? { done: !0 } : { done: !1, value: e[i++] };
        }, "n"), e: /* @__PURE__ */ n(function(c) {
          throw c;
        }, "e"), f: s };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o = !0, u = !1, a;
    return { s: /* @__PURE__ */ n(function() {
      r = r.call(e);
    }, "s"), n: /* @__PURE__ */ n(function() {
      var c = r.next();
      return o = c.done, c;
    }, "n"), e: /* @__PURE__ */ n(function(c) {
      u = !0, a = c;
    }, "e"), f: /* @__PURE__ */ n(function() {
      try {
        !o && r.return != null && r.return();
      } finally {
        if (u) throw a;
      }
    }, "f") };
  }
  n(cF, "_createForOfIteratorHelper");
  function fF(e, t) {
    if (e) {
      if (typeof e == "string") return Rd(e, t);
      var r = Object.prototype.toString.call(e).slice(8, -1);
      if (r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set") return Array.from(e);
      if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Rd(e, t);
    }
  }
  n(fF, "_unsupportedIterableToArray");
  function Rd(e, t) {
    (t == null || t > e.length) && (t = e.length);
    for (var r = 0, i = new Array(t); r < t; r++) i[r] = e[r];
    return i;
  }
  n(Rd, "_arrayLikeToArray");
  function kd(e, t, r, i, s, o, u) {
    try {
      var a = e[o](u), l = a.value;
    } catch (c) {
      r(c);
      return;
    }
    a.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(kd, "asyncGeneratorStep");
  function Bd(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var o = e.apply(t, r);
        function u(l) {
          kd(o, i, s, u, a, "next", l);
        }
        n(u, "_next");
        function a(l) {
          kd(o, i, s, u, a, "throw", l);
        }
        n(a, "_throw"), u(void 0);
      });
    };
  }
  n(Bd, "_asyncToGenerator");
  var Lu = Sd(), hF = ["suggest", "format", "onState", "validate", "onRender", "type"], Od = /* @__PURE__ */ n(() => {
  }, "noop");
  function Nt() {
    return Nu.apply(this, arguments);
  }
  n(Nt, "prompt");
  function Nu() {
    return Nu = Bd(function* (e = [], {
      onSubmit: t = Od,
      onCancel: r = Od
    } = {}) {
      let i = {}, s = Nt._override || {};
      e = [].concat(e);
      let o, u, a, l, c, h, p = /* @__PURE__ */ function() {
        var y = Bd(function* (_, C, w = !1) {
          if (!(!w && _.validate && _.validate(C) !== !0))
            return _.format ? yield _.format(C, i) : C;
        });
        return /* @__PURE__ */ n(function(C, w) {
          return y.apply(this, arguments);
        }, "getFormattedAnswer");
      }();
      var d = cF(e), f;
      try {
        for (d.s(); !(f = d.n()).done; ) {
          u = f.value;
          var m = u;
          if (l = m.name, c = m.type, typeof c == "function" && (c = yield c(o, Td({}, i), u), u.type = c), !!c) {
            for (let y in u) {
              if (hF.includes(y)) continue;
              let _ = u[y];
              u[y] = typeof _ == "function" ? yield _(o, Td({}, i), h) : _;
            }
            if (h = u, typeof u.message != "string")
              throw new Error("prompt message is required");
            var v = u;
            if (l = v.name, c = v.type, Lu[c] === void 0)
              throw new Error(`prompt type (${c}) is not defined`);
            if (s[u.name] !== void 0 && (o = yield p(u, s[u.name]), o !== void 0)) {
              i[l] = o;
              continue;
            }
            try {
              o = Nt._injected ? dF(Nt._injected, u.initial) : yield Lu[c](u), i[l] = o = yield p(u, o, !0), a = yield t(u, o, i);
            } catch {
              a = !(yield r(u, i));
            }
            if (a) return i;
          }
        }
      } catch (y) {
        d.e(y);
      } finally {
        d.f();
      }
      return i;
    }), Nu.apply(this, arguments);
  }
  n(Nu, "_prompt");
  function dF(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  n(dF, "getInjectedAnswer");
  function pF(e) {
    Nt._injected = (Nt._injected || []).concat(e);
  }
  n(pF, "inject");
  function DF(e) {
    Nt._override = Object.assign({}, e);
  }
  n(DF, "override");
  Pd.exports = Object.assign(Nt, {
    prompt: Nt,
    prompts: Lu,
    inject: pF,
    override: DF
  });
});

// ../node_modules/prompts/lib/util/action.js
var jd = g((lM, Md) => {
  "use strict";
  Md.exports = (e, t) => {
    if (!(e.meta && e.name !== "escape")) {
      if (e.ctrl) {
        if (e.name === "a") return "first";
        if (e.name === "c" || e.name === "d") return "abort";
        if (e.name === "e") return "last";
        if (e.name === "g") return "reset";
      }
      if (t) {
        if (e.name === "j") return "down";
        if (e.name === "k") return "up";
      }
      return e.name === "return" || e.name === "enter" ? "submit" : e.name === "backspace" ? "delete" : e.name === "delete" ? "deleteForward" :
      e.name === "abort" ? "abort" : e.name === "escape" ? "exit" : e.name === "tab" ? "next" : e.name === "pagedown" ? "nextPage" : e.name ===
      "pageup" ? "prevPage" : e.name === "home" ? "home" : e.name === "end" ? "end" : e.name === "up" ? "up" : e.name === "down" ? "down" : e.
      name === "right" ? "right" : e.name === "left" ? "left" : !1;
    }
  };
});

// ../node_modules/prompts/lib/util/strip.js
var Zn = g((cM, Id) => {
  "use strict";
  Id.exports = (e) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
    ].join("|"), r = new RegExp(t, "g");
    return typeof e == "string" ? e.replace(r, "") : e;
  };
});

// ../node_modules/prompts/lib/util/clear.js
var Ud = g((fM, Nd) => {
  "use strict";
  var mF = Zn(), { erase: Ld, cursor: yF } = he(), gF = /* @__PURE__ */ n((e) => [...mF(e)].length, "width");
  Nd.exports = function(e, t) {
    if (!t) return Ld.line + yF.to(0);
    let r = 0, i = e.split(/\r?\n/);
    for (let s of i)
      r += 1 + Math.floor(Math.max(gF(s) - 1, 0) / t);
    return Ld.lines(r);
  };
});

// ../node_modules/prompts/lib/util/figures.js
var Uu = g((dM, Wd) => {
  "use strict";
  var Ai = {
    arrowUp: "\u2191",
    arrowDown: "\u2193",
    arrowLeft: "\u2190",
    arrowRight: "\u2192",
    radioOn: "\u25C9",
    radioOff: "\u25EF",
    tick: "\u2714",
    cross: "\u2716",
    ellipsis: "\u2026",
    pointerSmall: "\u203A",
    line: "\u2500",
    pointer: "\u276F"
  }, bF = {
    arrowUp: Ai.arrowUp,
    arrowDown: Ai.arrowDown,
    arrowLeft: Ai.arrowLeft,
    arrowRight: Ai.arrowRight,
    radioOn: "(*)",
    radioOff: "( )",
    tick: "\u221A",
    cross: "\xD7",
    ellipsis: "...",
    pointerSmall: "\xBB",
    line: "\u2500",
    pointer: ">"
  }, wF = process.platform === "win32" ? bF : Ai;
  Wd.exports = wF;
});

// ../node_modules/prompts/lib/util/style.js
var Hd = g((pM, $d) => {
  "use strict";
  var kr = ce(), or = Uu(), Wu = Object.freeze({
    password: { scale: 1, render: /* @__PURE__ */ n((e) => "*".repeat(e.length), "render") },
    emoji: { scale: 2, render: /* @__PURE__ */ n((e) => "\u{1F603}".repeat(e.length), "render") },
    invisible: { scale: 0, render: /* @__PURE__ */ n((e) => "", "render") },
    default: { scale: 1, render: /* @__PURE__ */ n((e) => `${e}`, "render") }
  }), vF = /* @__PURE__ */ n((e) => Wu[e] || Wu.default, "render"), Ti = Object.freeze({
    aborted: kr.red(or.cross),
    done: kr.green(or.tick),
    exited: kr.yellow(or.cross),
    default: kr.cyan("?")
  }), _F = /* @__PURE__ */ n((e, t, r) => t ? Ti.aborted : r ? Ti.exited : e ? Ti.done : Ti.default, "symbol"), EF = /* @__PURE__ */ n((e) => kr.
  gray(e ? or.ellipsis : or.pointerSmall), "delimiter"), CF = /* @__PURE__ */ n((e, t) => kr.gray(e ? t ? or.pointerSmall : "+" : or.line), "\
item");
  $d.exports = {
    styles: Wu,
    render: vF,
    symbols: Ti,
    symbol: _F,
    delimiter: EF,
    item: CF
  };
});

// ../node_modules/prompts/lib/util/lines.js
var Vd = g((mM, zd) => {
  "use strict";
  var FF = Zn();
  zd.exports = function(e, t) {
    let r = String(FF(e) || "").split(/\r?\n/);
    return t ? r.map((i) => Math.ceil(i.length / t)).reduce((i, s) => i + s) : r.length;
  };
});

// ../node_modules/prompts/lib/util/wrap.js
var Jd = g((yM, Gd) => {
  "use strict";
  Gd.exports = (e, t = {}) => {
    let r = Number.isSafeInteger(parseInt(t.margin)) ? new Array(parseInt(t.margin)).fill(" ").join("") : t.margin || "", i = t.width;
    return (e || "").split(/\r?\n/g).map((s) => s.split(/\s+/g).reduce((o, u) => (u.length + r.length >= i || o[o.length - 1].length + u.length +
    1 < i ? o[o.length - 1] += ` ${u}` : o.push(`${r}${u}`), o), [r]).join(`
`)).join(`
`);
  };
});

// ../node_modules/prompts/lib/util/entriesToDisplay.js
var Kd = g((gM, Yd) => {
  "use strict";
  Yd.exports = (e, t, r) => {
    r = r || t;
    let i = Math.min(t - r, e - Math.floor(r / 2));
    i < 0 && (i = 0);
    let s = Math.min(i + r, t);
    return { startIndex: i, endIndex: s };
  };
});

// ../node_modules/prompts/lib/util/index.js
var Ke = g((bM, Qd) => {
  "use strict";
  Qd.exports = {
    action: jd(),
    clear: Ud(),
    style: Hd(),
    strip: Zn(),
    figures: Uu(),
    lines: Vd(),
    wrap: Jd(),
    entriesToDisplay: Kd()
  };
});

// ../node_modules/prompts/lib/elements/prompt.js
var wt = g((wM, Zd) => {
  "use strict";
  var Xd = require("readline"), { action: xF } = Ke(), SF = require("events"), { beep: AF, cursor: TF } = he(), RF = ce(), $u = class extends SF {
    static {
      n(this, "Prompt");
    }
    constructor(t = {}) {
      super(), this.firstRender = !0, this.in = t.stdin || process.stdin, this.out = t.stdout || process.stdout, this.onRender = (t.onRender ||
      (() => {
      })).bind(this);
      let r = Xd.createInterface({ input: this.in, escapeCodeTimeout: 50 });
      Xd.emitKeypressEvents(this.in, r), this.in.isTTY && this.in.setRawMode(!0);
      let i = ["SelectPrompt", "MultiselectPrompt"].indexOf(this.constructor.name) > -1, s = /* @__PURE__ */ n((o, u) => {
        let a = xF(u, i);
        a === !1 ? this._ && this._(o, u) : typeof this[a] == "function" ? this[a](u) : this.bell();
      }, "keypress");
      this.close = () => {
        this.out.write(TF.show), this.in.removeListener("keypress", s), this.in.isTTY && this.in.setRawMode(!1), r.close(), this.emit(this.aborted ?
        "abort" : this.exited ? "exit" : "submit", this.value), this.closed = !0;
      }, this.in.on("keypress", s);
    }
    fire() {
      this.emit("state", {
        value: this.value,
        aborted: !!this.aborted,
        exited: !!this.exited
      });
    }
    bell() {
      this.out.write(AF);
    }
    render() {
      this.onRender(RF), this.firstRender && (this.firstRender = !1);
    }
  };
  Zd.exports = $u;
});

// ../node_modules/prompts/lib/elements/text.js
var tp = g((_M, ep) => {
  var es = ce(), kF = wt(), { erase: BF, cursor: Ri } = he(), { style: Hu, clear: zu, lines: OF, figures: PF } = Ke(), Vu = class extends kF {
    static {
      n(this, "TextPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = Hu.render(t.style), this.scale = this.transform.scale, this.msg = t.message, this.initial = t.initial || "",
      this.validator = t.validate || (() => !0), this.value = "", this.errorMsg = t.error || "Please Enter A Valid Value", this.cursor = +!!this.
      initial, this.cursorOffset = 0, this.clear = zu("", this.out.columns), this.render();
    }
    set value(t) {
      !t && this.initial ? (this.placeholder = !0, this.rendered = es.gray(this.transform.render(this.initial))) : (this.placeholder = !1, this.
      rendered = this.transform.render(t)), this._value = t, this.fire();
    }
    get value() {
      return this._value;
    }
    reset() {
      this.value = "", this.cursor = +!!this.initial, this.cursorOffset = 0, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.value = this.value || this.initial, this.done = this.aborted = !0, this.error = !1, this.red = !1, this.fire(), this.render(), this.
      out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (this.value = this.value || this.initial, this.cursorOffset = 0, this.cursor = this.rendered.length, await this.validate(), this.error) {
        this.red = !0, this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    next() {
      if (!this.placeholder) return this.bell();
      this.value = this.initial, this.cursor = this.rendered.length, this.fire(), this.render();
    }
    moveCursor(t) {
      this.placeholder || (this.cursor = this.cursor + t, this.cursorOffset += t);
    }
    _(t, r) {
      let i = this.value.slice(0, this.cursor), s = this.value.slice(this.cursor);
      this.value = `${i}${t}${s}`, this.red = !1, this.cursor = this.placeholder ? 0 : i.length + 1, this.render();
    }
    delete() {
      if (this.isCursorAtStart()) return this.bell();
      let t = this.value.slice(0, this.cursor - 1), r = this.value.slice(this.cursor);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtStart() ? this.cursorOffset = 0 : (this.cursorOffset++, this.moveCursor(-1)), this.
      render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      let t = this.value.slice(0, this.cursor), r = this.value.slice(this.cursor + 1);
      this.value = `${t}${r}`, this.red = !1, this.isCursorAtEnd() ? this.cursorOffset = 0 : this.cursorOffset++, this.render();
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length, this.render();
    }
    left() {
      if (this.cursor <= 0 || this.placeholder) return this.bell();
      this.moveCursor(-1), this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length || this.placeholder) return this.bell();
      this.moveCursor(1), this.render();
    }
    isCursorAtStart() {
      return this.cursor === 0 || this.placeholder && this.cursor === 1;
    }
    isCursorAtEnd() {
      return this.cursor === this.rendered.length || this.placeholder && this.cursor === this.rendered.length + 1;
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(Ri.down(OF(this.outputError, this.out.columns) - 1) + zu(this.
      outputError, this.out.columns)), this.out.write(zu(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        Hu.symbol(this.done, this.aborted),
        es.bold(this.msg),
        Hu.delimiter(this.done),
        this.red ? es.red(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : PF.pointerSmall} ${es.red().italic(r)}`, "")), this.out.write(BF.line + Ri.to(0) + this.outputText + Ri.save + this.outputError +
      Ri.restore + Ri.move(this.cursorOffset, 0)));
    }
  };
  ep.exports = Vu;
});

// ../node_modules/prompts/lib/elements/select.js
var sp = g((CM, np) => {
  "use strict";
  var vt = ce(), qF = wt(), { style: rp, clear: ip, figures: ts, wrap: MF, entriesToDisplay: jF } = Ke(), { cursor: IF } = he(), Gu = class extends qF {
    static {
      n(this, "SelectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.hint = t.hint || "- Use arrow-keys. Return to submit.", this.warn = t.warn || "- This option is d\
isabled", this.cursor = t.initial || 0, this.choices = t.choices.map((r, i) => (typeof r == "string" && (r = { title: r, value: i }), {
        title: r && (r.title || r.value || r),
        value: r && (r.value === void 0 ? i : r.value),
        description: r && r.description,
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.optionsPerPage = t.optionsPerPage || 10, this.value = (this.choices[this.cursor] || {}).value, this.clear = ip("", this.out.
      columns), this.render();
    }
    moveCursor(t) {
      this.cursor = t, this.value = this.choices[t].value, this.fire();
    }
    reset() {
      this.moveCursor(0), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.selection.disabled ? this.bell() : (this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.moveCursor(0), this.render();
    }
    last() {
      this.moveCursor(this.choices.length - 1), this.render();
    }
    up() {
      this.cursor === 0 ? this.moveCursor(this.choices.length - 1) : this.moveCursor(this.cursor - 1), this.render();
    }
    down() {
      this.cursor === this.choices.length - 1 ? this.moveCursor(0) : this.moveCursor(this.cursor + 1), this.render();
    }
    next() {
      this.moveCursor((this.cursor + 1) % this.choices.length), this.render();
    }
    _(t, r) {
      if (t === " ") return this.submit();
    }
    get selection() {
      return this.choices[this.cursor];
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write(IF.hide) : this.out.write(ip(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = jF(this.cursor, this.choices.length, this.optionsPerPage);
      if (this.outputText = [
        rp.symbol(this.done, this.aborted),
        vt.bold(this.msg),
        rp.delimiter(!1),
        this.done ? this.selection.title : this.selection.disabled ? vt.yellow(this.warn) : vt.gray(this.hint)
      ].join(" "), !this.done) {
        this.outputText += `
`;
        for (let i = t; i < r; i++) {
          let s, o, u = "", a = this.choices[i];
          i === t && t > 0 ? o = ts.arrowUp : i === r - 1 && r < this.choices.length ? o = ts.arrowDown : o = " ", a.disabled ? (s = this.cursor ===
          i ? vt.gray().underline(a.title) : vt.strikethrough().gray(a.title), o = (this.cursor === i ? vt.bold().gray(ts.pointer) + " " : "\
  ") + o) : (s = this.cursor === i ? vt.cyan().underline(a.title) : a.title, o = (this.cursor === i ? vt.cyan(ts.pointer) + " " : "  ") + o,
          a.description && this.cursor === i && (u = ` - ${a.description}`, (o.length + s.length + u.length >= this.out.columns || a.description.
          split(/\r?\n/).length > 1) && (u = `
` + MF(a.description, { margin: 3, width: this.out.columns })))), this.outputText += `${o} ${s}${vt.gray(u)}
`;
        }
      }
      this.out.write(this.outputText);
    }
  };
  np.exports = Gu;
});

// ../node_modules/prompts/lib/elements/toggle.js
var lp = g((xM, ap) => {
  var rs = ce(), LF = wt(), { style: op, clear: NF } = Ke(), { cursor: up, erase: UF } = he(), Ju = class extends LF {
    static {
      n(this, "TogglePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = !!t.initial, this.active = t.active || "on", this.inactive = t.inactive || "off", this.initialValue =
      this.value, this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    deactivate() {
      if (this.value === !1) return this.bell();
      this.value = !1, this.render();
    }
    activate() {
      if (this.value === !0) return this.bell();
      this.value = !0, this.render();
    }
    delete() {
      this.deactivate();
    }
    left() {
      this.deactivate();
    }
    right() {
      this.activate();
    }
    down() {
      this.deactivate();
    }
    up() {
      this.activate();
    }
    next() {
      this.value = !this.value, this.fire(), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.value = !this.value;
      else if (t === "1")
        this.value = !0;
      else if (t === "0")
        this.value = !1;
      else return this.bell();
      this.render();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(up.hide) : this.out.write(NF(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        op.symbol(this.done, this.aborted),
        rs.bold(this.msg),
        op.delimiter(this.done),
        this.value ? this.inactive : rs.cyan().underline(this.inactive),
        rs.gray("/"),
        this.value ? rs.cyan().underline(this.active) : this.active
      ].join(" "), this.out.write(UF.line + up.to(0) + this.outputText));
    }
  };
  ap.exports = Ju;
});

// ../node_modules/prompts/lib/dateparts/datepart.js
var ot = g((AM, cp) => {
  "use strict";
  var Yu = class e {
    static {
      n(this, "DatePart");
    }
    constructor({ token: t, date: r, parts: i, locales: s }) {
      this.token = t, this.date = r || /* @__PURE__ */ new Date(), this.parts = i || [this], this.locales = s || {};
    }
    up() {
    }
    down() {
    }
    next() {
      let t = this.parts.indexOf(this);
      return this.parts.find((r, i) => i > t && r instanceof e);
    }
    setTo(t) {
    }
    prev() {
      let t = [].concat(this.parts).reverse(), r = t.indexOf(this);
      return t.find((i, s) => s > r && i instanceof e);
    }
    toString() {
      return String(this.date);
    }
  };
  cp.exports = Yu;
});

// ../node_modules/prompts/lib/dateparts/meridiem.js
var hp = g((RM, fp) => {
  "use strict";
  var WF = ot(), Ku = class extends WF {
    static {
      n(this, "Meridiem");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours((this.date.getHours() + 12) % 24);
    }
    down() {
      this.up();
    }
    toString() {
      let t = this.date.getHours() > 12 ? "pm" : "am";
      return /\A/.test(this.token) ? t.toUpperCase() : t;
    }
  };
  fp.exports = Ku;
});

// ../node_modules/prompts/lib/dateparts/day.js
var pp = g((BM, dp) => {
  "use strict";
  var $F = ot(), HF = /* @__PURE__ */ n((e) => (e = e % 10, e === 1 ? "st" : e === 2 ? "nd" : e === 3 ? "rd" : "th"), "pos"), Qu = class extends $F {
    static {
      n(this, "Day");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setDate(this.date.getDate() + 1);
    }
    down() {
      this.date.setDate(this.date.getDate() - 1);
    }
    setTo(t) {
      this.date.setDate(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getDate(), r = this.date.getDay();
      return this.token === "DD" ? String(t).padStart(2, "0") : this.token === "Do" ? t + HF(t) : this.token === "d" ? r + 1 : this.token ===
      "ddd" ? this.locales.weekdaysShort[r] : this.token === "dddd" ? this.locales.weekdays[r] : t;
    }
  };
  dp.exports = Qu;
});

// ../node_modules/prompts/lib/dateparts/hours.js
var mp = g((PM, Dp) => {
  "use strict";
  var zF = ot(), Xu = class extends zF {
    static {
      n(this, "Hours");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setHours(this.date.getHours() + 1);
    }
    down() {
      this.date.setHours(this.date.getHours() - 1);
    }
    setTo(t) {
      this.date.setHours(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getHours();
      return /h/.test(this.token) && (t = t % 12 || 12), this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  Dp.exports = Xu;
});

// ../node_modules/prompts/lib/dateparts/milliseconds.js
var gp = g((MM, yp) => {
  "use strict";
  var VF = ot(), Zu = class extends VF {
    static {
      n(this, "Milliseconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMilliseconds(this.date.getMilliseconds() + 1);
    }
    down() {
      this.date.setMilliseconds(this.date.getMilliseconds() - 1);
    }
    setTo(t) {
      this.date.setMilliseconds(parseInt(t.substr(-this.token.length)));
    }
    toString() {
      return String(this.date.getMilliseconds()).padStart(4, "0").substr(0, this.token.length);
    }
  };
  yp.exports = Zu;
});

// ../node_modules/prompts/lib/dateparts/minutes.js
var wp = g((IM, bp) => {
  "use strict";
  var GF = ot(), ea = class extends GF {
    static {
      n(this, "Minutes");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMinutes(this.date.getMinutes() + 1);
    }
    down() {
      this.date.setMinutes(this.date.getMinutes() - 1);
    }
    setTo(t) {
      this.date.setMinutes(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getMinutes();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  bp.exports = ea;
});

// ../node_modules/prompts/lib/dateparts/month.js
var _p = g((NM, vp) => {
  "use strict";
  var JF = ot(), ta = class extends JF {
    static {
      n(this, "Month");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setMonth(this.date.getMonth() + 1);
    }
    down() {
      this.date.setMonth(this.date.getMonth() - 1);
    }
    setTo(t) {
      t = parseInt(t.substr(-2)) - 1, this.date.setMonth(t < 0 ? 0 : t);
    }
    toString() {
      let t = this.date.getMonth(), r = this.token.length;
      return r === 2 ? String(t + 1).padStart(2, "0") : r === 3 ? this.locales.monthsShort[t] : r === 4 ? this.locales.months[t] : String(t +
      1);
    }
  };
  vp.exports = ta;
});

// ../node_modules/prompts/lib/dateparts/seconds.js
var Cp = g((WM, Ep) => {
  "use strict";
  var YF = ot(), ra = class extends YF {
    static {
      n(this, "Seconds");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setSeconds(this.date.getSeconds() + 1);
    }
    down() {
      this.date.setSeconds(this.date.getSeconds() - 1);
    }
    setTo(t) {
      this.date.setSeconds(parseInt(t.substr(-2)));
    }
    toString() {
      let t = this.date.getSeconds();
      return this.token.length > 1 ? String(t).padStart(2, "0") : t;
    }
  };
  Ep.exports = ra;
});

// ../node_modules/prompts/lib/dateparts/year.js
var xp = g((HM, Fp) => {
  "use strict";
  var KF = ot(), ia = class extends KF {
    static {
      n(this, "Year");
    }
    constructor(t = {}) {
      super(t);
    }
    up() {
      this.date.setFullYear(this.date.getFullYear() + 1);
    }
    down() {
      this.date.setFullYear(this.date.getFullYear() - 1);
    }
    setTo(t) {
      this.date.setFullYear(t.substr(-4));
    }
    toString() {
      let t = String(this.date.getFullYear()).padStart(4, "0");
      return this.token.length === 2 ? t.substr(-2) : t;
    }
  };
  Fp.exports = ia;
});

// ../node_modules/prompts/lib/dateparts/index.js
var Ap = g((VM, Sp) => {
  "use strict";
  Sp.exports = {
    DatePart: ot(),
    Meridiem: hp(),
    Day: pp(),
    Hours: mp(),
    Milliseconds: gp(),
    Minutes: wp(),
    Month: _p(),
    Seconds: Cp(),
    Year: xp()
  };
});

// ../node_modules/prompts/lib/elements/date.js
var qp = g((GM, Pp) => {
  "use strict";
  var na = ce(), QF = wt(), { style: Tp, clear: Rp, figures: XF } = Ke(), { erase: ZF, cursor: kp } = he(), { DatePart: Bp, Meridiem: ex, Day: tx,
  Hours: rx, Milliseconds: ix, Minutes: nx, Month: sx, Seconds: ox, Year: ux } = Ap(), ax = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4}|d)|(M{1,4})|(YY(?:YY)?)|([aA])|([Hh]{1,2})|(m{1,2})|(s{1,2})|(S{1,4})|./g,
  Op = {
    1: ({ token: e }) => e.replace(/\\(.)/g, "$1"),
    2: (e) => new tx(e),
    // Day // TODO
    3: (e) => new sx(e),
    // Month
    4: (e) => new ux(e),
    // Year
    5: (e) => new ex(e),
    // AM/PM // TODO (special)
    6: (e) => new rx(e),
    // Hours
    7: (e) => new nx(e),
    // Minutes
    8: (e) => new ox(e),
    // Seconds
    9: (e) => new ix(e)
    // Fractional seconds
  }, lx = {
    months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
    monthsShort: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
    weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
    weekdaysShort: "Sun,Mon,Tue,Wed,Thu,Fri,Sat".split(",")
  }, sa = class extends QF {
    static {
      n(this, "DatePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = 0, this.typed = "", this.locales = Object.assign(lx, t.locales), this._date = t.initial ||
      /* @__PURE__ */ new Date(), this.errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.mask =
      t.mask || "YYYY-MM-DD HH:mm:ss", this.clear = Rp("", this.out.columns), this.render();
    }
    get value() {
      return this.date;
    }
    get date() {
      return this._date;
    }
    set date(t) {
      t && this._date.setTime(t.getTime());
    }
    set mask(t) {
      let r;
      for (this.parts = []; r = ax.exec(t); ) {
        let s = r.shift(), o = r.findIndex((u) => u != null);
        this.parts.push(o in Op ? Op[o]({ token: r[o] || s, date: this.date, parts: this.parts, locales: this.locales }) : r[o] || s);
      }
      let i = this.parts.reduce((s, o) => (typeof o == "string" && typeof s[s.length - 1] == "string" ? s[s.length - 1] += o : s.push(o), s),
      []);
      this.parts.splice(0), this.parts.push(...i), this.reset();
    }
    moveCursor(t) {
      this.typed = "", this.cursor = t, this.fire();
    }
    reset() {
      this.moveCursor(this.parts.findIndex((t) => t instanceof Bp)), this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    up() {
      this.typed = "", this.parts[this.cursor].up(), this.render();
    }
    down() {
      this.typed = "", this.parts[this.cursor].down(), this.render();
    }
    left() {
      let t = this.parts[this.cursor].prev();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    right() {
      let t = this.parts[this.cursor].next();
      if (t == null) return this.bell();
      this.moveCursor(this.parts.indexOf(t)), this.render();
    }
    next() {
      let t = this.parts[this.cursor].next();
      this.moveCursor(t ? this.parts.indexOf(t) : this.parts.findIndex((r) => r instanceof Bp)), this.render();
    }
    _(t) {
      /\d/.test(t) && (this.typed += t, this.parts[this.cursor].setTo(this.typed), this.render());
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(kp.hide) : this.out.write(Rp(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        Tp.symbol(this.done, this.aborted),
        na.bold(this.msg),
        Tp.delimiter(!1),
        this.parts.reduce((t, r, i) => t.concat(i === this.cursor && !this.done ? na.cyan().underline(r.toString()) : r), []).join("")
      ].join(" "), this.error && (this.outputText += this.errorMsg.split(`
`).reduce(
        (t, r, i) => t + `
${i ? " " : XF.pointerSmall} ${na.red().italic(r)}`,
        ""
      )), this.out.write(ZF.line + kp.to(0) + this.outputText));
    }
  };
  Pp.exports = sa;
});

// ../node_modules/prompts/lib/elements/number.js
var Lp = g((YM, Ip) => {
  var is = ce(), cx = wt(), { cursor: ns, erase: fx } = he(), { style: oa, figures: hx, clear: Mp, lines: dx } = Ke(), px = /[0-9]/, ua = /* @__PURE__ */ n(
  (e) => e !== void 0, "isDef"), jp = /* @__PURE__ */ n((e, t) => {
    let r = Math.pow(10, t);
    return Math.round(e * r) / r;
  }, "round"), aa = class extends cx {
    static {
      n(this, "NumberPrompt");
    }
    constructor(t = {}) {
      super(t), this.transform = oa.render(t.style), this.msg = t.message, this.initial = ua(t.initial) ? t.initial : "", this.float = !!t.float,
      this.round = t.round || 2, this.inc = t.increment || 1, this.min = ua(t.min) ? t.min : -1 / 0, this.max = ua(t.max) ? t.max : 1 / 0, this.
      errorMsg = t.error || "Please Enter A Valid Value", this.validator = t.validate || (() => !0), this.color = "cyan", this.value = "", this.
      typed = "", this.lastHit = 0, this.render();
    }
    set value(t) {
      !t && t !== 0 ? (this.placeholder = !0, this.rendered = is.gray(this.transform.render(`${this.initial}`)), this._value = "") : (this.placeholder =
      !1, this.rendered = this.transform.render(`${jp(t, this.round)}`), this._value = jp(t, this.round)), this.fire();
    }
    get value() {
      return this._value;
    }
    parse(t) {
      return this.float ? parseFloat(t) : parseInt(t);
    }
    valid(t) {
      return t === "-" || t === "." && this.float || px.test(t);
    }
    reset() {
      this.typed = "", this.value = "", this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = this.aborted = !0, this.error = !1, this.fire(), this.render(), this.out.write(`\

`), this.close();
    }
    async validate() {
      let t = await this.validator(this.value);
      typeof t == "string" && (this.errorMsg = t, t = !1), this.error = !t;
    }
    async submit() {
      if (await this.validate(), this.error) {
        this.color = "red", this.fire(), this.render();
        return;
      }
      let t = this.value;
      this.value = t !== "" ? t : this.initial, this.done = !0, this.aborted = !1, this.error = !1, this.fire(), this.render(), this.out.write(
      `
`), this.close();
    }
    up() {
      if (this.typed = "", this.value === "" && (this.value = this.min - this.inc), this.value >= this.max) return this.bell();
      this.value += this.inc, this.color = "cyan", this.fire(), this.render();
    }
    down() {
      if (this.typed = "", this.value === "" && (this.value = this.min + this.inc), this.value <= this.min) return this.bell();
      this.value -= this.inc, this.color = "cyan", this.fire(), this.render();
    }
    delete() {
      let t = this.value.toString();
      if (t.length === 0) return this.bell();
      this.value = this.parse(t = t.slice(0, -1)) || "", this.value !== "" && this.value < this.min && (this.value = this.min), this.color =
      "cyan", this.fire(), this.render();
    }
    next() {
      this.value = this.initial, this.fire(), this.render();
    }
    _(t, r) {
      if (!this.valid(t)) return this.bell();
      let i = Date.now();
      if (i - this.lastHit > 1e3 && (this.typed = ""), this.typed += t, this.lastHit = i, this.color = "cyan", t === ".") return this.fire();
      this.value = Math.min(this.parse(this.typed), this.max), this.value > this.max && (this.value = this.max), this.value < this.min && (this.
      value = this.min), this.fire(), this.render();
    }
    render() {
      this.closed || (this.firstRender || (this.outputError && this.out.write(ns.down(dx(this.outputError, this.out.columns) - 1) + Mp(this.
      outputError, this.out.columns)), this.out.write(Mp(this.outputText, this.out.columns))), super.render(), this.outputError = "", this.outputText =
      [
        oa.symbol(this.done, this.aborted),
        is.bold(this.msg),
        oa.delimiter(this.done),
        !this.done || !this.done && !this.placeholder ? is[this.color]().underline(this.rendered) : this.rendered
      ].join(" "), this.error && (this.outputError += this.errorMsg.split(`
`).reduce((t, r, i) => t + `
${i ? " " : hx.pointerSmall} ${is.red().italic(r)}`, "")), this.out.write(fx.line + ns.to(0) + this.outputText + ns.save + this.outputError +
      ns.restore));
    }
  };
  Ip.exports = aa;
});

// ../node_modules/prompts/lib/elements/multiselect.js
var ca = g((QM, Wp) => {
  "use strict";
  var ut = ce(), { cursor: Dx } = he(), mx = wt(), { clear: Np, figures: Ut, style: Up, wrap: yx, entriesToDisplay: gx } = Ke(), la = class extends mx {
    static {
      n(this, "MultiselectPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.cursor = t.cursor || 0, this.scrollIndex = t.cursor || 0, this.hint = t.hint || "", this.warn = t.
      warn || "- This option is disabled -", this.minSelected = t.min, this.showMinError = !1, this.maxChoices = t.max, this.instructions = t.
      instructions, this.optionsPerPage = t.optionsPerPage || 10, this.value = t.choices.map((r, i) => (typeof r == "string" && (r = { title: r,
      value: i }), {
        title: r && (r.title || r.value || r),
        description: r && r.description,
        value: r && (r.value === void 0 ? i : r.value),
        selected: r && r.selected,
        disabled: r && r.disabled
      })), this.clear = Np("", this.out.columns), t.overrideRender || this.render();
    }
    reset() {
      this.value.map((t) => !t.selected), this.cursor = 0, this.fire(), this.render();
    }
    selected() {
      return this.value.filter((t) => t.selected);
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      let t = this.value.filter((r) => r.selected);
      this.minSelected && t.length < this.minSelected ? (this.showMinError = !0, this.render()) : (this.done = !0, this.aborted = !1, this.fire(),
      this.render(), this.out.write(`
`), this.close());
    }
    first() {
      this.cursor = 0, this.render();
    }
    last() {
      this.cursor = this.value.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.value.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.value.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.value.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.value[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.value[this.cursor].selected = !0, this.render();
    }
    handleSpaceToggle() {
      let t = this.value[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    toggleAll() {
      if (this.maxChoices !== void 0 || this.value[this.cursor].disabled)
        return this.bell();
      let t = !this.value[this.cursor].selected;
      this.value.filter((r) => !r.disabled).forEach((r) => r.selected = t), this.render();
    }
    _(t, r) {
      if (t === " ")
        this.handleSpaceToggle();
      else if (t === "a")
        this.toggleAll();
      else
        return this.bell();
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Ut.arrowUp}/${Ut.arrowDown}: Highlight option
    ${Ut.arrowLeft}/${Ut.arrowRight}/[space]: Toggle selection
` + (this.maxChoices === void 0 ? `    a: Toggle all
` : "") + "    enter/return: Complete answer" : "";
    }
    renderOption(t, r, i, s) {
      let o = (r.selected ? ut.green(Ut.radioOn) : Ut.radioOff) + " " + s + " ", u, a;
      return r.disabled ? u = t === i ? ut.gray().underline(r.title) : ut.strikethrough().gray(r.title) : (u = t === i ? ut.cyan().underline(
      r.title) : r.title, t === i && r.description && (a = ` - ${r.description}`, (o.length + u.length + a.length >= this.out.columns || r.description.
      split(/\r?\n/).length > 1) && (a = `
` + yx(r.description, { margin: o.length, width: this.out.columns })))), o + u + ut.gray(a || "");
    }
    // shared with autocompleteMultiselect
    paginateOptions(t) {
      if (t.length === 0)
        return ut.red("No matches for this query.");
      let { startIndex: r, endIndex: i } = gx(this.cursor, t.length, this.optionsPerPage), s, o = [];
      for (let u = r; u < i; u++)
        u === r && r > 0 ? s = Ut.arrowUp : u === i - 1 && i < t.length ? s = Ut.arrowDown : s = " ", o.push(this.renderOption(this.cursor, t[u],
        u, s));
      return `
` + o.join(`
`);
    }
    // shared with autocomleteMultiselect
    renderOptions(t) {
      return this.done ? "" : this.paginateOptions(t);
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [ut.gray(this.hint), this.renderInstructions()];
      return this.value[this.cursor].disabled && t.push(ut.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(Dx.hide), super.render();
      let t = [
        Up.symbol(this.done, this.aborted),
        ut.bold(this.msg),
        Up.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += ut.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.value), this.out.write(this.clear + t), this.clear = Np(t, this.out.columns);
    }
  };
  Wp.exports = la;
});

// ../node_modules/prompts/lib/elements/autocomplete.js
var Gp = g((ZM, Vp) => {
  "use strict";
  var ki = ce(), bx = wt(), { erase: wx, cursor: $p } = he(), { style: fa, clear: Hp, figures: ha, wrap: vx, entriesToDisplay: _x } = Ke(), zp = /* @__PURE__ */ n(
  (e, t) => e[t] && (e[t].value || e[t].title || e[t]), "getVal"), Ex = /* @__PURE__ */ n((e, t) => e[t] && (e[t].title || e[t].value || e[t]),
  "getTitle"), Cx = /* @__PURE__ */ n((e, t) => {
    let r = e.findIndex((i) => i.value === t || i.title === t);
    return r > -1 ? r : void 0;
  }, "getIndex"), da = class extends bx {
    static {
      n(this, "AutocompletePrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.suggest = t.suggest, this.choices = t.choices, this.initial = typeof t.initial == "number" ? t.initial :
      Cx(t.choices, t.initial), this.select = this.initial || t.cursor || 0, this.i18n = { noMatches: t.noMatches || "no matches found" }, this.
      fallback = t.fallback || this.initial, this.clearFirst = t.clearFirst || !1, this.suggestions = [], this.input = "", this.limit = t.limit ||
      10, this.cursor = 0, this.transform = fa.render(t.style), this.scale = this.transform.scale, this.render = this.render.bind(this), this.
      complete = this.complete.bind(this), this.clear = Hp("", this.out.columns), this.complete(this.render), this.render();
    }
    set fallback(t) {
      this._fb = Number.isSafeInteger(parseInt(t)) ? parseInt(t) : t;
    }
    get fallback() {
      let t;
      return typeof this._fb == "number" ? t = this.choices[this._fb] : typeof this._fb == "string" && (t = { title: this._fb }), t || this.
      _fb || { title: this.i18n.noMatches };
    }
    moveSelect(t) {
      this.select = t, this.suggestions.length > 0 ? this.value = zp(this.suggestions, t) : this.value = this.fallback.value, this.fire();
    }
    async complete(t) {
      let r = this.completing = this.suggest(this.input, this.choices), i = await r;
      if (this.completing !== r) return;
      this.suggestions = i.map((o, u, a) => ({ title: Ex(a, u), value: zp(a, u), description: o.description })), this.completing = !1;
      let s = Math.max(i.length - 1, 0);
      this.moveSelect(Math.min(s, this.select)), t && t();
    }
    reset() {
      this.input = "", this.complete(() => {
        this.moveSelect(this.initial !== void 0 ? this.initial : 0), this.render();
      }), this.render();
    }
    exit() {
      this.clearFirst && this.input.length > 0 ? this.reset() : (this.done = this.exited = !0, this.aborted = !1, this.fire(), this.render(),
      this.out.write(`
`), this.close());
    }
    abort() {
      this.done = this.aborted = !0, this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.done = !0, this.aborted = this.exited = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      let i = this.input.slice(0, this.cursor), s = this.input.slice(this.cursor);
      this.input = `${i}${t}${s}`, this.cursor = i.length + 1, this.complete(this.render), this.render();
    }
    delete() {
      if (this.cursor === 0) return this.bell();
      let t = this.input.slice(0, this.cursor - 1), r = this.input.slice(this.cursor);
      this.input = `${t}${r}`, this.complete(this.render), this.cursor = this.cursor - 1, this.render();
    }
    deleteForward() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      let t = this.input.slice(0, this.cursor), r = this.input.slice(this.cursor + 1);
      this.input = `${t}${r}`, this.complete(this.render), this.render();
    }
    first() {
      this.moveSelect(0), this.render();
    }
    last() {
      this.moveSelect(this.suggestions.length - 1), this.render();
    }
    up() {
      this.select === 0 ? this.moveSelect(this.suggestions.length - 1) : this.moveSelect(this.select - 1), this.render();
    }
    down() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    next() {
      this.select === this.suggestions.length - 1 ? this.moveSelect(0) : this.moveSelect(this.select + 1), this.render();
    }
    nextPage() {
      this.moveSelect(Math.min(this.select + this.limit, this.suggestions.length - 1)), this.render();
    }
    prevPage() {
      this.moveSelect(Math.max(this.select - this.limit, 0)), this.render();
    }
    left() {
      if (this.cursor <= 0) return this.bell();
      this.cursor = this.cursor - 1, this.render();
    }
    right() {
      if (this.cursor * this.scale >= this.rendered.length) return this.bell();
      this.cursor = this.cursor + 1, this.render();
    }
    renderOption(t, r, i, s) {
      let o, u = i ? ha.arrowUp : s ? ha.arrowDown : " ", a = r ? ki.cyan().underline(t.title) : t.title;
      return u = (r ? ki.cyan(ha.pointer) + " " : "  ") + u, t.description && (o = ` - ${t.description}`, (u.length + a.length + o.length >=
      this.out.columns || t.description.split(/\r?\n/).length > 1) && (o = `
` + vx(t.description, { margin: 3, width: this.out.columns }))), u + " " + a + ki.gray(o || "");
    }
    render() {
      if (this.closed) return;
      this.firstRender ? this.out.write($p.hide) : this.out.write(Hp(this.outputText, this.out.columns)), super.render();
      let { startIndex: t, endIndex: r } = _x(this.select, this.choices.length, this.limit);
      if (this.outputText = [
        fa.symbol(this.done, this.aborted, this.exited),
        ki.bold(this.msg),
        fa.delimiter(this.completing),
        this.done && this.suggestions[this.select] ? this.suggestions[this.select].title : this.rendered = this.transform.render(this.input)
      ].join(" "), !this.done) {
        let i = this.suggestions.slice(t, r).map((s, o) => this.renderOption(
          s,
          this.select === o + t,
          o === 0 && t > 0,
          o + t === r - 1 && r < this.choices.length
        )).join(`
`);
        this.outputText += `
` + (i || ki.gray(this.fallback.title));
      }
      this.out.write(wx.line + $p.to(0) + this.outputText);
    }
  };
  Vp.exports = da;
});

// ../node_modules/prompts/lib/elements/autocompleteMultiselect.js
var Qp = g((tj, Kp) => {
  "use strict";
  var _t = ce(), { cursor: Fx } = he(), xx = ca(), { clear: Jp, style: Yp, figures: Br } = Ke(), pa = class extends xx {
    static {
      n(this, "AutocompleteMultiselectPrompt");
    }
    constructor(t = {}) {
      t.overrideRender = !0, super(t), this.inputValue = "", this.clear = Jp("", this.out.columns), this.filteredOptions = this.value, this.
      render();
    }
    last() {
      this.cursor = this.filteredOptions.length - 1, this.render();
    }
    next() {
      this.cursor = (this.cursor + 1) % this.filteredOptions.length, this.render();
    }
    up() {
      this.cursor === 0 ? this.cursor = this.filteredOptions.length - 1 : this.cursor--, this.render();
    }
    down() {
      this.cursor === this.filteredOptions.length - 1 ? this.cursor = 0 : this.cursor++, this.render();
    }
    left() {
      this.filteredOptions[this.cursor].selected = !1, this.render();
    }
    right() {
      if (this.value.filter((t) => t.selected).length >= this.maxChoices) return this.bell();
      this.filteredOptions[this.cursor].selected = !0, this.render();
    }
    delete() {
      this.inputValue.length && (this.inputValue = this.inputValue.substr(0, this.inputValue.length - 1), this.updateFilteredOptions());
    }
    updateFilteredOptions() {
      let t = this.filteredOptions[this.cursor];
      this.filteredOptions = this.value.filter((i) => this.inputValue ? !!(typeof i.title == "string" && i.title.toLowerCase().includes(this.
      inputValue.toLowerCase()) || typeof i.value == "string" && i.value.toLowerCase().includes(this.inputValue.toLowerCase())) : !0);
      let r = this.filteredOptions.findIndex((i) => i === t);
      this.cursor = r < 0 ? 0 : r, this.render();
    }
    handleSpaceToggle() {
      let t = this.filteredOptions[this.cursor];
      if (t.selected)
        t.selected = !1, this.render();
      else {
        if (t.disabled || this.value.filter((r) => r.selected).length >= this.maxChoices)
          return this.bell();
        t.selected = !0, this.render();
      }
    }
    handleInputChange(t) {
      this.inputValue = this.inputValue + t, this.updateFilteredOptions();
    }
    _(t, r) {
      t === " " ? this.handleSpaceToggle() : this.handleInputChange(t);
    }
    renderInstructions() {
      return this.instructions === void 0 || this.instructions ? typeof this.instructions == "string" ? this.instructions : `
Instructions:
    ${Br.arrowUp}/${Br.arrowDown}: Highlight option
    ${Br.arrowLeft}/${Br.arrowRight}/[space]: Toggle selection
    [a,b,c]/delete: Filter choices
    enter/return: Complete answer
` : "";
    }
    renderCurrentInput() {
      return `
Filtered results for: ${this.inputValue ? this.inputValue : _t.gray("Enter something to filter")}
`;
    }
    renderOption(t, r, i) {
      let s;
      return r.disabled ? s = t === i ? _t.gray().underline(r.title) : _t.strikethrough().gray(r.title) : s = t === i ? _t.cyan().underline(
      r.title) : r.title, (r.selected ? _t.green(Br.radioOn) : Br.radioOff) + "  " + s;
    }
    renderDoneOrInstructions() {
      if (this.done)
        return this.value.filter((r) => r.selected).map((r) => r.title).join(", ");
      let t = [_t.gray(this.hint), this.renderInstructions(), this.renderCurrentInput()];
      return this.filteredOptions.length && this.filteredOptions[this.cursor].disabled && t.push(_t.yellow(this.warn)), t.join(" ");
    }
    render() {
      if (this.closed) return;
      this.firstRender && this.out.write(Fx.hide), super.render();
      let t = [
        Yp.symbol(this.done, this.aborted),
        _t.bold(this.msg),
        Yp.delimiter(!1),
        this.renderDoneOrInstructions()
      ].join(" ");
      this.showMinError && (t += _t.red(`You must select a minimum of ${this.minSelected} choices.`), this.showMinError = !1), t += this.renderOptions(
      this.filteredOptions), this.out.write(this.clear + t), this.clear = Jp(t, this.out.columns);
    }
  };
  Kp.exports = pa;
});

// ../node_modules/prompts/lib/elements/confirm.js
var rD = g((ij, tD) => {
  var Xp = ce(), Sx = wt(), { style: Zp, clear: Ax } = Ke(), { erase: Tx, cursor: eD } = he(), Da = class extends Sx {
    static {
      n(this, "ConfirmPrompt");
    }
    constructor(t = {}) {
      super(t), this.msg = t.message, this.value = t.initial, this.initialValue = !!t.initial, this.yesMsg = t.yes || "yes", this.yesOption =
      t.yesOption || "(Y/n)", this.noMsg = t.no || "no", this.noOption = t.noOption || "(y/N)", this.render();
    }
    reset() {
      this.value = this.initialValue, this.fire(), this.render();
    }
    exit() {
      this.abort();
    }
    abort() {
      this.done = this.aborted = !0, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    submit() {
      this.value = this.value || !1, this.done = !0, this.aborted = !1, this.fire(), this.render(), this.out.write(`
`), this.close();
    }
    _(t, r) {
      return t.toLowerCase() === "y" ? (this.value = !0, this.submit()) : t.toLowerCase() === "n" ? (this.value = !1, this.submit()) : this.
      bell();
    }
    render() {
      this.closed || (this.firstRender ? this.out.write(eD.hide) : this.out.write(Ax(this.outputText, this.out.columns)), super.render(), this.
      outputText = [
        Zp.symbol(this.done, this.aborted),
        Xp.bold(this.msg),
        Zp.delimiter(this.done),
        this.done ? this.value ? this.yesMsg : this.noMsg : Xp.gray(this.initialValue ? this.yesOption : this.noOption)
      ].join(" "), this.out.write(Tx.line + eD.to(0) + this.outputText));
    }
  };
  tD.exports = Da;
});

// ../node_modules/prompts/lib/elements/index.js
var nD = g((sj, iD) => {
  "use strict";
  iD.exports = {
    TextPrompt: tp(),
    SelectPrompt: sp(),
    TogglePrompt: lp(),
    DatePrompt: qp(),
    NumberPrompt: Lp(),
    MultiselectPrompt: ca(),
    AutocompletePrompt: Gp(),
    AutocompleteMultiselectPrompt: Qp(),
    ConfirmPrompt: rD()
  };
});

// ../node_modules/prompts/lib/prompts.js
var oD = g((sD) => {
  "use strict";
  var Ue = sD, Rx = nD(), ss = /* @__PURE__ */ n((e) => e, "noop");
  function at(e, t, r = {}) {
    return new Promise((i, s) => {
      let o = new Rx[e](t), u = r.onAbort || ss, a = r.onSubmit || ss, l = r.onExit || ss;
      o.on("state", t.onState || ss), o.on("submit", (c) => i(a(c))), o.on("exit", (c) => i(l(c))), o.on("abort", (c) => s(u(c)));
    });
  }
  n(at, "toPrompt");
  Ue.text = (e) => at("TextPrompt", e);
  Ue.password = (e) => (e.style = "password", Ue.text(e));
  Ue.invisible = (e) => (e.style = "invisible", Ue.text(e));
  Ue.number = (e) => at("NumberPrompt", e);
  Ue.date = (e) => at("DatePrompt", e);
  Ue.confirm = (e) => at("ConfirmPrompt", e);
  Ue.list = (e) => {
    let t = e.separator || ",";
    return at("TextPrompt", e, {
      onSubmit: /* @__PURE__ */ n((r) => r.split(t).map((i) => i.trim()), "onSubmit")
    });
  };
  Ue.toggle = (e) => at("TogglePrompt", e);
  Ue.select = (e) => at("SelectPrompt", e);
  Ue.multiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return at("MultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  Ue.autocompleteMultiselect = (e) => {
    e.choices = [].concat(e.choices || []);
    let t = /* @__PURE__ */ n((r) => r.filter((i) => i.selected).map((i) => i.value), "toSelected");
    return at("AutocompleteMultiselectPrompt", e, {
      onAbort: t,
      onSubmit: t
    });
  };
  var kx = /* @__PURE__ */ n((e, t) => Promise.resolve(
    t.filter((r) => r.title.slice(0, e.length).toLowerCase() === e.toLowerCase())
  ), "byTitle");
  Ue.autocomplete = (e) => (e.suggest = e.suggest || kx, e.choices = [].concat(e.choices || []), at("AutocompletePrompt", e));
});

// ../node_modules/prompts/lib/index.js
var lD = g((aj, aD) => {
  "use strict";
  var ma = oD(), Bx = ["suggest", "format", "onState", "validate", "onRender", "type"], uD = /* @__PURE__ */ n(() => {
  }, "noop");
  async function Wt(e = [], { onSubmit: t = uD, onCancel: r = uD } = {}) {
    let i = {}, s = Wt._override || {};
    e = [].concat(e);
    let o, u, a, l, c, h, p = /* @__PURE__ */ n(async (d, f, m = !1) => {
      if (!(!m && d.validate && d.validate(f) !== !0))
        return d.format ? await d.format(f, i) : f;
    }, "getFormattedAnswer");
    for (u of e)
      if ({ name: l, type: c } = u, typeof c == "function" && (c = await c(o, { ...i }, u), u.type = c), !!c) {
        for (let d in u) {
          if (Bx.includes(d)) continue;
          let f = u[d];
          u[d] = typeof f == "function" ? await f(o, { ...i }, h) : f;
        }
        if (h = u, typeof u.message != "string")
          throw new Error("prompt message is required");
        if ({ name: l, type: c } = u, ma[c] === void 0)
          throw new Error(`prompt type (${c}) is not defined`);
        if (s[u.name] !== void 0 && (o = await p(u, s[u.name]), o !== void 0)) {
          i[l] = o;
          continue;
        }
        try {
          o = Wt._injected ? Ox(Wt._injected, u.initial) : await ma[c](u), i[l] = o = await p(u, o, !0), a = await t(u, o, i);
        } catch {
          a = !await r(u, i);
        }
        if (a) return i;
      }
    return i;
  }
  n(Wt, "prompt");
  function Ox(e, t) {
    let r = e.shift();
    if (r instanceof Error)
      throw r;
    return r === void 0 ? t : r;
  }
  n(Ox, "getInjectedAnswer");
  function Px(e) {
    Wt._injected = (Wt._injected || []).concat(e);
  }
  n(Px, "inject");
  function qx(e) {
    Wt._override = Object.assign({}, e);
  }
  n(qx, "override");
  aD.exports = Object.assign(Wt, { prompt: Wt, prompts: ma, inject: Px, override: qx });
});

// ../node_modules/prompts/index.js
var os = g((cj, cD) => {
  function Mx(e) {
    e = (Array.isArray(e) ? e : e.split(".")).map(Number);
    let t = 0, r = process.versions.node.split(".").map(Number);
    for (; t < e.length; t++) {
      if (r[t] > e[t]) return !1;
      if (e[t] > r[t]) return !0;
    }
    return !1;
  }
  n(Mx, "isNodeLT");
  cD.exports = Mx("8.6.0") ? qd() : lD();
});

// ../node_modules/universalify/index.js
var _e = g((va) => {
  "use strict";
  va.fromCallback = function(e) {
    return Object.defineProperty(function(...t) {
      if (typeof t[t.length - 1] == "function") e.apply(this, t);
      else
        return new Promise((r, i) => {
          e.call(
            this,
            ...t,
            (s, o) => s != null ? i(s) : r(o)
          );
        });
    }, "name", { value: e.name });
  };
  va.fromPromise = function(e) {
    return Object.defineProperty(function(...t) {
      let r = t[t.length - 1];
      if (typeof r != "function") return e.apply(this, t);
      e.apply(this, t.slice(0, -1)).then((i) => r(null, i), r);
    }, "name", { value: e.name });
  };
});

// ../node_modules/graceful-fs/polyfills.js
var ED = g((Sj, _D) => {
  var $t = require("constants"), Qx = process.cwd, fs = null, Xx = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return fs || (fs = Qx.call(process)), fs;
  };
  try {
    process.cwd();
  } catch {
  }
  typeof process.chdir == "function" && (_a = process.chdir, process.chdir = function(e) {
    fs = null, _a.call(process, e);
  }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, _a));
  var _a;
  _D.exports = Zx;
  function Zx(e) {
    $t.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && t(e), e.lutimes || r(e), e.chown = o(e.chown), e.fchown =
    o(e.fchown), e.lchown = o(e.lchown), e.chmod = i(e.chmod), e.fchmod = i(e.fchmod), e.lchmod = i(e.lchmod), e.chownSync = u(e.chownSync),
    e.fchownSync = u(e.fchownSync), e.lchownSync = u(e.lchownSync), e.chmodSync = s(e.chmodSync), e.fchmodSync = s(e.fchmodSync), e.lchmodSync =
    s(e.lchmodSync), e.stat = a(e.stat), e.fstat = a(e.fstat), e.lstat = a(e.lstat), e.statSync = l(e.statSync), e.fstatSync = l(e.fstatSync),
    e.lstatSync = l(e.lstatSync), e.chmod && !e.lchmod && (e.lchmod = function(h, p, d) {
      d && process.nextTick(d);
    }, e.lchmodSync = function() {
    }), e.chown && !e.lchown && (e.lchown = function(h, p, d, f) {
      f && process.nextTick(f);
    }, e.lchownSync = function() {
    }), Xx === "win32" && (e.rename = typeof e.rename != "function" ? e.rename : function(h) {
      function p(d, f, m) {
        var v = Date.now(), y = 0;
        h(d, f, /* @__PURE__ */ n(function _(C) {
          if (C && (C.code === "EACCES" || C.code === "EPERM" || C.code === "EBUSY") && Date.now() - v < 6e4) {
            setTimeout(function() {
              e.stat(f, function(w, E) {
                w && w.code === "ENOENT" ? h(d, f, _) : m(C);
              });
            }, y), y < 100 && (y += 10);
            return;
          }
          m && m(C);
        }, "CB"));
      }
      return n(p, "rename"), Object.setPrototypeOf && Object.setPrototypeOf(p, h), p;
    }(e.rename)), e.read = typeof e.read != "function" ? e.read : function(h) {
      function p(d, f, m, v, y, _) {
        var C;
        if (_ && typeof _ == "function") {
          var w = 0;
          C = /* @__PURE__ */ n(function(E, x, A) {
            if (E && E.code === "EAGAIN" && w < 10)
              return w++, h.call(e, d, f, m, v, y, C);
            _.apply(this, arguments);
          }, "callback");
        }
        return h.call(e, d, f, m, v, y, C);
      }
      return n(p, "read"), Object.setPrototypeOf && Object.setPrototypeOf(p, h), p;
    }(e.read), e.readSync = typeof e.readSync != "function" ? e.readSync : /* @__PURE__ */ function(h) {
      return function(p, d, f, m, v) {
        for (var y = 0; ; )
          try {
            return h.call(e, p, d, f, m, v);
          } catch (_) {
            if (_.code === "EAGAIN" && y < 10) {
              y++;
              continue;
            }
            throw _;
          }
      };
    }(e.readSync);
    function t(h) {
      h.lchmod = function(p, d, f) {
        h.open(
          p,
          $t.O_WRONLY | $t.O_SYMLINK,
          d,
          function(m, v) {
            if (m) {
              f && f(m);
              return;
            }
            h.fchmod(v, d, function(y) {
              h.close(v, function(_) {
                f && f(y || _);
              });
            });
          }
        );
      }, h.lchmodSync = function(p, d) {
        var f = h.openSync(p, $t.O_WRONLY | $t.O_SYMLINK, d), m = !0, v;
        try {
          v = h.fchmodSync(f, d), m = !1;
        } finally {
          if (m)
            try {
              h.closeSync(f);
            } catch {
            }
          else
            h.closeSync(f);
        }
        return v;
      };
    }
    n(t, "patchLchmod");
    function r(h) {
      $t.hasOwnProperty("O_SYMLINK") && h.futimes ? (h.lutimes = function(p, d, f, m) {
        h.open(p, $t.O_SYMLINK, function(v, y) {
          if (v) {
            m && m(v);
            return;
          }
          h.futimes(y, d, f, function(_) {
            h.close(y, function(C) {
              m && m(_ || C);
            });
          });
        });
      }, h.lutimesSync = function(p, d, f) {
        var m = h.openSync(p, $t.O_SYMLINK), v, y = !0;
        try {
          v = h.futimesSync(m, d, f), y = !1;
        } finally {
          if (y)
            try {
              h.closeSync(m);
            } catch {
            }
          else
            h.closeSync(m);
        }
        return v;
      }) : h.futimes && (h.lutimes = function(p, d, f, m) {
        m && process.nextTick(m);
      }, h.lutimesSync = function() {
      });
    }
    n(r, "patchLutimes");
    function i(h) {
      return h && function(p, d, f) {
        return h.call(e, p, d, function(m) {
          c(m) && (m = null), f && f.apply(this, arguments);
        });
      };
    }
    n(i, "chmodFix");
    function s(h) {
      return h && function(p, d) {
        try {
          return h.call(e, p, d);
        } catch (f) {
          if (!c(f)) throw f;
        }
      };
    }
    n(s, "chmodFixSync");
    function o(h) {
      return h && function(p, d, f, m) {
        return h.call(e, p, d, f, function(v) {
          c(v) && (v = null), m && m.apply(this, arguments);
        });
      };
    }
    n(o, "chownFix");
    function u(h) {
      return h && function(p, d, f) {
        try {
          return h.call(e, p, d, f);
        } catch (m) {
          if (!c(m)) throw m;
        }
      };
    }
    n(u, "chownFixSync");
    function a(h) {
      return h && function(p, d, f) {
        typeof d == "function" && (f = d, d = null);
        function m(v, y) {
          y && (y.uid < 0 && (y.uid += 4294967296), y.gid < 0 && (y.gid += 4294967296)), f && f.apply(this, arguments);
        }
        return n(m, "callback"), d ? h.call(e, p, d, m) : h.call(e, p, m);
      };
    }
    n(a, "statFix");
    function l(h) {
      return h && function(p, d) {
        var f = d ? h.call(e, p, d) : h.call(e, p);
        return f && (f.uid < 0 && (f.uid += 4294967296), f.gid < 0 && (f.gid += 4294967296)), f;
      };
    }
    n(l, "statFixSync");
    function c(h) {
      if (!h || h.code === "ENOSYS")
        return !0;
      var p = !process.getuid || process.getuid() !== 0;
      return !!(p && (h.code === "EINVAL" || h.code === "EPERM"));
    }
    n(c, "chownErOk");
  }
  n(Zx, "patch");
});

// ../node_modules/graceful-fs/legacy-streams.js
var xD = g((Tj, FD) => {
  var CD = require("stream").Stream;
  FD.exports = e2;
  function e2(e) {
    return {
      ReadStream: t,
      WriteStream: r
    };
    function t(i, s) {
      if (!(this instanceof t)) return new t(i, s);
      CD.call(this);
      var o = this;
      this.path = i, this.fd = null, this.readable = !0, this.paused = !1, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, s =
      s || {};
      for (var u = Object.keys(s), a = 0, l = u.length; a < l; a++) {
        var c = u[a];
        this[c] = s[c];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          o._read();
        });
        return;
      }
      e.open(this.path, this.flags, this.mode, function(h, p) {
        if (h) {
          o.emit("error", h), o.readable = !1;
          return;
        }
        o.fd = p, o.emit("open", p), o._read();
      });
    }
    function r(i, s) {
      if (!(this instanceof r)) return new r(i, s);
      CD.call(this), this.path = i, this.fd = null, this.writable = !0, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten =
      0, s = s || {};
      for (var o = Object.keys(s), u = 0, a = o.length; u < a; u++) {
        var l = o[u];
        this[l] = s[l];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = !1, this._queue = [], this.fd === null && (this._open = e.open, this._queue.push([this._open, this.path, this.flags, this.
      mode, void 0]), this.flush());
    }
  }
  n(e2, "legacy");
});

// ../node_modules/graceful-fs/clone.js
var AD = g((kj, SD) => {
  "use strict";
  SD.exports = r2;
  var t2 = Object.getPrototypeOf || function(e) {
    return e.__proto__;
  };
  function r2(e) {
    if (e === null || typeof e != "object")
      return e;
    if (e instanceof Object)
      var t = { __proto__: t2(e) };
    else
      var t = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(e).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(e, r));
    }), t;
  }
  n(r2, "clone");
});

// ../node_modules/graceful-fs/graceful-fs.js
var Mr = g((Oj, Fa) => {
  var pe = require("fs"), i2 = ED(), n2 = xD(), s2 = AD(), hs = require("util"), Ce, ps;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (Ce = Symbol.for("graceful-fs.queue"), ps = Symbol.for("graceful-fs.previ\
ous")) : (Ce = "___graceful-fs.queue", ps = "___graceful-fs.previous");
  function o2() {
  }
  n(o2, "noop");
  function kD(e, t) {
    Object.defineProperty(e, Ce, {
      get: /* @__PURE__ */ n(function() {
        return t;
      }, "get")
    });
  }
  n(kD, "publishQueue");
  var ur = o2;
  hs.debuglog ? ur = hs.debuglog("gfs4") : /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && (ur = /* @__PURE__ */ n(function() {
    var e = hs.format.apply(hs, arguments);
    e = "GFS4: " + e.split(/\n/).join(`
GFS4: `), console.error(e);
  }, "debug"));
  pe[Ce] || (TD = global[Ce] || [], kD(pe, TD), pe.close = function(e) {
    function t(r, i) {
      return e.call(pe, r, function(s) {
        s || RD(), typeof i == "function" && i.apply(this, arguments);
      });
    }
    return n(t, "close"), Object.defineProperty(t, ps, {
      value: e
    }), t;
  }(pe.close), pe.closeSync = function(e) {
    function t(r) {
      e.apply(pe, arguments), RD();
    }
    return n(t, "closeSync"), Object.defineProperty(t, ps, {
      value: e
    }), t;
  }(pe.closeSync), /\bgfs4\b/i.test(process.env.NODE_DEBUG || "") && process.on("exit", function() {
    ur(pe[Ce]), require("assert").equal(pe[Ce].length, 0);
  }));
  var TD;
  global[Ce] || kD(global, pe[Ce]);
  Fa.exports = Ea(s2(pe));
  process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !pe.__patched && (Fa.exports = Ea(pe), pe.__patched = !0);
  function Ea(e) {
    i2(e), e.gracefulify = Ea, e.createReadStream = x, e.createWriteStream = A;
    var t = e.readFile;
    e.readFile = r;
    function r(F, P, M) {
      return typeof P == "function" && (M = P, P = null), U(F, P, M);
      function U(B, T, q, L) {
        return t(B, T, function(I) {
          I && (I.code === "EMFILE" || I.code === "ENFILE") ? qr([U, [B, T, q], I, L || Date.now(), Date.now()]) : typeof q == "function" &&
          q.apply(this, arguments);
        });
      }
      n(U, "go$readFile");
    }
    n(r, "readFile");
    var i = e.writeFile;
    e.writeFile = s;
    function s(F, P, M, U) {
      return typeof M == "function" && (U = M, M = null), B(F, P, M, U);
      function B(T, q, L, I, R) {
        return i(T, q, L, function(N) {
          N && (N.code === "EMFILE" || N.code === "ENFILE") ? qr([B, [T, q, L, I], N, R || Date.now(), Date.now()]) : typeof I == "function" &&
          I.apply(this, arguments);
        });
      }
      n(B, "go$writeFile");
    }
    n(s, "writeFile");
    var o = e.appendFile;
    o && (e.appendFile = u);
    function u(F, P, M, U) {
      return typeof M == "function" && (U = M, M = null), B(F, P, M, U);
      function B(T, q, L, I, R) {
        return o(T, q, L, function(N) {
          N && (N.code === "EMFILE" || N.code === "ENFILE") ? qr([B, [T, q, L, I], N, R || Date.now(), Date.now()]) : typeof I == "function" &&
          I.apply(this, arguments);
        });
      }
      n(B, "go$appendFile");
    }
    n(u, "appendFile");
    var a = e.copyFile;
    a && (e.copyFile = l);
    function l(F, P, M, U) {
      return typeof M == "function" && (U = M, M = 0), B(F, P, M, U);
      function B(T, q, L, I, R) {
        return a(T, q, L, function(N) {
          N && (N.code === "EMFILE" || N.code === "ENFILE") ? qr([B, [T, q, L, I], N, R || Date.now(), Date.now()]) : typeof I == "function" &&
          I.apply(this, arguments);
        });
      }
      n(B, "go$copyFile");
    }
    n(l, "copyFile");
    var c = e.readdir;
    e.readdir = p;
    var h = /^v[0-5]\./;
    function p(F, P, M) {
      typeof P == "function" && (M = P, P = null);
      var U = h.test(process.version) ? /* @__PURE__ */ n(function(q, L, I, R) {
        return c(q, B(
          q,
          L,
          I,
          R
        ));
      }, "go$readdir") : /* @__PURE__ */ n(function(q, L, I, R) {
        return c(q, L, B(
          q,
          L,
          I,
          R
        ));
      }, "go$readdir");
      return U(F, P, M);
      function B(T, q, L, I) {
        return function(R, N) {
          R && (R.code === "EMFILE" || R.code === "ENFILE") ? qr([
            U,
            [T, q, L],
            R,
            I || Date.now(),
            Date.now()
          ]) : (N && N.sort && N.sort(), typeof L == "function" && L.call(this, R, N));
        };
      }
    }
    if (n(p, "readdir"), process.version.substr(0, 4) === "v0.8") {
      var d = n2(e);
      _ = d.ReadStream, w = d.WriteStream;
    }
    var f = e.ReadStream;
    f && (_.prototype = Object.create(f.prototype), _.prototype.open = C);
    var m = e.WriteStream;
    m && (w.prototype = Object.create(m.prototype), w.prototype.open = E), Object.defineProperty(e, "ReadStream", {
      get: /* @__PURE__ */ n(function() {
        return _;
      }, "get"),
      set: /* @__PURE__ */ n(function(F) {
        _ = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e, "WriteStream", {
      get: /* @__PURE__ */ n(function() {
        return w;
      }, "get"),
      set: /* @__PURE__ */ n(function(F) {
        w = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var v = _;
    Object.defineProperty(e, "FileReadStream", {
      get: /* @__PURE__ */ n(function() {
        return v;
      }, "get"),
      set: /* @__PURE__ */ n(function(F) {
        v = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    var y = w;
    Object.defineProperty(e, "FileWriteStream", {
      get: /* @__PURE__ */ n(function() {
        return y;
      }, "get"),
      set: /* @__PURE__ */ n(function(F) {
        y = F;
      }, "set"),
      enumerable: !0,
      configurable: !0
    });
    function _(F, P) {
      return this instanceof _ ? (f.apply(this, arguments), this) : _.apply(Object.create(_.prototype), arguments);
    }
    n(_, "ReadStream");
    function C() {
      var F = this;
      j(F.path, F.flags, F.mode, function(P, M) {
        P ? (F.autoClose && F.destroy(), F.emit("error", P)) : (F.fd = M, F.emit("open", M), F.read());
      });
    }
    n(C, "ReadStream$open");
    function w(F, P) {
      return this instanceof w ? (m.apply(this, arguments), this) : w.apply(Object.create(w.prototype), arguments);
    }
    n(w, "WriteStream");
    function E() {
      var F = this;
      j(F.path, F.flags, F.mode, function(P, M) {
        P ? (F.destroy(), F.emit("error", P)) : (F.fd = M, F.emit("open", M));
      });
    }
    n(E, "WriteStream$open");
    function x(F, P) {
      return new e.ReadStream(F, P);
    }
    n(x, "createReadStream");
    function A(F, P) {
      return new e.WriteStream(F, P);
    }
    n(A, "createWriteStream");
    var O = e.open;
    e.open = j;
    function j(F, P, M, U) {
      return typeof M == "function" && (U = M, M = null), B(F, P, M, U);
      function B(T, q, L, I, R) {
        return O(T, q, L, function(N, $) {
          N && (N.code === "EMFILE" || N.code === "ENFILE") ? qr([B, [T, q, L, I], N, R || Date.now(), Date.now()]) : typeof I == "function" &&
          I.apply(this, arguments);
        });
      }
      n(B, "go$open");
    }
    return n(j, "open"), e;
  }
  n(Ea, "patch");
  function qr(e) {
    ur("ENQUEUE", e[0].name, e[1]), pe[Ce].push(e), Ca();
  }
  n(qr, "enqueue");
  var ds;
  function RD() {
    for (var e = Date.now(), t = 0; t < pe[Ce].length; ++t)
      pe[Ce][t].length > 2 && (pe[Ce][t][3] = e, pe[Ce][t][4] = e);
    Ca();
  }
  n(RD, "resetQueue");
  function Ca() {
    if (clearTimeout(ds), ds = void 0, pe[Ce].length !== 0) {
      var e = pe[Ce].shift(), t = e[0], r = e[1], i = e[2], s = e[3], o = e[4];
      if (s === void 0)
        ur("RETRY", t.name, r), t.apply(null, r);
      else if (Date.now() - s >= 6e4) {
        ur("TIMEOUT", t.name, r);
        var u = r.pop();
        typeof u == "function" && u.call(null, i);
      } else {
        var a = Date.now() - o, l = Math.max(o - s, 1), c = Math.min(l * 1.2, 100);
        a >= c ? (ur("RETRY", t.name, r), t.apply(null, r.concat([s]))) : pe[Ce].push(e);
      }
      ds === void 0 && (ds = setTimeout(Ca, 0));
    }
  }
  n(Ca, "retry");
});

// ../node_modules/fs-extra/lib/fs/index.js
var Me = g((Et) => {
  "use strict";
  var BD = _e().fromCallback, qe = Mr(), u2 = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((e) => typeof qe[e] == "function");
  Object.assign(Et, qe);
  u2.forEach((e) => {
    Et[e] = BD(qe[e]);
  });
  Et.exists = function(e, t) {
    return typeof t == "function" ? qe.exists(e, t) : new Promise((r) => qe.exists(e, r));
  };
  Et.read = function(e, t, r, i, s, o) {
    return typeof o == "function" ? qe.read(e, t, r, i, s, o) : new Promise((u, a) => {
      qe.read(e, t, r, i, s, (l, c, h) => {
        if (l) return a(l);
        u({ bytesRead: c, buffer: h });
      });
    });
  };
  Et.write = function(e, t, ...r) {
    return typeof r[r.length - 1] == "function" ? qe.write(e, t, ...r) : new Promise((i, s) => {
      qe.write(e, t, ...r, (o, u, a) => {
        if (o) return s(o);
        i({ bytesWritten: u, buffer: a });
      });
    });
  };
  Et.readv = function(e, t, ...r) {
    return typeof r[r.length - 1] == "function" ? qe.readv(e, t, ...r) : new Promise((i, s) => {
      qe.readv(e, t, ...r, (o, u, a) => {
        if (o) return s(o);
        i({ bytesRead: u, buffers: a });
      });
    });
  };
  Et.writev = function(e, t, ...r) {
    return typeof r[r.length - 1] == "function" ? qe.writev(e, t, ...r) : new Promise((i, s) => {
      qe.writev(e, t, ...r, (o, u, a) => {
        if (o) return s(o);
        i({ bytesWritten: u, buffers: a });
      });
    });
  };
  typeof qe.realpath.native == "function" ? Et.realpath.native = BD(qe.realpath.native) : process.emitWarning(
    "fs.realpath.native is not a function. Is fs being monkey-patched?",
    "Warning",
    "fs-extra-WARN0003"
  );
});

// ../node_modules/fs-extra/lib/mkdirs/utils.js
var PD = g((Mj, OD) => {
  "use strict";
  var a2 = require("path");
  OD.exports.checkPath = /* @__PURE__ */ n(function(t) {
    if (process.platform === "win32" && /[<>:"|?*]/.test(t.replace(a2.parse(t).root, ""))) {
      let i = new Error(`Path contains invalid characters: ${t}`);
      throw i.code = "EINVAL", i;
    }
  }, "checkPath");
});

// ../node_modules/fs-extra/lib/mkdirs/make-dir.js
var ID = g((Ij, xa) => {
  "use strict";
  var qD = Me(), { checkPath: MD } = PD(), jD = /* @__PURE__ */ n((e) => {
    let t = { mode: 511 };
    return typeof e == "number" ? e : { ...t, ...e }.mode;
  }, "getMode");
  xa.exports.makeDir = async (e, t) => (MD(e), qD.mkdir(e, {
    mode: jD(t),
    recursive: !0
  }));
  xa.exports.makeDirSync = (e, t) => (MD(e), qD.mkdirSync(e, {
    mode: jD(t),
    recursive: !0
  }));
});

// ../node_modules/fs-extra/lib/mkdirs/index.js
var Xe = g((Nj, LD) => {
  "use strict";
  var l2 = _e().fromPromise, { makeDir: c2, makeDirSync: Sa } = ID(), Aa = l2(c2);
  LD.exports = {
    mkdirs: Aa,
    mkdirsSync: Sa,
    // alias
    mkdirp: Aa,
    mkdirpSync: Sa,
    ensureDir: Aa,
    ensureDirSync: Sa
  };
});

// ../node_modules/fs-extra/lib/path-exists/index.js
var Ht = g((Uj, UD) => {
  "use strict";
  var f2 = _e().fromPromise, ND = Me();
  function h2(e) {
    return ND.access(e).then(() => !0).catch(() => !1);
  }
  n(h2, "pathExists");
  UD.exports = {
    pathExists: f2(h2),
    pathExistsSync: ND.existsSync
  };
});

// ../node_modules/fs-extra/lib/util/utimes.js
var Ta = g(($j, WD) => {
  "use strict";
  var jr = Me(), d2 = _e().fromPromise;
  async function p2(e, t, r) {
    let i = await jr.open(e, "r+"), s = null;
    try {
      await jr.futimes(i, t, r);
    } finally {
      try {
        await jr.close(i);
      } catch (o) {
        s = o;
      }
    }
    if (s)
      throw s;
  }
  n(p2, "utimesMillis");
  function D2(e, t, r) {
    let i = jr.openSync(e, "r+");
    return jr.futimesSync(i, t, r), jr.closeSync(i);
  }
  n(D2, "utimesMillisSync");
  WD.exports = {
    utimesMillis: d2(p2),
    utimesMillisSync: D2
  };
});

// ../node_modules/fs-extra/lib/util/stat.js
var ar = g((zj, VD) => {
  "use strict";
  var Ir = Me(), Ee = require("path"), $D = _e().fromPromise;
  function m2(e, t, r) {
    let i = r.dereference ? (s) => Ir.stat(s, { bigint: !0 }) : (s) => Ir.lstat(s, { bigint: !0 });
    return Promise.all([
      i(e),
      i(t).catch((s) => {
        if (s.code === "ENOENT") return null;
        throw s;
      })
    ]).then(([s, o]) => ({ srcStat: s, destStat: o }));
  }
  n(m2, "getStats");
  function y2(e, t, r) {
    let i, s = r.dereference ? (u) => Ir.statSync(u, { bigint: !0 }) : (u) => Ir.lstatSync(u, { bigint: !0 }), o = s(e);
    try {
      i = s(t);
    } catch (u) {
      if (u.code === "ENOENT") return { srcStat: o, destStat: null };
      throw u;
    }
    return { srcStat: o, destStat: i };
  }
  n(y2, "getStatsSync");
  async function g2(e, t, r, i) {
    let { srcStat: s, destStat: o } = await m2(e, t, i);
    if (o) {
      if (Pi(s, o)) {
        let u = Ee.basename(e), a = Ee.basename(t);
        if (r === "move" && u !== a && u.toLowerCase() === a.toLowerCase())
          return { srcStat: s, destStat: o, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (s.isDirectory() && !o.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
      if (!s.isDirectory() && o.isDirectory())
        throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
    }
    if (s.isDirectory() && Ra(e, t))
      throw new Error(Ds(e, t, r));
    return { srcStat: s, destStat: o };
  }
  n(g2, "checkPaths");
  function b2(e, t, r, i) {
    let { srcStat: s, destStat: o } = y2(e, t, i);
    if (o) {
      if (Pi(s, o)) {
        let u = Ee.basename(e), a = Ee.basename(t);
        if (r === "move" && u !== a && u.toLowerCase() === a.toLowerCase())
          return { srcStat: s, destStat: o, isChangingCase: !0 };
        throw new Error("Source and destination must not be the same.");
      }
      if (s.isDirectory() && !o.isDirectory())
        throw new Error(`Cannot overwrite non-directory '${t}' with directory '${e}'.`);
      if (!s.isDirectory() && o.isDirectory())
        throw new Error(`Cannot overwrite directory '${t}' with non-directory '${e}'.`);
    }
    if (s.isDirectory() && Ra(e, t))
      throw new Error(Ds(e, t, r));
    return { srcStat: s, destStat: o };
  }
  n(b2, "checkPathsSync");
  async function HD(e, t, r, i) {
    let s = Ee.resolve(Ee.dirname(e)), o = Ee.resolve(Ee.dirname(r));
    if (o === s || o === Ee.parse(o).root) return;
    let u;
    try {
      u = await Ir.stat(o, { bigint: !0 });
    } catch (a) {
      if (a.code === "ENOENT") return;
      throw a;
    }
    if (Pi(t, u))
      throw new Error(Ds(e, r, i));
    return HD(e, t, o, i);
  }
  n(HD, "checkParentPaths");
  function zD(e, t, r, i) {
    let s = Ee.resolve(Ee.dirname(e)), o = Ee.resolve(Ee.dirname(r));
    if (o === s || o === Ee.parse(o).root) return;
    let u;
    try {
      u = Ir.statSync(o, { bigint: !0 });
    } catch (a) {
      if (a.code === "ENOENT") return;
      throw a;
    }
    if (Pi(t, u))
      throw new Error(Ds(e, r, i));
    return zD(e, t, o, i);
  }
  n(zD, "checkParentPathsSync");
  function Pi(e, t) {
    return t.ino && t.dev && t.ino === e.ino && t.dev === e.dev;
  }
  n(Pi, "areIdentical");
  function Ra(e, t) {
    let r = Ee.resolve(e).split(Ee.sep).filter((s) => s), i = Ee.resolve(t).split(Ee.sep).filter((s) => s);
    return r.every((s, o) => i[o] === s);
  }
  n(Ra, "isSrcSubdir");
  function Ds(e, t, r) {
    return `Cannot ${r} '${e}' to a subdirectory of itself, '${t}'.`;
  }
  n(Ds, "errMsg");
  VD.exports = {
    // checkPaths
    checkPaths: $D(g2),
    checkPathsSync: b2,
    // checkParent
    checkParentPaths: $D(HD),
    checkParentPathsSync: zD,
    // Misc
    isSrcSubdir: Ra,
    areIdentical: Pi
  };
});

// ../node_modules/fs-extra/lib/copy/copy.js
var QD = g((Gj, KD) => {
  "use strict";
  var Re = Me(), qi = require("path"), { mkdirs: w2 } = Xe(), { pathExists: v2 } = Ht(), { utimesMillis: _2 } = Ta(), Mi = ar();
  async function E2(e, t, r = {}) {
    typeof r == "function" && (r = { filter: r }), r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ? !!r.overwrite :
    r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0001"
    );
    let { srcStat: i, destStat: s } = await Mi.checkPaths(e, t, "copy", r);
    if (await Mi.checkParentPaths(e, i, t, "copy"), !await JD(e, t, r)) return;
    let u = qi.dirname(t);
    await v2(u) || await w2(u), await YD(s, e, t, r);
  }
  n(E2, "copy");
  async function JD(e, t, r) {
    return r.filter ? r.filter(e, t) : !0;
  }
  n(JD, "runFilter");
  async function YD(e, t, r, i) {
    let o = await (i.dereference ? Re.stat : Re.lstat)(t);
    if (o.isDirectory()) return S2(o, e, t, r, i);
    if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return C2(o, e, t, r, i);
    if (o.isSymbolicLink()) return A2(e, t, r, i);
    throw o.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : o.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(
    `Unknown file: ${t}`);
  }
  n(YD, "getStatsAndPerformCopy");
  async function C2(e, t, r, i, s) {
    if (!t) return GD(e, r, i, s);
    if (s.overwrite)
      return await Re.unlink(i), GD(e, r, i, s);
    if (s.errorOnExist)
      throw new Error(`'${i}' already exists`);
  }
  n(C2, "onFile");
  async function GD(e, t, r, i) {
    if (await Re.copyFile(t, r), i.preserveTimestamps) {
      F2(e.mode) && await x2(r, e.mode);
      let s = await Re.stat(t);
      await _2(r, s.atime, s.mtime);
    }
    return Re.chmod(r, e.mode);
  }
  n(GD, "copyFile");
  function F2(e) {
    return (e & 128) === 0;
  }
  n(F2, "fileIsNotWritable");
  function x2(e, t) {
    return Re.chmod(e, t | 128);
  }
  n(x2, "makeFileWritable");
  async function S2(e, t, r, i, s) {
    t || await Re.mkdir(i);
    let o = await Re.readdir(r);
    await Promise.all(o.map(async (u) => {
      let a = qi.join(r, u), l = qi.join(i, u);
      if (!await JD(a, l, s)) return;
      let { destStat: h } = await Mi.checkPaths(a, l, "copy", s);
      return YD(h, a, l, s);
    })), t || await Re.chmod(i, e.mode);
  }
  n(S2, "onDir");
  async function A2(e, t, r, i) {
    let s = await Re.readlink(t);
    if (i.dereference && (s = qi.resolve(process.cwd(), s)), !e)
      return Re.symlink(s, r);
    let o = null;
    try {
      o = await Re.readlink(r);
    } catch (u) {
      if (u.code === "EINVAL" || u.code === "UNKNOWN") return Re.symlink(s, r);
      throw u;
    }
    if (i.dereference && (o = qi.resolve(process.cwd(), o)), Mi.isSrcSubdir(s, o))
      throw new Error(`Cannot copy '${s}' to a subdirectory of itself, '${o}'.`);
    if (Mi.isSrcSubdir(o, s))
      throw new Error(`Cannot overwrite '${o}' with '${s}'.`);
    return await Re.unlink(r), Re.symlink(s, r);
  }
  n(A2, "onLink");
  KD.exports = E2;
});

// ../node_modules/fs-extra/lib/copy/copy-sync.js
var rm = g((Yj, tm) => {
  "use strict";
  var je = Mr(), ji = require("path"), T2 = Xe().mkdirsSync, R2 = Ta().utimesMillisSync, Ii = ar();
  function k2(e, t, r) {
    typeof r == "function" && (r = { filter: r }), r = r || {}, r.clobber = "clobber" in r ? !!r.clobber : !0, r.overwrite = "overwrite" in r ?
    !!r.overwrite : r.clobber, r.preserveTimestamps && process.arch === "ia32" && process.emitWarning(
      `Using the preserveTimestamps option in 32-bit node is not recommended;

	see https://github.com/jprichardson/node-fs-extra/issues/269`,
      "Warning",
      "fs-extra-WARN0002"
    );
    let { srcStat: i, destStat: s } = Ii.checkPathsSync(e, t, "copy", r);
    if (Ii.checkParentPathsSync(e, i, t, "copy"), r.filter && !r.filter(e, t)) return;
    let o = ji.dirname(t);
    return je.existsSync(o) || T2(o), XD(s, e, t, r);
  }
  n(k2, "copySync");
  function XD(e, t, r, i) {
    let o = (i.dereference ? je.statSync : je.lstatSync)(t);
    if (o.isDirectory()) return I2(o, e, t, r, i);
    if (o.isFile() || o.isCharacterDevice() || o.isBlockDevice()) return B2(o, e, t, r, i);
    if (o.isSymbolicLink()) return U2(e, t, r, i);
    throw o.isSocket() ? new Error(`Cannot copy a socket file: ${t}`) : o.isFIFO() ? new Error(`Cannot copy a FIFO pipe: ${t}`) : new Error(
    `Unknown file: ${t}`);
  }
  n(XD, "getStats");
  function B2(e, t, r, i, s) {
    return t ? O2(e, r, i, s) : ZD(e, r, i, s);
  }
  n(B2, "onFile");
  function O2(e, t, r, i) {
    if (i.overwrite)
      return je.unlinkSync(r), ZD(e, t, r, i);
    if (i.errorOnExist)
      throw new Error(`'${r}' already exists`);
  }
  n(O2, "mayCopyFile");
  function ZD(e, t, r, i) {
    return je.copyFileSync(t, r), i.preserveTimestamps && P2(e.mode, t, r), ka(r, e.mode);
  }
  n(ZD, "copyFile");
  function P2(e, t, r) {
    return q2(e) && M2(r, e), j2(t, r);
  }
  n(P2, "handleTimestamps");
  function q2(e) {
    return (e & 128) === 0;
  }
  n(q2, "fileIsNotWritable");
  function M2(e, t) {
    return ka(e, t | 128);
  }
  n(M2, "makeFileWritable");
  function ka(e, t) {
    return je.chmodSync(e, t);
  }
  n(ka, "setDestMode");
  function j2(e, t) {
    let r = je.statSync(e);
    return R2(t, r.atime, r.mtime);
  }
  n(j2, "setDestTimestamps");
  function I2(e, t, r, i, s) {
    return t ? em(r, i, s) : L2(e.mode, r, i, s);
  }
  n(I2, "onDir");
  function L2(e, t, r, i) {
    return je.mkdirSync(r), em(t, r, i), ka(r, e);
  }
  n(L2, "mkDirAndCopy");
  function em(e, t, r) {
    je.readdirSync(e).forEach((i) => N2(i, e, t, r));
  }
  n(em, "copyDir");
  function N2(e, t, r, i) {
    let s = ji.join(t, e), o = ji.join(r, e);
    if (i.filter && !i.filter(s, o)) return;
    let { destStat: u } = Ii.checkPathsSync(s, o, "copy", i);
    return XD(u, s, o, i);
  }
  n(N2, "copyDirItem");
  function U2(e, t, r, i) {
    let s = je.readlinkSync(t);
    if (i.dereference && (s = ji.resolve(process.cwd(), s)), e) {
      let o;
      try {
        o = je.readlinkSync(r);
      } catch (u) {
        if (u.code === "EINVAL" || u.code === "UNKNOWN") return je.symlinkSync(s, r);
        throw u;
      }
      if (i.dereference && (o = ji.resolve(process.cwd(), o)), Ii.isSrcSubdir(s, o))
        throw new Error(`Cannot copy '${s}' to a subdirectory of itself, '${o}'.`);
      if (Ii.isSrcSubdir(o, s))
        throw new Error(`Cannot overwrite '${o}' with '${s}'.`);
      return W2(s, r);
    } else
      return je.symlinkSync(s, r);
  }
  n(U2, "onLink");
  function W2(e, t) {
    return je.unlinkSync(t), je.symlinkSync(e, t);
  }
  n(W2, "copyLink");
  tm.exports = k2;
});

// ../node_modules/fs-extra/lib/copy/index.js
var ms = g((Qj, im) => {
  "use strict";
  var $2 = _e().fromPromise;
  im.exports = {
    copy: $2(QD()),
    copySync: rm()
  };
});

// ../node_modules/fs-extra/lib/remove/index.js
var Li = g((Xj, sm) => {
  "use strict";
  var nm = Mr(), H2 = _e().fromCallback;
  function z2(e, t) {
    nm.rm(e, { recursive: !0, force: !0 }, t);
  }
  n(z2, "remove");
  function V2(e) {
    nm.rmSync(e, { recursive: !0, force: !0 });
  }
  n(V2, "removeSync");
  sm.exports = {
    remove: H2(z2),
    removeSync: V2
  };
});

// ../node_modules/fs-extra/lib/empty/index.js
var dm = g((eI, hm) => {
  "use strict";
  var G2 = _e().fromPromise, am = Me(), lm = require("path"), cm = Xe(), fm = Li(), om = G2(/* @__PURE__ */ n(async function(t) {
    let r;
    try {
      r = await am.readdir(t);
    } catch {
      return cm.mkdirs(t);
    }
    return Promise.all(r.map((i) => fm.remove(lm.join(t, i))));
  }, "emptyDir"));
  function um(e) {
    let t;
    try {
      t = am.readdirSync(e);
    } catch {
      return cm.mkdirsSync(e);
    }
    t.forEach((r) => {
      r = lm.join(e, r), fm.removeSync(r);
    });
  }
  n(um, "emptyDirSync");
  hm.exports = {
    emptyDirSync: um,
    emptydirSync: um,
    emptyDir: om,
    emptydir: om
  };
});

// ../node_modules/fs-extra/lib/ensure/file.js
var ym = g((rI, mm) => {
  "use strict";
  var J2 = _e().fromPromise, pm = require("path"), Ct = Me(), Dm = Xe();
  async function Y2(e) {
    let t;
    try {
      t = await Ct.stat(e);
    } catch {
    }
    if (t && t.isFile()) return;
    let r = pm.dirname(e), i = null;
    try {
      i = await Ct.stat(r);
    } catch (s) {
      if (s.code === "ENOENT") {
        await Dm.mkdirs(r), await Ct.writeFile(e, "");
        return;
      } else
        throw s;
    }
    i.isDirectory() ? await Ct.writeFile(e, "") : await Ct.readdir(r);
  }
  n(Y2, "createFile");
  function K2(e) {
    let t;
    try {
      t = Ct.statSync(e);
    } catch {
    }
    if (t && t.isFile()) return;
    let r = pm.dirname(e);
    try {
      Ct.statSync(r).isDirectory() || Ct.readdirSync(r);
    } catch (i) {
      if (i && i.code === "ENOENT") Dm.mkdirsSync(r);
      else throw i;
    }
    Ct.writeFileSync(e, "");
  }
  n(K2, "createFileSync");
  mm.exports = {
    createFile: J2(Y2),
    createFileSync: K2
  };
});

// ../node_modules/fs-extra/lib/ensure/link.js
var _m = g((nI, vm) => {
  "use strict";
  var Q2 = _e().fromPromise, gm = require("path"), zt = Me(), bm = Xe(), { pathExists: X2 } = Ht(), { areIdentical: wm } = ar();
  async function Z2(e, t) {
    let r;
    try {
      r = await zt.lstat(t);
    } catch {
    }
    let i;
    try {
      i = await zt.lstat(e);
    } catch (u) {
      throw u.message = u.message.replace("lstat", "ensureLink"), u;
    }
    if (r && wm(i, r)) return;
    let s = gm.dirname(t);
    await X2(s) || await bm.mkdirs(s), await zt.link(e, t);
  }
  n(Z2, "createLink");
  function eS(e, t) {
    let r;
    try {
      r = zt.lstatSync(t);
    } catch {
    }
    try {
      let o = zt.lstatSync(e);
      if (r && wm(o, r)) return;
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureLink"), o;
    }
    let i = gm.dirname(t);
    return zt.existsSync(i) || bm.mkdirsSync(i), zt.linkSync(e, t);
  }
  n(eS, "createLinkSync");
  vm.exports = {
    createLink: Q2(Z2),
    createLinkSync: eS
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-paths.js
var Cm = g((oI, Em) => {
  "use strict";
  var Vt = require("path"), Ni = Me(), { pathExists: tS } = Ht(), rS = _e().fromPromise;
  async function iS(e, t) {
    if (Vt.isAbsolute(e)) {
      try {
        await Ni.lstat(e);
      } catch (o) {
        throw o.message = o.message.replace("lstat", "ensureSymlink"), o;
      }
      return {
        toCwd: e,
        toDst: e
      };
    }
    let r = Vt.dirname(t), i = Vt.join(r, e);
    if (await tS(i))
      return {
        toCwd: i,
        toDst: e
      };
    try {
      await Ni.lstat(e);
    } catch (o) {
      throw o.message = o.message.replace("lstat", "ensureSymlink"), o;
    }
    return {
      toCwd: e,
      toDst: Vt.relative(r, e)
    };
  }
  n(iS, "symlinkPaths");
  function nS(e, t) {
    if (Vt.isAbsolute(e)) {
      if (!Ni.existsSync(e)) throw new Error("absolute srcpath does not exist");
      return {
        toCwd: e,
        toDst: e
      };
    }
    let r = Vt.dirname(t), i = Vt.join(r, e);
    if (Ni.existsSync(i))
      return {
        toCwd: i,
        toDst: e
      };
    if (!Ni.existsSync(e)) throw new Error("relative srcpath does not exist");
    return {
      toCwd: e,
      toDst: Vt.relative(r, e)
    };
  }
  n(nS, "symlinkPathsSync");
  Em.exports = {
    symlinkPaths: rS(iS),
    symlinkPathsSync: nS
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink-type.js
var Sm = g((aI, xm) => {
  "use strict";
  var Fm = Me(), sS = _e().fromPromise;
  async function oS(e, t) {
    if (t) return t;
    let r;
    try {
      r = await Fm.lstat(e);
    } catch {
      return "file";
    }
    return r && r.isDirectory() ? "dir" : "file";
  }
  n(oS, "symlinkType");
  function uS(e, t) {
    if (t) return t;
    let r;
    try {
      r = Fm.lstatSync(e);
    } catch {
      return "file";
    }
    return r && r.isDirectory() ? "dir" : "file";
  }
  n(uS, "symlinkTypeSync");
  xm.exports = {
    symlinkType: sS(oS),
    symlinkTypeSync: uS
  };
});

// ../node_modules/fs-extra/lib/ensure/symlink.js
var km = g((cI, Rm) => {
  "use strict";
  var aS = _e().fromPromise, Am = require("path"), lt = Me(), { mkdirs: lS, mkdirsSync: cS } = Xe(), { symlinkPaths: fS, symlinkPathsSync: hS } = Cm(),
  { symlinkType: dS, symlinkTypeSync: pS } = Sm(), { pathExists: DS } = Ht(), { areIdentical: Tm } = ar();
  async function mS(e, t, r) {
    let i;
    try {
      i = await lt.lstat(t);
    } catch {
    }
    if (i && i.isSymbolicLink()) {
      let [a, l] = await Promise.all([
        lt.stat(e),
        lt.stat(t)
      ]);
      if (Tm(a, l)) return;
    }
    let s = await fS(e, t);
    e = s.toDst;
    let o = await dS(s.toCwd, r), u = Am.dirname(t);
    return await DS(u) || await lS(u), lt.symlink(e, t, o);
  }
  n(mS, "createSymlink");
  function yS(e, t, r) {
    let i;
    try {
      i = lt.lstatSync(t);
    } catch {
    }
    if (i && i.isSymbolicLink()) {
      let a = lt.statSync(e), l = lt.statSync(t);
      if (Tm(a, l)) return;
    }
    let s = hS(e, t);
    e = s.toDst, r = pS(s.toCwd, r);
    let o = Am.dirname(t);
    return lt.existsSync(o) || cS(o), lt.symlinkSync(e, t, r);
  }
  n(yS, "createSymlinkSync");
  Rm.exports = {
    createSymlink: aS(mS),
    createSymlinkSync: yS
  };
});

// ../node_modules/fs-extra/lib/ensure/index.js
var Lm = g((hI, Im) => {
  "use strict";
  var { createFile: Bm, createFileSync: Om } = ym(), { createLink: Pm, createLinkSync: qm } = _m(), { createSymlink: Mm, createSymlinkSync: jm } = km();
  Im.exports = {
    // file
    createFile: Bm,
    createFileSync: Om,
    ensureFile: Bm,
    ensureFileSync: Om,
    // link
    createLink: Pm,
    createLinkSync: qm,
    ensureLink: Pm,
    ensureLinkSync: qm,
    // symlink
    createSymlink: Mm,
    createSymlinkSync: jm,
    ensureSymlink: Mm,
    ensureSymlinkSync: jm
  };
});

// ../node_modules/jsonfile/utils.js
var ys = g((dI, Nm) => {
  function gS(e, { EOL: t = `
`, finalEOL: r = !0, replacer: i = null, spaces: s } = {}) {
    let o = r ? t : "";
    return JSON.stringify(e, i, s).replace(/\n/g, t) + o;
  }
  n(gS, "stringify");
  function bS(e) {
    return Buffer.isBuffer(e) && (e = e.toString("utf8")), e.replace(/^\uFEFF/, "");
  }
  n(bS, "stripBom");
  Nm.exports = { stringify: gS, stripBom: bS };
});

// ../node_modules/jsonfile/index.js
var Hm = g((DI, $m) => {
  var Lr;
  try {
    Lr = Mr();
  } catch {
    Lr = require("fs");
  }
  var gs = _e(), { stringify: Um, stripBom: Wm } = ys();
  async function wS(e, t = {}) {
    typeof t == "string" && (t = { encoding: t });
    let r = t.fs || Lr, i = "throws" in t ? t.throws : !0, s = await gs.fromCallback(r.readFile)(e, t);
    s = Wm(s);
    let o;
    try {
      o = JSON.parse(s, t ? t.reviver : null);
    } catch (u) {
      if (i)
        throw u.message = `${e}: ${u.message}`, u;
      return null;
    }
    return o;
  }
  n(wS, "_readFile");
  var vS = gs.fromPromise(wS);
  function _S(e, t = {}) {
    typeof t == "string" && (t = { encoding: t });
    let r = t.fs || Lr, i = "throws" in t ? t.throws : !0;
    try {
      let s = r.readFileSync(e, t);
      return s = Wm(s), JSON.parse(s, t.reviver);
    } catch (s) {
      if (i)
        throw s.message = `${e}: ${s.message}`, s;
      return null;
    }
  }
  n(_S, "readFileSync");
  async function ES(e, t, r = {}) {
    let i = r.fs || Lr, s = Um(t, r);
    await gs.fromCallback(i.writeFile)(e, s, r);
  }
  n(ES, "_writeFile");
  var CS = gs.fromPromise(ES);
  function FS(e, t, r = {}) {
    let i = r.fs || Lr, s = Um(t, r);
    return i.writeFileSync(e, s, r);
  }
  n(FS, "writeFileSync");
  var xS = {
    readFile: vS,
    readFileSync: _S,
    writeFile: CS,
    writeFileSync: FS
  };
  $m.exports = xS;
});

// ../node_modules/fs-extra/lib/json/jsonfile.js
var Vm = g((yI, zm) => {
  "use strict";
  var bs = Hm();
  zm.exports = {
    // jsonfile exports
    readJson: bs.readFile,
    readJsonSync: bs.readFileSync,
    writeJson: bs.writeFile,
    writeJsonSync: bs.writeFileSync
  };
});

// ../node_modules/fs-extra/lib/output-file/index.js
var ws = g((gI, Ym) => {
  "use strict";
  var SS = _e().fromPromise, Ba = Me(), Gm = require("path"), Jm = Xe(), AS = Ht().pathExists;
  async function TS(e, t, r = "utf-8") {
    let i = Gm.dirname(e);
    return await AS(i) || await Jm.mkdirs(i), Ba.writeFile(e, t, r);
  }
  n(TS, "outputFile");
  function RS(e, ...t) {
    let r = Gm.dirname(e);
    Ba.existsSync(r) || Jm.mkdirsSync(r), Ba.writeFileSync(e, ...t);
  }
  n(RS, "outputFileSync");
  Ym.exports = {
    outputFile: SS(TS),
    outputFileSync: RS
  };
});

// ../node_modules/fs-extra/lib/json/output-json.js
var Qm = g((wI, Km) => {
  "use strict";
  var { stringify: kS } = ys(), { outputFile: BS } = ws();
  async function OS(e, t, r = {}) {
    let i = kS(t, r);
    await BS(e, i, r);
  }
  n(OS, "outputJson");
  Km.exports = OS;
});

// ../node_modules/fs-extra/lib/json/output-json-sync.js
var Zm = g((_I, Xm) => {
  "use strict";
  var { stringify: PS } = ys(), { outputFileSync: qS } = ws();
  function MS(e, t, r) {
    let i = PS(t, r);
    qS(e, i, r);
  }
  n(MS, "outputJsonSync");
  Xm.exports = MS;
});

// ../node_modules/fs-extra/lib/json/index.js
var ty = g((CI, ey) => {
  "use strict";
  var jS = _e().fromPromise, Ie = Vm();
  Ie.outputJson = jS(Qm());
  Ie.outputJsonSync = Zm();
  Ie.outputJSON = Ie.outputJson;
  Ie.outputJSONSync = Ie.outputJsonSync;
  Ie.writeJSON = Ie.writeJson;
  Ie.writeJSONSync = Ie.writeJsonSync;
  Ie.readJSON = Ie.readJson;
  Ie.readJSONSync = Ie.readJsonSync;
  ey.exports = Ie;
});

// ../node_modules/fs-extra/lib/move/move.js
var oy = g((FI, sy) => {
  "use strict";
  var IS = Me(), ry = require("path"), { copy: LS } = ms(), { remove: ny } = Li(), { mkdirp: NS } = Xe(), { pathExists: US } = Ht(), iy = ar();
  async function WS(e, t, r = {}) {
    let i = r.overwrite || r.clobber || !1, { srcStat: s, isChangingCase: o = !1 } = await iy.checkPaths(e, t, "move", r);
    await iy.checkParentPaths(e, s, t, "move");
    let u = ry.dirname(t);
    return ry.parse(u).root !== u && await NS(u), $S(e, t, i, o);
  }
  n(WS, "move");
  async function $S(e, t, r, i) {
    if (!i) {
      if (r)
        await ny(t);
      else if (await US(t))
        throw new Error("dest already exists.");
    }
    try {
      await IS.rename(e, t);
    } catch (s) {
      if (s.code !== "EXDEV")
        throw s;
      await HS(e, t, r);
    }
  }
  n($S, "doRename");
  async function HS(e, t, r) {
    return await LS(e, t, {
      overwrite: r,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), ny(e);
  }
  n(HS, "moveAcrossDevice");
  sy.exports = WS;
});

// ../node_modules/fs-extra/lib/move/move-sync.js
var fy = g((SI, cy) => {
  "use strict";
  var ay = Mr(), Pa = require("path"), zS = ms().copySync, ly = Li().removeSync, VS = Xe().mkdirpSync, uy = ar();
  function GS(e, t, r) {
    r = r || {};
    let i = r.overwrite || r.clobber || !1, { srcStat: s, isChangingCase: o = !1 } = uy.checkPathsSync(e, t, "move", r);
    return uy.checkParentPathsSync(e, s, t, "move"), JS(t) || VS(Pa.dirname(t)), YS(e, t, i, o);
  }
  n(GS, "moveSync");
  function JS(e) {
    let t = Pa.dirname(e);
    return Pa.parse(t).root === t;
  }
  n(JS, "isParentRoot");
  function YS(e, t, r, i) {
    if (i) return Oa(e, t, r);
    if (r)
      return ly(t), Oa(e, t, r);
    if (ay.existsSync(t)) throw new Error("dest already exists.");
    return Oa(e, t, r);
  }
  n(YS, "doRename");
  function Oa(e, t, r) {
    try {
      ay.renameSync(e, t);
    } catch (i) {
      if (i.code !== "EXDEV") throw i;
      return KS(e, t, r);
    }
  }
  n(Oa, "rename");
  function KS(e, t, r) {
    return zS(e, t, {
      overwrite: r,
      errorOnExist: !0,
      preserveTimestamps: !0
    }), ly(e);
  }
  n(KS, "moveAcrossDevice");
  cy.exports = GS;
});

// ../node_modules/fs-extra/lib/move/index.js
var dy = g((TI, hy) => {
  "use strict";
  var QS = _e().fromPromise;
  hy.exports = {
    move: QS(oy()),
    moveSync: fy()
  };
});

// ../node_modules/fs-extra/lib/index.js
var qa = g((RI, py) => {
  "use strict";
  py.exports = {
    // Export promiseified graceful-fs:
    ...Me(),
    // Export extra methods:
    ...ms(),
    ...dm(),
    ...Lm(),
    ...ty(),
    ...Xe(),
    ...dy(),
    ...ws(),
    ...Ht(),
    ...Li()
  };
});

// ../node_modules/wrappy/wrappy.js
var gy = g((qI, yy) => {
  yy.exports = my;
  function my(e, t) {
    if (e && t) return my(e)(t);
    if (typeof e != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(e).forEach(function(i) {
      r[i] = e[i];
    }), r;
    function r() {
      for (var i = new Array(arguments.length), s = 0; s < i.length; s++)
        i[s] = arguments[s];
      var o = e.apply(this, i), u = i[i.length - 1];
      return typeof o == "function" && o !== u && Object.keys(u).forEach(function(a) {
        o[a] = u[a];
      }), o;
    }
    n(r, "wrapper");
  }
  n(my, "wrappy");
});

// ../node_modules/once/once.js
var _s = g((jI, La) => {
  var by = gy();
  La.exports = by(vs);
  La.exports.strict = by(wy);
  vs.proto = vs(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: /* @__PURE__ */ n(function() {
        return vs(this);
      }, "value"),
      configurable: !0
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: /* @__PURE__ */ n(function() {
        return wy(this);
      }, "value"),
      configurable: !0
    });
  });
  function vs(e) {
    var t = /* @__PURE__ */ n(function() {
      return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));
    }, "f");
    return t.called = !1, t;
  }
  n(vs, "once");
  function wy(e) {
    var t = /* @__PURE__ */ n(function() {
      if (t.called)
        throw new Error(t.onceError);
      return t.called = !0, t.value = e.apply(this, arguments);
    }, "f"), r = e.name || "Function wrapped with `once`";
    return t.onceError = r + " shouldn't be called more than once", t.called = !1, t;
  }
  n(wy, "onceStrict");
});

// ../node_modules/end-of-stream/index.js
var Nr = g((LI, _y) => {
  var r3 = _s(), i3 = /* @__PURE__ */ n(function() {
  }, "noop"), n3 = /* @__PURE__ */ n(function(e) {
    return e.setHeader && typeof e.abort == "function";
  }, "isRequest"), s3 = /* @__PURE__ */ n(function(e) {
    return e.stdio && Array.isArray(e.stdio) && e.stdio.length === 3;
  }, "isChildProcess"), vy = /* @__PURE__ */ n(function(e, t, r) {
    if (typeof t == "function") return vy(e, null, t);
    t || (t = {}), r = r3(r || i3);
    var i = e._writableState, s = e._readableState, o = t.readable || t.readable !== !1 && e.readable, u = t.writable || t.writable !== !1 &&
    e.writable, a = !1, l = /* @__PURE__ */ n(function() {
      e.writable || c();
    }, "onlegacyfinish"), c = /* @__PURE__ */ n(function() {
      u = !1, o || r.call(e);
    }, "onfinish"), h = /* @__PURE__ */ n(function() {
      o = !1, u || r.call(e);
    }, "onend"), p = /* @__PURE__ */ n(function(y) {
      r.call(e, y ? new Error("exited with error code: " + y) : null);
    }, "onexit"), d = /* @__PURE__ */ n(function(y) {
      r.call(e, y);
    }, "onerror"), f = /* @__PURE__ */ n(function() {
      process.nextTick(m);
    }, "onclose"), m = /* @__PURE__ */ n(function() {
      if (!a) {
        if (o && !(s && s.ended && !s.destroyed)) return r.call(e, new Error("premature close"));
        if (u && !(i && i.ended && !i.destroyed)) return r.call(e, new Error("premature close"));
      }
    }, "onclosenexttick"), v = /* @__PURE__ */ n(function() {
      e.req.on("finish", c);
    }, "onrequest");
    return n3(e) ? (e.on("complete", c), e.on("abort", f), e.req ? v() : e.on("request", v)) : u && !i && (e.on("end", l), e.on("close", l)),
    s3(e) && e.on("exit", p), e.on("end", h), e.on("finish", c), t.error !== !1 && e.on("error", d), e.on("close", f), function() {
      a = !0, e.removeListener("complete", c), e.removeListener("abort", f), e.removeListener("request", v), e.req && e.req.removeListener("\
finish", c), e.removeListener("end", l), e.removeListener("close", l), e.removeListener("finish", c), e.removeListener("exit", p), e.removeListener(
      "end", h), e.removeListener("error", d), e.removeListener("close", f);
    };
  }, "eos");
  _y.exports = vy;
});

// ../node_modules/pump/index.js
var Ua = g((UI, Cy) => {
  var o3 = _s(), u3 = Nr(), Na = require("fs"), Wi = /* @__PURE__ */ n(function() {
  }, "noop"), a3 = /^v?\.0/.test(process.version), Es = /* @__PURE__ */ n(function(e) {
    return typeof e == "function";
  }, "isFn"), l3 = /* @__PURE__ */ n(function(e) {
    return !a3 || !Na ? !1 : (e instanceof (Na.ReadStream || Wi) || e instanceof (Na.WriteStream || Wi)) && Es(e.close);
  }, "isFS"), c3 = /* @__PURE__ */ n(function(e) {
    return e.setHeader && Es(e.abort);
  }, "isRequest"), f3 = /* @__PURE__ */ n(function(e, t, r, i) {
    i = o3(i);
    var s = !1;
    e.on("close", function() {
      s = !0;
    }), u3(e, { readable: t, writable: r }, function(u) {
      if (u) return i(u);
      s = !0, i();
    });
    var o = !1;
    return function(u) {
      if (!s && !o) {
        if (o = !0, l3(e)) return e.close(Wi);
        if (c3(e)) return e.abort();
        if (Es(e.destroy)) return e.destroy();
        i(u || new Error("stream was destroyed"));
      }
    };
  }, "destroyer"), Ey = /* @__PURE__ */ n(function(e) {
    e();
  }, "call"), h3 = /* @__PURE__ */ n(function(e, t) {
    return e.pipe(t);
  }, "pipe"), d3 = /* @__PURE__ */ n(function() {
    var e = Array.prototype.slice.call(arguments), t = Es(e[e.length - 1] || Wi) && e.pop() || Wi;
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
    var r, i = e.map(function(s, o) {
      var u = o < e.length - 1, a = o > 0;
      return f3(s, u, a, function(l) {
        r || (r = l), l && i.forEach(Ey), !u && (i.forEach(Ey), t(r));
      });
    });
    return e.reduce(h3);
  }, "pump");
  Cy.exports = d3;
});

// ../node_modules/tar-fs/node_modules/chownr/chownr.js
var ky = g(($I, Ry) => {
  "use strict";
  var ze = require("fs"), lr = require("path"), p3 = ze.lchown ? "lchown" : "chown", D3 = ze.lchownSync ? "lchownSync" : "chownSync", xy = ze.
  lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/), Fy = /* @__PURE__ */ n((e, t, r) => {
    try {
      return ze[D3](e, t, r);
    } catch (i) {
      if (i.code !== "ENOENT")
        throw i;
    }
  }, "lchownSync"), m3 = /* @__PURE__ */ n((e, t, r) => {
    try {
      return ze.chownSync(e, t, r);
    } catch (i) {
      if (i.code !== "ENOENT")
        throw i;
    }
  }, "chownSync"), y3 = xy ? (e, t, r, i) => (s) => {
    !s || s.code !== "EISDIR" ? i(s) : ze.chown(e, t, r, i);
  } : (e, t, r, i) => i, Wa = xy ? (e, t, r) => {
    try {
      return Fy(e, t, r);
    } catch (i) {
      if (i.code !== "EISDIR")
        throw i;
      m3(e, t, r);
    }
  } : (e, t, r) => Fy(e, t, r), g3 = process.version, Sy = /* @__PURE__ */ n((e, t, r) => ze.readdir(e, t, r), "readdir"), b3 = /* @__PURE__ */ n(
  (e, t) => ze.readdirSync(e, t), "readdirSync");
  /^v4\./.test(g3) && (Sy = /* @__PURE__ */ n((e, t, r) => ze.readdir(e, r), "readdir"));
  var Cs = /* @__PURE__ */ n((e, t, r, i) => {
    ze[p3](e, t, r, y3(e, t, r, (s) => {
      i(s && s.code !== "ENOENT" ? s : null);
    }));
  }, "chown"), Ay = /* @__PURE__ */ n((e, t, r, i, s) => {
    if (typeof t == "string")
      return ze.lstat(lr.resolve(e, t), (o, u) => {
        if (o)
          return s(o.code !== "ENOENT" ? o : null);
        u.name = t, Ay(e, u, r, i, s);
      });
    if (t.isDirectory())
      $a(lr.resolve(e, t.name), r, i, (o) => {
        if (o)
          return s(o);
        let u = lr.resolve(e, t.name);
        Cs(u, r, i, s);
      });
    else {
      let o = lr.resolve(e, t.name);
      Cs(o, r, i, s);
    }
  }, "chownrKid"), $a = /* @__PURE__ */ n((e, t, r, i) => {
    Sy(e, { withFileTypes: !0 }, (s, o) => {
      if (s) {
        if (s.code === "ENOENT")
          return i();
        if (s.code !== "ENOTDIR" && s.code !== "ENOTSUP")
          return i(s);
      }
      if (s || !o.length)
        return Cs(e, t, r, i);
      let u = o.length, a = null, l = /* @__PURE__ */ n((c) => {
        if (!a) {
          if (c)
            return i(a = c);
          if (--u === 0)
            return Cs(e, t, r, i);
        }
      }, "then");
      o.forEach((c) => Ay(e, c, t, r, l));
    });
  }, "chownr"), w3 = /* @__PURE__ */ n((e, t, r, i) => {
    if (typeof t == "string")
      try {
        let s = ze.lstatSync(lr.resolve(e, t));
        s.name = t, t = s;
      } catch (s) {
        if (s.code === "ENOENT")
          return;
        throw s;
      }
    t.isDirectory() && Ty(lr.resolve(e, t.name), r, i), Wa(lr.resolve(e, t.name), r, i);
  }, "chownrKidSync"), Ty = /* @__PURE__ */ n((e, t, r) => {
    let i;
    try {
      i = b3(e, { withFileTypes: !0 });
    } catch (s) {
      if (s.code === "ENOENT")
        return;
      if (s.code === "ENOTDIR" || s.code === "ENOTSUP")
        return Wa(e, t, r);
      throw s;
    }
    return i && i.length && i.forEach((s) => w3(e, s, t, r)), Wa(e, t, r);
  }, "chownrSync");
  Ry.exports = $a;
  $a.sync = Ty;
});

// ../node_modules/readable-stream/lib/internal/streams/stream.js
var Ha = g((zI, By) => {
  By.exports = require("stream");
});

// ../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var Iy = g((VI, jy) => {
  "use strict";
  function Oy(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(s) {
        return Object.getOwnPropertyDescriptor(e, s).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  n(Oy, "ownKeys");
  function Py(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? Oy(Object(r), !0).forEach(function(i) {
        v3(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : Oy(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  n(Py, "_objectSpread");
  function v3(e, t, r) {
    return t = My(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(v3, "_defineProperty");
  function _3(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(_3, "_classCallCheck");
  function qy(e, t) {
    for (var r = 0; r < t.length; r++) {
      var i = t[r];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, My(i.key), i);
    }
  }
  n(qy, "_defineProperties");
  function E3(e, t, r) {
    return t && qy(e.prototype, t), r && qy(e, r), Object.defineProperty(e, "prototype", { writable: !1 }), e;
  }
  n(E3, "_createClass");
  function My(e) {
    var t = C3(e, "string");
    return typeof t == "symbol" ? t : String(t);
  }
  n(My, "_toPropertyKey");
  function C3(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(e, t || "default");
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  n(C3, "_toPrimitive");
  var F3 = require("buffer"), Fs = F3.Buffer, x3 = require("util"), za = x3.inspect, S3 = za && za.custom || "inspect";
  function A3(e, t, r) {
    Fs.prototype.copy.call(e, t, r);
  }
  n(A3, "copyBuffer");
  jy.exports = /* @__PURE__ */ function() {
    function e() {
      _3(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), E3(e, [{
      key: "push",
      value: /* @__PURE__ */ n(function(r) {
        var i = {
          data: r,
          next: null
        };
        this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
      }, "push")
    }, {
      key: "unshift",
      value: /* @__PURE__ */ n(function(r) {
        var i = {
          data: r,
          next: this.head
        };
        this.length === 0 && (this.tail = i), this.head = i, ++this.length;
      }, "unshift")
    }, {
      key: "shift",
      value: /* @__PURE__ */ n(function() {
        if (this.length !== 0) {
          var r = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
        }
      }, "shift")
    }, {
      key: "clear",
      value: /* @__PURE__ */ n(function() {
        this.head = this.tail = null, this.length = 0;
      }, "clear")
    }, {
      key: "join",
      value: /* @__PURE__ */ n(function(r) {
        if (this.length === 0) return "";
        for (var i = this.head, s = "" + i.data; i = i.next; ) s += r + i.data;
        return s;
      }, "join")
    }, {
      key: "concat",
      value: /* @__PURE__ */ n(function(r) {
        if (this.length === 0) return Fs.alloc(0);
        for (var i = Fs.allocUnsafe(r >>> 0), s = this.head, o = 0; s; )
          A3(s.data, i, o), o += s.data.length, s = s.next;
        return i;
      }, "concat")
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: /* @__PURE__ */ n(function(r, i) {
        var s;
        return r < this.head.data.length ? (s = this.head.data.slice(0, r), this.head.data = this.head.data.slice(r)) : r === this.head.data.
        length ? s = this.shift() : s = i ? this._getString(r) : this._getBuffer(r), s;
      }, "consume")
    }, {
      key: "first",
      value: /* @__PURE__ */ n(function() {
        return this.head.data;
      }, "first")
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: /* @__PURE__ */ n(function(r) {
        var i = this.head, s = 1, o = i.data;
        for (r -= o.length; i = i.next; ) {
          var u = i.data, a = r > u.length ? u.length : r;
          if (a === u.length ? o += u : o += u.slice(0, r), r -= a, r === 0) {
            a === u.length ? (++s, i.next ? this.head = i.next : this.head = this.tail = null) : (this.head = i, i.data = u.slice(a));
            break;
          }
          ++s;
        }
        return this.length -= s, o;
      }, "_getString")
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: /* @__PURE__ */ n(function(r) {
        var i = Fs.allocUnsafe(r), s = this.head, o = 1;
        for (s.data.copy(i), r -= s.data.length; s = s.next; ) {
          var u = s.data, a = r > u.length ? u.length : r;
          if (u.copy(i, i.length - r, 0, a), r -= a, r === 0) {
            a === u.length ? (++o, s.next ? this.head = s.next : this.head = this.tail = null) : (this.head = s, s.data = u.slice(a));
            break;
          }
          ++o;
        }
        return this.length -= o, i;
      }, "_getBuffer")
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: S3,
      value: /* @__PURE__ */ n(function(r, i) {
        return za(this, Py(Py({}, i), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }, "value")
    }]), e;
  }();
});

// ../node_modules/readable-stream/lib/internal/streams/destroy.js
var Ga = g((JI, Ny) => {
  "use strict";
  function T3(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.
    nextTick(Va, this, e)) : process.nextTick(Va, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState &&
    (this._writableState.destroyed = !0), this._destroy(e || null, function(o) {
      !t && o ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(xs, r) : (r._writableState.errorEmitted = !0, process.nextTick(
      Ly, r, o)) : process.nextTick(Ly, r, o) : t ? (process.nextTick(xs, r), t(o)) : process.nextTick(xs, r);
    }), this);
  }
  n(T3, "destroy");
  function Ly(e, t) {
    Va(e, t), xs(e);
  }
  n(Ly, "emitErrorAndCloseNT");
  function xs(e) {
    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
  }
  n(xs, "emitCloseNT");
  function R3() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(R3, "undestroy");
  function Va(e, t) {
    e.emit("error", t);
  }
  n(Va, "emitErrorNT");
  function k3(e, t) {
    var r = e._readableState, i = e._writableState;
    r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : e.emit("error", t);
  }
  n(k3, "errorOrDestroy");
  Ny.exports = {
    destroy: T3,
    undestroy: R3,
    errorOrDestroy: k3
  };
});

// ../node_modules/readable-stream/errors.js
var Gt = g((KI, $y) => {
  "use strict";
  var Wy = {};
  function Ve(e, t, r) {
    r || (r = Error);
    function i(o, u, a) {
      return typeof t == "string" ? t : t(o, u, a);
    }
    n(i, "getMessage");
    class s extends r {
      static {
        n(this, "NodeError");
      }
      constructor(u, a, l) {
        super(i(u, a, l));
      }
    }
    s.prototype.name = r.name, s.prototype.code = e, Wy[e] = s;
  }
  n(Ve, "createErrorType");
  function Uy(e, t) {
    if (Array.isArray(e)) {
      let r = e.length;
      return e = e.map((i) => String(i)), r > 2 ? `one of ${t} ${e.slice(0, r - 1).join(", ")}, or ` + e[r - 1] : r === 2 ? `one of ${t} ${e[0]}\
 or ${e[1]}` : `of ${t} ${e[0]}`;
    } else
      return `of ${t} ${String(e)}`;
  }
  n(Uy, "oneOf");
  function B3(e, t, r) {
    return e.substr(!r || r < 0 ? 0 : +r, t.length) === t;
  }
  n(B3, "startsWith");
  function O3(e, t, r) {
    return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
  }
  n(O3, "endsWith");
  function P3(e, t, r) {
    return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
  }
  n(P3, "includes");
  Ve("ERR_INVALID_OPT_VALUE", function(e, t) {
    return 'The value "' + t + '" is invalid for option "' + e + '"';
  }, TypeError);
  Ve("ERR_INVALID_ARG_TYPE", function(e, t, r) {
    let i;
    typeof t == "string" && B3(t, "not ") ? (i = "must not be", t = t.replace(/^not /, "")) : i = "must be";
    let s;
    if (O3(e, " argument"))
      s = `The ${e} ${i} ${Uy(t, "type")}`;
    else {
      let o = P3(e, ".") ? "property" : "argument";
      s = `The "${e}" ${o} ${i} ${Uy(t, "type")}`;
    }
    return s += `. Received type ${typeof r}`, s;
  }, TypeError);
  Ve("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  Ve("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
    return "The " + e + " method is not implemented";
  });
  Ve("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  Ve("ERR_STREAM_DESTROYED", function(e) {
    return "Cannot call " + e + " after a stream was destroyed";
  });
  Ve("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  Ve("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  Ve("ERR_STREAM_WRITE_AFTER_END", "write after end");
  Ve("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  Ve("ERR_UNKNOWN_ENCODING", function(e) {
    return "Unknown encoding: " + e;
  }, TypeError);
  Ve("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  $y.exports.codes = Wy;
});

// ../node_modules/readable-stream/lib/internal/streams/state.js
var Ja = g((XI, Hy) => {
  "use strict";
  var q3 = Gt().codes.ERR_INVALID_OPT_VALUE;
  function M3(e, t, r) {
    return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
  }
  n(M3, "highWaterMarkFrom");
  function j3(e, t, r, i) {
    var s = M3(t, i, r);
    if (s != null) {
      if (!(isFinite(s) && Math.floor(s) === s) || s < 0) {
        var o = i ? r : "highWaterMark";
        throw new q3(o, s);
      }
      return Math.floor(s);
    }
    return e.objectMode ? 16 : 16 * 1024;
  }
  n(j3, "getHighWaterMark");
  Hy.exports = {
    getHighWaterMark: j3
  };
});

// ../node_modules/inherits/inherits_browser.js
var zy = g((e4, Ya) => {
  typeof Object.create == "function" ? Ya.exports = /* @__PURE__ */ n(function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  }, "inherits") : Ya.exports = /* @__PURE__ */ n(function(t, r) {
    if (r) {
      t.super_ = r;
      var i = /* @__PURE__ */ n(function() {
      }, "TempCtor");
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  }, "inherits");
});

// ../node_modules/inherits/inherits.js
var ee = g((r4, Qa) => {
  try {
    if (Ka = require("util"), typeof Ka.inherits != "function") throw "";
    Qa.exports = Ka.inherits;
  } catch {
    Qa.exports = zy();
  }
  var Ka;
});

// ../node_modules/util-deprecate/node.js
var $i = g((i4, Vy) => {
  Vy.exports = require("util").deprecate;
});

// ../node_modules/readable-stream/lib/_stream_writable.js
var el = g((n4, Xy) => {
  "use strict";
  Xy.exports = me;
  function Jy(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      c1(t, e);
    };
  }
  n(Jy, "CorkedRequest");
  var Ur;
  me.WritableState = zi;
  var I3 = {
    deprecate: $i()
  }, Yy = Ha(), As = require("buffer").Buffer, L3 = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self :
  {}).Uint8Array || function() {
  };
  function N3(e) {
    return As.from(e);
  }
  n(N3, "_uint8ArrayToBuffer");
  function U3(e) {
    return As.isBuffer(e) || e instanceof L3;
  }
  n(U3, "_isUint8Array");
  var Za = Ga(), W3 = Ja(), $3 = W3.getHighWaterMark, Jt = Gt().codes, H3 = Jt.ERR_INVALID_ARG_TYPE, z3 = Jt.ERR_METHOD_NOT_IMPLEMENTED, V3 = Jt.
  ERR_MULTIPLE_CALLBACK, G3 = Jt.ERR_STREAM_CANNOT_PIPE, J3 = Jt.ERR_STREAM_DESTROYED, Y3 = Jt.ERR_STREAM_NULL_VALUES, K3 = Jt.ERR_STREAM_WRITE_AFTER_END,
  Q3 = Jt.ERR_UNKNOWN_ENCODING, Wr = Za.errorOrDestroy;
  ee()(me, Yy);
  function X3() {
  }
  n(X3, "nop");
  function zi(e, t, r) {
    Ur = Ur || cr(), e = e || {}, typeof r != "boolean" && (r = t instanceof Ur), this.objectMode = !!e.objectMode, r && (this.objectMode = this.
    objectMode || !!e.writableObjectMode), this.highWaterMark = $3(this, e, "writableHighWaterMark", r), this.finalCalled = !1, this.needDrain =
    !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var i = e.decodeStrings === !1;
    this.decodeStrings = !i, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(s) {
      s1(t, s);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.emitClose = e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.
    corkedRequestsFree = new Jy(this);
  }
  n(zi, "WritableState");
  zi.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(zi.prototype, "buffer", {
        get: I3.deprecate(/* @__PURE__ */ n(function() {
          return this.getBuffer();
        }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var Ss;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ss = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(me, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(t) {
      return Ss.call(this, t) ? !0 : this !== me ? !1 : t && t._writableState instanceof zi;
    }, "value")
  })) : Ss = /* @__PURE__ */ n(function(t) {
    return t instanceof this;
  }, "realHasInstance");
  function me(e) {
    Ur = Ur || cr();
    var t = this instanceof Ur;
    if (!t && !Ss.call(me, this)) return new me(e);
    this._writableState = new zi(e, this, t), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), Yy.call(this);
  }
  n(me, "Writable");
  me.prototype.pipe = function() {
    Wr(this, new G3());
  };
  function Z3(e, t) {
    var r = new K3();
    Wr(e, r), process.nextTick(t, r);
  }
  n(Z3, "writeAfterEnd");
  function e1(e, t, r, i) {
    var s;
    return r === null ? s = new Y3() : typeof r != "string" && !t.objectMode && (s = new H3("chunk", ["string", "Buffer"], r)), s ? (Wr(e, s),
    process.nextTick(i, s), !1) : !0;
  }
  n(e1, "validChunk");
  me.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, o = !i.objectMode && U3(e);
    return o && !As.isBuffer(e) && (e = N3(e)), typeof t == "function" && (r = t, t = null), o ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = X3), i.ending ? Z3(this, r) : (o || e1(this, i, e, r)) && (i.pendingcb++, s = r1(this, i, o, e, t, r)), s;
  };
  me.prototype.cork = function() {
    this._writableState.corked++;
  };
  me.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Ky(this, e));
  };
  me.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new Q3(t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  Object.defineProperty(me.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState && this._writableState.getBuffer();
    }, "get")
  });
  function t1(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = As.from(t, r)), t;
  }
  n(t1, "decodeChunk");
  Object.defineProperty(me.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function r1(e, t, r, i, s, o) {
    if (!r) {
      var u = t1(t, i, s);
      i !== u && (r = !0, s = "buffer", i = u);
    }
    var a = t.objectMode ? 1 : i.length;
    t.length += a;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: o,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      Xa(e, t, !1, a, i, s, o);
    return l;
  }
  n(r1, "writeOrBuffer");
  function Xa(e, t, r, i, s, o, u) {
    t.writelen = i, t.writecb = u, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new J3("write")) : r ? e._writev(s, t.onwrite) : e._write(
    s, o, t.onwrite), t.sync = !1;
  }
  n(Xa, "doWrite");
  function i1(e, t, r, i, s) {
    --t.pendingcb, r ? (process.nextTick(s, i), process.nextTick(Hi, e, t), e._writableState.errorEmitted = !0, Wr(e, i)) : (s(i), e._writableState.
    errorEmitted = !0, Wr(e, i), Hi(e, t));
  }
  n(i1, "onwriteError");
  function n1(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(n1, "onwriteStateUpdate");
  function s1(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (typeof s != "function") throw new V3();
    if (n1(r), t) i1(e, r, i, t, s);
    else {
      var o = Qy(r) || e.destroyed;
      !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && Ky(e, r), i ? process.nextTick(Gy, e, r, o, s) : Gy(e, r, o, s);
    }
  }
  n(s1, "onwrite");
  function Gy(e, t, r, i) {
    r || o1(e, t), t.pendingcb--, i(), Hi(e, t);
  }
  n(Gy, "afterWrite");
  function o1(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(o1, "onwriteDrain");
  function Ky(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), o = t.corkedRequestsFree;
      o.entry = r;
      for (var u = 0, a = !0; r; )
        s[u] = r, r.isBuf || (a = !1), r = r.next, u += 1;
      s.allBuffers = a, Xa(e, t, !0, t.length, s, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree =
      o.next, o.next = null) : t.corkedRequestsFree = new Jy(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, h = r.callback, p = t.objectMode ? 1 : l.length;
        if (Xa(e, t, !1, p, l, c, h), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(Ky, "clearBuffer");
  me.prototype._write = function(e, t, r) {
    r(new z3("_write()"));
  };
  me.prototype._writev = null;
  me.prototype.end = function(e, t, r) {
    var i = this._writableState;
    return typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t),
    i.corked && (i.corked = 1, this.uncork()), i.ending || l1(this, i, r), this;
  };
  Object.defineProperty(me.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.length;
    }, "get")
  });
  function Qy(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(Qy, "needFinish");
  function u1(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && Wr(e, r), t.prefinished = !0, e.emit("prefinish"), Hi(e, t);
    });
  }
  n(u1, "callFinal");
  function a1(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.pendingcb++, t.finalCalled = !0, process.nextTick(
    u1, e, t)) : (t.prefinished = !0, e.emit("prefinish")));
  }
  n(a1, "prefinish");
  function Hi(e, t) {
    var r = Qy(t);
    if (r && (a1(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
      var i = e._readableState;
      (!i || i.autoDestroy && i.endEmitted) && e.destroy();
    }
    return r;
  }
  n(Hi, "finishMaybe");
  function l1(e, t, r) {
    t.ending = !0, Hi(e, t), r && (t.finished ? process.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(l1, "endWritable");
  function c1(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(c1, "onCorkedFinish");
  Object.defineProperty(me.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._writableState && (this._writableState.destroyed = t);
    }, "set")
  });
  me.prototype.destroy = Za.destroy;
  me.prototype._undestroy = Za.undestroy;
  me.prototype._destroy = function(e, t) {
    t(e);
  };
});

// ../node_modules/readable-stream/lib/_stream_duplex.js
var cr = g((o4, eg) => {
  "use strict";
  var f1 = Object.keys || function(e) {
    var t = [];
    for (var r in e) t.push(r);
    return t;
  };
  eg.exports = ct;
  var Zy = il(), rl = el();
  ee()(ct, Zy);
  for (tl = f1(rl.prototype), Ts = 0; Ts < tl.length; Ts++)
    Rs = tl[Ts], ct.prototype[Rs] || (ct.prototype[Rs] = rl.prototype[Rs]);
  var tl, Rs, Ts;
  function ct(e) {
    if (!(this instanceof ct)) return new ct(e);
    Zy.call(this, e), rl.call(this, e), this.allowHalfOpen = !0, e && (e.readable === !1 && (this.readable = !1), e.writable === !1 && (this.
    writable = !1), e.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", h1)));
  }
  n(ct, "Duplex");
  Object.defineProperty(ct.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  Object.defineProperty(ct.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState && this._writableState.getBuffer();
    }, "get")
  });
  Object.defineProperty(ct.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.length;
    }, "get")
  });
  function h1() {
    this._writableState.ended || process.nextTick(d1, this);
  }
  n(h1, "onend");
  function d1(e) {
    e.end();
  }
  n(d1, "onEndNT");
  Object.defineProperty(ct.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = t, this._writableState.destroyed =
      t);
    }, "set")
  });
});

// ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var ks = g((a4, ig) => {
  "use strict";
  var tg = Gt().codes.ERR_STREAM_PREMATURE_CLOSE;
  function p1(e) {
    var t = !1;
    return function() {
      if (!t) {
        t = !0;
        for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)
          i[s] = arguments[s];
        e.apply(this, i);
      }
    };
  }
  n(p1, "once");
  function D1() {
  }
  n(D1, "noop");
  function m1(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  n(m1, "isRequest");
  function rg(e, t, r) {
    if (typeof t == "function") return rg(e, null, t);
    t || (t = {}), r = p1(r || D1);
    var i = t.readable || t.readable !== !1 && e.readable, s = t.writable || t.writable !== !1 && e.writable, o = /* @__PURE__ */ n(function() {
      e.writable || a();
    }, "onlegacyfinish"), u = e._writableState && e._writableState.finished, a = /* @__PURE__ */ n(function() {
      s = !1, u = !0, i || r.call(e);
    }, "onfinish"), l = e._readableState && e._readableState.endEmitted, c = /* @__PURE__ */ n(function() {
      i = !1, l = !0, s || r.call(e);
    }, "onend"), h = /* @__PURE__ */ n(function(m) {
      r.call(e, m);
    }, "onerror"), p = /* @__PURE__ */ n(function() {
      var m;
      if (i && !l)
        return (!e._readableState || !e._readableState.ended) && (m = new tg()), r.call(e, m);
      if (s && !u)
        return (!e._writableState || !e._writableState.ended) && (m = new tg()), r.call(e, m);
    }, "onclose"), d = /* @__PURE__ */ n(function() {
      e.req.on("finish", a);
    }, "onrequest");
    return m1(e) ? (e.on("complete", a), e.on("abort", p), e.req ? d() : e.on("request", d)) : s && !e._writableState && (e.on("end", o), e.
    on("close", o)), e.on("end", c), e.on("finish", a), t.error !== !1 && e.on("error", h), e.on("close", p), function() {
      e.removeListener("complete", a), e.removeListener("abort", p), e.removeListener("request", d), e.req && e.req.removeListener("finish",
      a), e.removeListener("end", o), e.removeListener("close", o), e.removeListener("finish", a), e.removeListener("end", c), e.removeListener(
      "error", h), e.removeListener("close", p);
    };
  }
  n(rg, "eos");
  ig.exports = rg;
});

// ../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var sg = g((c4, ng) => {
  "use strict";
  var Bs;
  function Yt(e, t, r) {
    return t = y1(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(Yt, "_defineProperty");
  function y1(e) {
    var t = g1(e, "string");
    return typeof t == "symbol" ? t : String(t);
  }
  n(y1, "_toPropertyKey");
  function g1(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(e, t || "default");
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  n(g1, "_toPrimitive");
  var b1 = ks(), Kt = Symbol("lastResolve"), fr = Symbol("lastReject"), Vi = Symbol("error"), Os = Symbol("ended"), hr = Symbol("lastPromise"),
  nl = Symbol("handlePromise"), dr = Symbol("stream");
  function Qt(e, t) {
    return {
      value: e,
      done: t
    };
  }
  n(Qt, "createIterResult");
  function w1(e) {
    var t = e[Kt];
    if (t !== null) {
      var r = e[dr].read();
      r !== null && (e[hr] = null, e[Kt] = null, e[fr] = null, t(Qt(r, !1)));
    }
  }
  n(w1, "readAndResolve");
  function v1(e) {
    process.nextTick(w1, e);
  }
  n(v1, "onReadable");
  function _1(e, t) {
    return function(r, i) {
      e.then(function() {
        if (t[Os]) {
          r(Qt(void 0, !0));
          return;
        }
        t[nl](r, i);
      }, i);
    };
  }
  n(_1, "wrapForNext");
  var E1 = Object.getPrototypeOf(function() {
  }), C1 = Object.setPrototypeOf((Bs = {
    get stream() {
      return this[dr];
    },
    next: /* @__PURE__ */ n(function() {
      var t = this, r = this[Vi];
      if (r !== null)
        return Promise.reject(r);
      if (this[Os])
        return Promise.resolve(Qt(void 0, !0));
      if (this[dr].destroyed)
        return new Promise(function(u, a) {
          process.nextTick(function() {
            t[Vi] ? a(t[Vi]) : u(Qt(void 0, !0));
          });
        });
      var i = this[hr], s;
      if (i)
        s = new Promise(_1(i, this));
      else {
        var o = this[dr].read();
        if (o !== null)
          return Promise.resolve(Qt(o, !1));
        s = new Promise(this[nl]);
      }
      return this[hr] = s, s;
    }, "next")
  }, Yt(Bs, Symbol.asyncIterator, function() {
    return this;
  }), Yt(Bs, "return", /* @__PURE__ */ n(function() {
    var t = this;
    return new Promise(function(r, i) {
      t[dr].destroy(null, function(s) {
        if (s) {
          i(s);
          return;
        }
        r(Qt(void 0, !0));
      });
    });
  }, "_return")), Bs), E1), F1 = /* @__PURE__ */ n(function(t) {
    var r, i = Object.create(C1, (r = {}, Yt(r, dr, {
      value: t,
      writable: !0
    }), Yt(r, Kt, {
      value: null,
      writable: !0
    }), Yt(r, fr, {
      value: null,
      writable: !0
    }), Yt(r, Vi, {
      value: null,
      writable: !0
    }), Yt(r, Os, {
      value: t._readableState.endEmitted,
      writable: !0
    }), Yt(r, nl, {
      value: /* @__PURE__ */ n(function(o, u) {
        var a = i[dr].read();
        a ? (i[hr] = null, i[Kt] = null, i[fr] = null, o(Qt(a, !1))) : (i[Kt] = o, i[fr] = u);
      }, "value"),
      writable: !0
    }), r));
    return i[hr] = null, b1(t, function(s) {
      if (s && s.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var o = i[fr];
        o !== null && (i[hr] = null, i[Kt] = null, i[fr] = null, o(s)), i[Vi] = s;
        return;
      }
      var u = i[Kt];
      u !== null && (i[hr] = null, i[Kt] = null, i[fr] = null, u(Qt(void 0, !0))), i[Os] = !0;
    }), t.on("readable", v1.bind(null, i)), i;
  }, "createReadableStreamAsyncIterator");
  ng.exports = F1;
});

// ../node_modules/readable-stream/lib/internal/streams/from.js
var lg = g((h4, ag) => {
  "use strict";
  function og(e, t, r, i, s, o, u) {
    try {
      var a = e[o](u), l = a.value;
    } catch (c) {
      r(c);
      return;
    }
    a.done ? t(l) : Promise.resolve(l).then(i, s);
  }
  n(og, "asyncGeneratorStep");
  function x1(e) {
    return function() {
      var t = this, r = arguments;
      return new Promise(function(i, s) {
        var o = e.apply(t, r);
        function u(l) {
          og(o, i, s, u, a, "next", l);
        }
        n(u, "_next");
        function a(l) {
          og(o, i, s, u, a, "throw", l);
        }
        n(a, "_throw"), u(void 0);
      });
    };
  }
  n(x1, "_asyncToGenerator");
  function ug(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(e);
      t && (i = i.filter(function(s) {
        return Object.getOwnPropertyDescriptor(e, s).enumerable;
      })), r.push.apply(r, i);
    }
    return r;
  }
  n(ug, "ownKeys");
  function S1(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t] != null ? arguments[t] : {};
      t % 2 ? ug(Object(r), !0).forEach(function(i) {
        A1(e, i, r[i]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : ug(Object(r)).forEach(function(i) {
        Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i));
      });
    }
    return e;
  }
  n(S1, "_objectSpread");
  function A1(e, t, r) {
    return t = T1(t), t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e;
  }
  n(A1, "_defineProperty");
  function T1(e) {
    var t = R1(e, "string");
    return typeof t == "symbol" ? t : String(t);
  }
  n(T1, "_toPropertyKey");
  function R1(e, t) {
    if (typeof e != "object" || e === null) return e;
    var r = e[Symbol.toPrimitive];
    if (r !== void 0) {
      var i = r.call(e, t || "default");
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (t === "string" ? String : Number)(e);
  }
  n(R1, "_toPrimitive");
  var k1 = Gt().codes.ERR_INVALID_ARG_TYPE;
  function B1(e, t, r) {
    var i;
    if (t && typeof t.next == "function")
      i = t;
    else if (t && t[Symbol.asyncIterator]) i = t[Symbol.asyncIterator]();
    else if (t && t[Symbol.iterator]) i = t[Symbol.iterator]();
    else throw new k1("iterable", ["Iterable"], t);
    var s = new e(S1({
      objectMode: !0
    }, r)), o = !1;
    s._read = function() {
      o || (o = !0, u());
    };
    function u() {
      return a.apply(this, arguments);
    }
    n(u, "next");
    function a() {
      return a = x1(function* () {
        try {
          var l = yield i.next(), c = l.value, h = l.done;
          h ? s.push(null) : s.push(yield c) ? u() : o = !1;
        } catch (p) {
          s.destroy(p);
        }
      }), a.apply(this, arguments);
    }
    return n(a, "_next2"), s;
  }
  n(B1, "from");
  ag.exports = B1;
});

// ../node_modules/readable-stream/lib/_stream_readable.js
var il = g((D4, bg) => {
  "use strict";
  bg.exports = z;
  var $r;
  z.ReadableState = dg;
  var p4 = require("events").EventEmitter, hg = /* @__PURE__ */ n(function(t, r) {
    return t.listeners(r).length;
  }, "EElistenerCount"), Ji = Ha(), Ps = require("buffer").Buffer, O1 = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self <
  "u" ? self : {}).Uint8Array || function() {
  };
  function P1(e) {
    return Ps.from(e);
  }
  n(P1, "_uint8ArrayToBuffer");
  function q1(e) {
    return Ps.isBuffer(e) || e instanceof O1;
  }
  n(q1, "_isUint8Array");
  var sl = require("util"), W;
  sl && sl.debuglog ? W = sl.debuglog("stream") : W = /* @__PURE__ */ n(function() {
  }, "debug");
  var M1 = Iy(), hl = Ga(), j1 = Ja(), I1 = j1.getHighWaterMark, qs = Gt().codes, L1 = qs.ERR_INVALID_ARG_TYPE, N1 = qs.ERR_STREAM_PUSH_AFTER_EOF,
  U1 = qs.ERR_METHOD_NOT_IMPLEMENTED, W1 = qs.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Hr, ol, ul;
  ee()(z, Ji);
  var Gi = hl.errorOrDestroy, al = ["error", "close", "destroy", "pause", "resume"];
  function $1(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n($1, "prependListener");
  function dg(e, t, r) {
    $r = $r || cr(), e = e || {}, typeof r != "boolean" && (r = t instanceof $r), this.objectMode = !!e.objectMode, r && (this.objectMode = this.
    objectMode || !!e.readableObjectMode), this.highWaterMark = I1(this, e, "readableHighWaterMark", r), this.buffer = new M1(), this.length =
    0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0,
    this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose =
    e.emitClose !== !1, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain =
    0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (Hr || (Hr = require("string_decoder/").StringDecoder),
    this.decoder = new Hr(e.encoding), this.encoding = e.encoding);
  }
  n(dg, "ReadableState");
  function z(e) {
    if ($r = $r || cr(), !(this instanceof z)) return new z(e);
    var t = this instanceof $r;
    this._readableState = new dg(e, this, t), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), Ji.call(this);
  }
  n(z, "Readable");
  Object.defineProperty(z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._readableState && (this._readableState.destroyed = t);
    }, "set")
  });
  z.prototype.destroy = hl.destroy;
  z.prototype._undestroy = hl.undestroy;
  z.prototype._destroy = function(e, t) {
    t(e);
  };
  z.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = Ps.from(e, t), t = ""), i =
    !0), pg(this, e, t, !1, i);
  };
  z.prototype.unshift = function(e) {
    return pg(this, e, null, !0, !1);
  };
  function pg(e, t, r, i, s) {
    W("readableAddChunk", t);
    var o = e._readableState;
    if (t === null)
      o.reading = !1, V1(e, o);
    else {
      var u;
      if (s || (u = H1(o, t)), u)
        Gi(e, u);
      else if (o.objectMode || t && t.length > 0)
        if (typeof t != "string" && !o.objectMode && Object.getPrototypeOf(t) !== Ps.prototype && (t = P1(t)), i)
          o.endEmitted ? Gi(e, new W1()) : ll(e, o, t, !0);
        else if (o.ended)
          Gi(e, new N1());
        else {
          if (o.destroyed)
            return !1;
          o.reading = !1, o.decoder && !r ? (t = o.decoder.write(t), o.objectMode || t.length !== 0 ? ll(e, o, t, !1) : fl(e, o)) : ll(e, o,
          t, !1);
        }
      else i || (o.reading = !1, fl(e, o));
    }
    return !o.ended && (o.length < o.highWaterMark || o.length === 0);
  }
  n(pg, "readableAddChunk");
  function ll(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.
    unshift(r) : t.buffer.push(r), t.needReadable && Ms(e)), fl(e, t);
  }
  n(ll, "addChunk");
  function H1(e, t) {
    var r;
    return !q1(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new L1("chunk", ["string", "Buffer", "Uint8Array"], t)), r;
  }
  n(H1, "chunkInvalid");
  z.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  z.prototype.setEncoding = function(e) {
    Hr || (Hr = require("string_decoder/").StringDecoder);
    var t = new Hr(e);
    this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var r = this._readableState.buffer.head, i = ""; r !== null; )
      i += t.write(r.data), r = r.next;
    return this._readableState.buffer.clear(), i !== "" && this._readableState.buffer.push(i), this._readableState.length = i.length, this;
  };
  var cg = 1073741824;
  function z1(e) {
    return e >= cg ? e = cg : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(z1, "computeNewHighWaterMark");
  function fg(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = z1(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(fg, "howMuchToRead");
  z.prototype.read = function(e) {
    W("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length >
    0) || t.ended))
      return W("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? cl(this) : Ms(this), null;
    if (e = fg(e, t), e === 0 && t.ended)
      return t.length === 0 && cl(this), null;
    var i = t.needReadable;
    W("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, W("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, W("reading or ended", i)) : i && (W("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = fg(r, t)));
    var s;
    return e > 0 ? s = yg(e, t) : s = null, s === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain =
    0), t.length === 0 && (t.ended || (t.needReadable = !0), r !== e && t.ended && cl(this)), s !== null && this.emit("data", s), s;
  };
  function V1(e, t) {
    if (W("onEofChunk"), !t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, t.sync ? Ms(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, Dg(e)));
    }
  }
  n(V1, "onEofChunk");
  function Ms(e) {
    var t = e._readableState;
    W("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (W("emitReadable", t.flowing), t.emittedReadable =
    !0, process.nextTick(Dg, e));
  }
  n(Ms, "emitReadable");
  function Dg(e) {
    var t = e._readableState;
    W("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1),
    t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, dl(e);
  }
  n(Dg, "emitReadable_");
  function fl(e, t) {
    t.readingMore || (t.readingMore = !0, process.nextTick(G1, e, t));
  }
  n(fl, "maybeReadMore");
  function G1(e, t) {
    for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0); ) {
      var r = t.length;
      if (W("maybeReadMore read 0"), e.read(0), r === t.length)
        break;
    }
    t.readingMore = !1;
  }
  n(G1, "maybeReadMore_");
  z.prototype._read = function(e) {
    Gi(this, new U1("_read()"));
  };
  z.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, W("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, o = s ? a : v;
    i.endEmitted ? process.nextTick(o) : r.once("end", o), e.on("unpipe", u);
    function u(y, _) {
      W("onunpipe"), y === r && _ && _.hasUnpiped === !1 && (_.hasUnpiped = !0, h());
    }
    n(u, "onunpipe");
    function a() {
      W("onend"), e.end();
    }
    n(a, "onend");
    var l = J1(r);
    e.on("drain", l);
    var c = !1;
    function h() {
      W("cleanup"), e.removeListener("close", f), e.removeListener("finish", m), e.removeListener("drain", l), e.removeListener("error", d),
      e.removeListener("unpipe", u), r.removeListener("end", a), r.removeListener("end", v), r.removeListener("data", p), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(h, "cleanup"), r.on("data", p);
    function p(y) {
      W("ondata");
      var _ = e.write(y);
      W("dest.write", _), _ === !1 && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && gg(i.pipes, e) !== -1) && !c && (W("false\
 write response, pause", i.awaitDrain), i.awaitDrain++), r.pause());
    }
    n(p, "ondata");
    function d(y) {
      W("onerror", y), v(), e.removeListener("error", d), hg(e, "error") === 0 && Gi(e, y);
    }
    n(d, "onerror"), $1(e, "error", d);
    function f() {
      e.removeListener("finish", m), v();
    }
    n(f, "onclose"), e.once("close", f);
    function m() {
      W("onfinish"), e.removeListener("close", f), v();
    }
    n(m, "onfinish"), e.once("finish", m);
    function v() {
      W("unpipe"), r.unpipe(e);
    }
    return n(v, "unpipe"), e.emit("pipe", r), i.flowing || (W("pipe resume"), r.resume()), e;
  };
  function J1(e) {
    return /* @__PURE__ */ n(function() {
      var r = e._readableState;
      W("pipeOnDrain", r.awaitDrain), r.awaitDrain && r.awaitDrain--, r.awaitDrain === 0 && hg(e, "data") && (r.flowing = !0, dl(e));
    }, "pipeOnDrainFunctionResult");
  }
  n(J1, "pipeOnDrain");
  z.prototype.unpipe = function(e) {
    var t = this._readableState, r = {
      hasUnpiped: !1
    };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var o = 0; o < s; o++) i[o].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var u = gg(t.pipes, e);
    return u === -1 ? this : (t.pipes.splice(u, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  z.prototype.on = function(e, t) {
    var r = Ji.prototype.on.call(this, e, t), i = this._readableState;
    return e === "data" ? (i.readableListening = this.listenerCount("readable") > 0, i.flowing !== !1 && this.resume()) : e === "readable" &&
    !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, W("on reada\
ble", i.length, i.reading), i.length ? Ms(this) : i.reading || process.nextTick(Y1, this)), r;
  };
  z.prototype.addListener = z.prototype.on;
  z.prototype.removeListener = function(e, t) {
    var r = Ji.prototype.removeListener.call(this, e, t);
    return e === "readable" && process.nextTick(mg, this), r;
  };
  z.prototype.removeAllListeners = function(e) {
    var t = Ji.prototype.removeAllListeners.apply(this, arguments);
    return (e === "readable" || e === void 0) && process.nextTick(mg, this), t;
  };
  function mg(e) {
    var t = e._readableState;
    t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.
    resume();
  }
  n(mg, "updateReadableListening");
  function Y1(e) {
    W("readable nexttick read 0"), e.read(0);
  }
  n(Y1, "nReadingNextTick");
  z.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (W("resume"), e.flowing = !e.readableListening, K1(this, e)), e.paused = !1, this;
  };
  function K1(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, process.nextTick(Q1, e, t));
  }
  n(K1, "resume");
  function Q1(e, t) {
    W("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), dl(e), t.flowing && !t.reading && e.read(0);
  }
  n(Q1, "resume_");
  z.prototype.pause = function() {
    return W("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (W("pause"), this._readableState.flowing =
    !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function dl(e) {
    var t = e._readableState;
    for (W("flow", t.flowing); t.flowing && e.read() !== null; ) ;
  }
  n(dl, "flow");
  z.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (W("wrapped end"), r.decoder && !r.ended) {
        var u = r.decoder.end();
        u && u.length && t.push(u);
      }
      t.push(null);
    }), e.on("data", function(u) {
      if (W("wrapped data"), r.decoder && (u = r.decoder.write(u)), !(r.objectMode && u == null) && !(!r.objectMode && (!u || !u.length))) {
        var a = t.push(u);
        a || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = (/* @__PURE__ */ n(function(a) {
        return /* @__PURE__ */ n(function() {
          return e[a].apply(e, arguments);
        }, "methodWrapReturnFunction");
      }, "methodWrap"))(s));
    for (var o = 0; o < al.length; o++)
      e.on(al[o], this.emit.bind(this, al[o]));
    return this._read = function(u) {
      W("wrapped _read", u), i && (i = !1, e.resume());
    }, this;
  };
  typeof Symbol == "function" && (z.prototype[Symbol.asyncIterator] = function() {
    return ol === void 0 && (ol = sg()), ol(this);
  });
  Object.defineProperty(z.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  Object.defineProperty(z.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState && this._readableState.buffer;
    }, "get")
  });
  Object.defineProperty(z.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.flowing;
    }, "get"),
    set: /* @__PURE__ */ n(function(t) {
      this._readableState && (this._readableState.flowing = t);
    }, "set")
  });
  z._fromList = yg;
  Object.defineProperty(z.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.length;
    }, "get")
  });
  function yg(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    first() : r = t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r;
  }
  n(yg, "fromList");
  function cl(e) {
    var t = e._readableState;
    W("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, process.nextTick(X1, t, e));
  }
  n(cl, "endReadable");
  function X1(e, t) {
    if (W("endReadableNT", e.endEmitted, e.length), !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.
    autoDestroy)) {
      var r = t._writableState;
      (!r || r.autoDestroy && r.finished) && t.destroy();
    }
  }
  n(X1, "endReadableNT");
  typeof Symbol == "function" && (z.from = function(e, t) {
    return ul === void 0 && (ul = lg()), ul(z, e, t);
  });
  function gg(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(gg, "indexOf");
});

// ../node_modules/readable-stream/lib/_stream_transform.js
var pl = g((y4, vg) => {
  "use strict";
  vg.exports = Ft;
  var js = Gt().codes, Z1 = js.ERR_METHOD_NOT_IMPLEMENTED, eA = js.ERR_MULTIPLE_CALLBACK, tA = js.ERR_TRANSFORM_ALREADY_TRANSFORMING, rA = js.
  ERR_TRANSFORM_WITH_LENGTH_0, Is = cr();
  ee()(Ft, Is);
  function iA(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (i === null)
      return this.emit("error", new eA());
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(iA, "afterTransform");
  function Ft(e) {
    if (!(this instanceof Ft)) return new Ft(e);
    Is.call(this, e), this._transformState = {
      afterTransform: iA.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", nA);
  }
  n(Ft, "Transform");
  function nA() {
    var e = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
      wg(e, t, r);
    }) : wg(this, null, null);
  }
  n(nA, "prefinish");
  Ft.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, Is.prototype.push.call(this, e, t);
  };
  Ft.prototype._transform = function(e, t, r) {
    r(new Z1("_transform()"));
  };
  Ft.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  Ft.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform =
    !0;
  };
  Ft.prototype._destroy = function(e, t) {
    Is.prototype._destroy.call(this, e, function(r) {
      t(r);
    });
  };
  function wg(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new rA();
    if (e._transformState.transforming) throw new tA();
    return e.push(null);
  }
  n(wg, "done");
});

// ../node_modules/readable-stream/lib/_stream_passthrough.js
var Cg = g((b4, Eg) => {
  "use strict";
  Eg.exports = Yi;
  var _g = pl();
  ee()(Yi, _g);
  function Yi(e) {
    if (!(this instanceof Yi)) return new Yi(e);
    _g.call(this, e);
  }
  n(Yi, "PassThrough");
  Yi.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/readable-stream/lib/internal/streams/pipeline.js
var Tg = g((v4, Ag) => {
  "use strict";
  var Dl;
  function sA(e) {
    var t = !1;
    return function() {
      t || (t = !0, e.apply(void 0, arguments));
    };
  }
  n(sA, "once");
  var Sg = Gt().codes, oA = Sg.ERR_MISSING_ARGS, uA = Sg.ERR_STREAM_DESTROYED;
  function Fg(e) {
    if (e) throw e;
  }
  n(Fg, "noop");
  function aA(e) {
    return e.setHeader && typeof e.abort == "function";
  }
  n(aA, "isRequest");
  function lA(e, t, r, i) {
    i = sA(i);
    var s = !1;
    e.on("close", function() {
      s = !0;
    }), Dl === void 0 && (Dl = ks()), Dl(e, {
      readable: t,
      writable: r
    }, function(u) {
      if (u) return i(u);
      s = !0, i();
    });
    var o = !1;
    return function(u) {
      if (!s && !o) {
        if (o = !0, aA(e)) return e.abort();
        if (typeof e.destroy == "function") return e.destroy();
        i(u || new uA("pipe"));
      }
    };
  }
  n(lA, "destroyer");
  function xg(e) {
    e();
  }
  n(xg, "call");
  function cA(e, t) {
    return e.pipe(t);
  }
  n(cA, "pipe");
  function fA(e) {
    return !e.length || typeof e[e.length - 1] != "function" ? Fg : e.pop();
  }
  n(fA, "popCallback");
  function hA() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    var i = fA(t);
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
      throw new oA("streams");
    var s, o = t.map(function(u, a) {
      var l = a < t.length - 1, c = a > 0;
      return lA(u, l, c, function(h) {
        s || (s = h), h && o.forEach(xg), !l && (o.forEach(xg), i(s));
      });
    });
    return t.reduce(cA);
  }
  n(hA, "pipeline");
  Ag.exports = hA;
});

// ../node_modules/readable-stream/readable.js
var zr = g((Ge, Qi) => {
  var Ki = require("stream");
  process.env.READABLE_STREAM === "disable" && Ki ? (Qi.exports = Ki.Readable, Object.assign(Qi.exports, Ki), Qi.exports.Stream = Ki) : (Ge =
  Qi.exports = il(), Ge.Stream = Ki || Ge, Ge.Readable = Ge, Ge.Writable = el(), Ge.Duplex = cr(), Ge.Transform = pl(), Ge.PassThrough = Cg(),
  Ge.finished = ks(), Ge.pipeline = Tg());
});

// ../node_modules/bl/BufferList.js
var Bg = g((E4, kg) => {
  "use strict";
  var { Buffer: Ze } = require("buffer"), Rg = Symbol.for("BufferList");
  function te(e) {
    if (!(this instanceof te))
      return new te(e);
    te._init.call(this, e);
  }
  n(te, "BufferList");
  te._init = /* @__PURE__ */ n(function(t) {
    Object.defineProperty(this, Rg, { value: !0 }), this._bufs = [], this.length = 0, t && this.append(t);
  }, "_init");
  te.prototype._new = /* @__PURE__ */ n(function(t) {
    return new te(t);
  }, "_new");
  te.prototype._offset = /* @__PURE__ */ n(function(t) {
    if (t === 0)
      return [0, 0];
    let r = 0;
    for (let i = 0; i < this._bufs.length; i++) {
      let s = r + this._bufs[i].length;
      if (t < s || i === this._bufs.length - 1)
        return [i, t - r];
      r = s;
    }
  }, "_offset");
  te.prototype._reverseOffset = function(e) {
    let t = e[0], r = e[1];
    for (let i = 0; i < t; i++)
      r += this._bufs[i].length;
    return r;
  };
  te.prototype.get = /* @__PURE__ */ n(function(t) {
    if (t > this.length || t < 0)
      return;
    let r = this._offset(t);
    return this._bufs[r[0]][r[1]];
  }, "get");
  te.prototype.slice = /* @__PURE__ */ n(function(t, r) {
    return typeof t == "number" && t < 0 && (t += this.length), typeof r == "number" && r < 0 && (r += this.length), this.copy(null, 0, t, r);
  }, "slice");
  te.prototype.copy = /* @__PURE__ */ n(function(t, r, i, s) {
    if ((typeof i != "number" || i < 0) && (i = 0), (typeof s != "number" || s > this.length) && (s = this.length), i >= this.length || s <=
    0)
      return t || Ze.alloc(0);
    let o = !!t, u = this._offset(i), a = s - i, l = a, c = o && r || 0, h = u[1];
    if (i === 0 && s === this.length) {
      if (!o)
        return this._bufs.length === 1 ? this._bufs[0] : Ze.concat(this._bufs, this.length);
      for (let p = 0; p < this._bufs.length; p++)
        this._bufs[p].copy(t, c), c += this._bufs[p].length;
      return t;
    }
    if (l <= this._bufs[u[0]].length - h)
      return o ? this._bufs[u[0]].copy(t, r, h, h + l) : this._bufs[u[0]].slice(h, h + l);
    o || (t = Ze.allocUnsafe(a));
    for (let p = u[0]; p < this._bufs.length; p++) {
      let d = this._bufs[p].length - h;
      if (l > d)
        this._bufs[p].copy(t, c, h), c += d;
      else {
        this._bufs[p].copy(t, c, h, h + l), c += d;
        break;
      }
      l -= d, h && (h = 0);
    }
    return t.length > c ? t.slice(0, c) : t;
  }, "copy");
  te.prototype.shallowSlice = /* @__PURE__ */ n(function(t, r) {
    if (t = t || 0, r = typeof r != "number" ? this.length : r, t < 0 && (t += this.length), r < 0 && (r += this.length), t === r)
      return this._new();
    let i = this._offset(t), s = this._offset(r), o = this._bufs.slice(i[0], s[0] + 1);
    return s[1] === 0 ? o.pop() : o[o.length - 1] = o[o.length - 1].slice(0, s[1]), i[1] !== 0 && (o[0] = o[0].slice(i[1])), this._new(o);
  }, "shallowSlice");
  te.prototype.toString = /* @__PURE__ */ n(function(t, r, i) {
    return this.slice(r, i).toString(t);
  }, "toString");
  te.prototype.consume = /* @__PURE__ */ n(function(t) {
    if (t = Math.trunc(t), Number.isNaN(t) || t <= 0) return this;
    for (; this._bufs.length; )
      if (t >= this._bufs[0].length)
        t -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
      else {
        this._bufs[0] = this._bufs[0].slice(t), this.length -= t;
        break;
      }
    return this;
  }, "consume");
  te.prototype.duplicate = /* @__PURE__ */ n(function() {
    let t = this._new();
    for (let r = 0; r < this._bufs.length; r++)
      t.append(this._bufs[r]);
    return t;
  }, "duplicate");
  te.prototype.append = /* @__PURE__ */ n(function(t) {
    if (t == null)
      return this;
    if (t.buffer)
      this._appendBuffer(Ze.from(t.buffer, t.byteOffset, t.byteLength));
    else if (Array.isArray(t))
      for (let r = 0; r < t.length; r++)
        this.append(t[r]);
    else if (this._isBufferList(t))
      for (let r = 0; r < t._bufs.length; r++)
        this.append(t._bufs[r]);
    else
      typeof t == "number" && (t = t.toString()), this._appendBuffer(Ze.from(t));
    return this;
  }, "append");
  te.prototype._appendBuffer = /* @__PURE__ */ n(function(t) {
    this._bufs.push(t), this.length += t.length;
  }, "appendBuffer");
  te.prototype.indexOf = function(e, t, r) {
    if (r === void 0 && typeof t == "string" && (r = t, t = void 0), typeof e == "function" || Array.isArray(e))
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    if (typeof e == "number" ? e = Ze.from([e]) : typeof e == "string" ? e = Ze.from(e, r) : this._isBufferList(e) ? e = e.slice() : Array.isArray(
    e.buffer) ? e = Ze.from(e.buffer, e.byteOffset, e.byteLength) : Ze.isBuffer(e) || (e = Ze.from(e)), t = Number(t || 0), isNaN(t) && (t =
    0), t < 0 && (t = this.length + t), t < 0 && (t = 0), e.length === 0)
      return t > this.length ? this.length : t;
    let i = this._offset(t), s = i[0], o = i[1];
    for (; s < this._bufs.length; s++) {
      let u = this._bufs[s];
      for (; o < u.length; )
        if (u.length - o >= e.length) {
          let l = u.indexOf(e, o);
          if (l !== -1)
            return this._reverseOffset([s, l]);
          o = u.length - e.length + 1;
        } else {
          let l = this._reverseOffset([s, o]);
          if (this._match(l, e))
            return l;
          o++;
        }
      o = 0;
    }
    return -1;
  };
  te.prototype._match = function(e, t) {
    if (this.length - e < t.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (this.get(e + r) !== t[r])
        return !1;
    return !0;
  };
  (function() {
    let e = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (let t in e)
      (function(r) {
        e[r] === null ? te.prototype[r] = function(i, s) {
          return this.slice(i, i + s)[r](0, s);
        } : te.prototype[r] = function(i = 0) {
          return this.slice(i, i + e[r])[r](0);
        };
      })(t);
  })();
  te.prototype._isBufferList = /* @__PURE__ */ n(function(t) {
    return t instanceof te || te.isBufferList(t);
  }, "_isBufferList");
  te.isBufferList = /* @__PURE__ */ n(function(t) {
    return t != null && t[Rg];
  }, "isBufferList");
  kg.exports = te;
});

// ../node_modules/bl/bl.js
var Og = g((F4, Ls) => {
  "use strict";
  var ml = zr().Duplex, dA = ee(), Xi = Bg();
  function ke(e) {
    if (!(this instanceof ke))
      return new ke(e);
    if (typeof e == "function") {
      this._callback = e;
      let t = (/* @__PURE__ */ n(function(i) {
        this._callback && (this._callback(i), this._callback = null);
      }, "piper")).bind(this);
      this.on("pipe", /* @__PURE__ */ n(function(i) {
        i.on("error", t);
      }, "onPipe")), this.on("unpipe", /* @__PURE__ */ n(function(i) {
        i.removeListener("error", t);
      }, "onUnpipe")), e = null;
    }
    Xi._init.call(this, e), ml.call(this);
  }
  n(ke, "BufferListStream");
  dA(ke, ml);
  Object.assign(ke.prototype, Xi.prototype);
  ke.prototype._new = /* @__PURE__ */ n(function(t) {
    return new ke(t);
  }, "_new");
  ke.prototype._write = /* @__PURE__ */ n(function(t, r, i) {
    this._appendBuffer(t), typeof i == "function" && i();
  }, "_write");
  ke.prototype._read = /* @__PURE__ */ n(function(t) {
    if (!this.length)
      return this.push(null);
    t = Math.min(t, this.length), this.push(this.slice(0, t)), this.consume(t);
  }, "_read");
  ke.prototype.end = /* @__PURE__ */ n(function(t) {
    ml.prototype.end.call(this, t), this._callback && (this._callback(null, this.slice()), this._callback = null);
  }, "end");
  ke.prototype._destroy = /* @__PURE__ */ n(function(t, r) {
    this._bufs.length = 0, this.length = 0, r(t);
  }, "_destroy");
  ke.prototype._isBufferList = /* @__PURE__ */ n(function(t) {
    return t instanceof ke || t instanceof Xi || ke.isBufferList(t);
  }, "_isBufferList");
  ke.isBufferList = Xi.isBufferList;
  Ls.exports = ke;
  Ls.exports.BufferListStream = ke;
  Ls.exports.BufferList = Xi;
});

// ../node_modules/tar-stream/headers.js
var bl = g((Gr) => {
  var pA = Buffer.alloc, DA = "0000000000000000000", mA = "7777777777777777777", Pg = 48, qg = Buffer.from("ustar\0", "binary"), yA = Buffer.
  from("00", "binary"), gA = Buffer.from("ustar ", "binary"), bA = Buffer.from(" \0", "binary"), wA = parseInt("7777", 8), Zi = 257, gl = 263,
  vA = /* @__PURE__ */ n(function(e, t, r) {
    return typeof e != "number" ? r : (e = ~~e, e >= t ? t : e >= 0 || (e += t, e >= 0) ? e : 0);
  }, "clamp"), _A = /* @__PURE__ */ n(function(e) {
    switch (e) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  }, "toType"), EA = /* @__PURE__ */ n(function(e) {
    switch (e) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  }, "toTypeflag"), Mg = /* @__PURE__ */ n(function(e, t, r, i) {
    for (; r < i; r++)
      if (e[r] === t) return r;
    return i;
  }, "indexOf"), jg = /* @__PURE__ */ n(function(e) {
    for (var t = 256, r = 0; r < 148; r++) t += e[r];
    for (var i = 156; i < 512; i++) t += e[i];
    return t;
  }, "cksum"), Xt = /* @__PURE__ */ n(function(e, t) {
    return e = e.toString(8), e.length > t ? mA.slice(0, t) + " " : DA.slice(0, t - e.length) + e + " ";
  }, "encodeOct");
  function CA(e) {
    var t;
    if (e[0] === 128) t = !0;
    else if (e[0] === 255) t = !1;
    else return null;
    for (var r = [], i = e.length - 1; i > 0; i--) {
      var s = e[i];
      t ? r.push(s) : r.push(255 - s);
    }
    var o = 0, u = r.length;
    for (i = 0; i < u; i++)
      o += r[i] * Math.pow(256, i);
    return t ? o : -1 * o;
  }
  n(CA, "parse256");
  var Zt = /* @__PURE__ */ n(function(e, t, r) {
    if (e = e.slice(t, t + r), t = 0, e[t] & 128)
      return CA(e);
    for (; t < e.length && e[t] === 32; ) t++;
    for (var i = vA(Mg(e, 32, t, e.length), e.length, e.length); t < i && e[t] === 0; ) t++;
    return i === t ? 0 : parseInt(e.slice(t, i).toString(), 8);
  }, "decodeOct"), Vr = /* @__PURE__ */ n(function(e, t, r, i) {
    return e.slice(t, Mg(e, 0, t, t + r)).toString(i);
  }, "decodeStr"), yl = /* @__PURE__ */ n(function(e) {
    var t = Buffer.byteLength(e), r = Math.floor(Math.log(t) / Math.log(10)) + 1;
    return t + r >= Math.pow(10, r) && r++, t + r + e;
  }, "addLength");
  Gr.decodeLongPath = function(e, t) {
    return Vr(e, 0, e.length, t);
  };
  Gr.encodePax = function(e) {
    var t = "";
    e.name && (t += yl(" path=" + e.name + `
`)), e.linkname && (t += yl(" linkpath=" + e.linkname + `
`));
    var r = e.pax;
    if (r)
      for (var i in r)
        t += yl(" " + i + "=" + r[i] + `
`);
    return Buffer.from(t);
  };
  Gr.decodePax = function(e) {
    for (var t = {}; e.length; ) {
      for (var r = 0; r < e.length && e[r] !== 32; ) r++;
      var i = parseInt(e.slice(0, r).toString(), 10);
      if (!i) return t;
      var s = e.slice(r + 1, i - 1).toString(), o = s.indexOf("=");
      if (o === -1) return t;
      t[s.slice(0, o)] = s.slice(o + 1), e = e.slice(i);
    }
    return t;
  };
  Gr.encode = function(e) {
    var t = pA(512), r = e.name, i = "";
    if (e.typeflag === 5 && r[r.length - 1] !== "/" && (r += "/"), Buffer.byteLength(r) !== r.length) return null;
    for (; Buffer.byteLength(r) > 100; ) {
      var s = r.indexOf("/");
      if (s === -1) return null;
      i += i ? "/" + r.slice(0, s) : r.slice(0, s), r = r.slice(s + 1);
    }
    return Buffer.byteLength(r) > 100 || Buffer.byteLength(i) > 155 || e.linkname && Buffer.byteLength(e.linkname) > 100 ? null : (t.write(r),
    t.write(Xt(e.mode & wA, 6), 100), t.write(Xt(e.uid, 6), 108), t.write(Xt(e.gid, 6), 116), t.write(Xt(e.size, 11), 124), t.write(Xt(e.mtime.
    getTime() / 1e3 | 0, 11), 136), t[156] = Pg + EA(e.type), e.linkname && t.write(e.linkname, 157), qg.copy(t, Zi), yA.copy(t, gl), e.uname &&
    t.write(e.uname, 265), e.gname && t.write(e.gname, 297), t.write(Xt(e.devmajor || 0, 6), 329), t.write(Xt(e.devminor || 0, 6), 337), i &&
    t.write(i, 345), t.write(Xt(jg(t), 6), 148), t);
  };
  Gr.decode = function(e, t, r) {
    var i = e[156] === 0 ? 0 : e[156] - Pg, s = Vr(e, 0, 100, t), o = Zt(e, 100, 8), u = Zt(e, 108, 8), a = Zt(e, 116, 8), l = Zt(e, 124, 12),
    c = Zt(e, 136, 12), h = _A(i), p = e[157] === 0 ? null : Vr(e, 157, 100, t), d = Vr(e, 265, 32), f = Vr(e, 297, 32), m = Zt(e, 329, 8), v = Zt(
    e, 337, 8), y = jg(e);
    if (y === 8 * 32) return null;
    if (y !== Zt(e, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (qg.compare(e, Zi, Zi + 6) === 0)
      e[345] && (s = Vr(e, 345, 155, t) + "/" + s);
    else if (!(gA.compare(e, Zi, Zi + 6) === 0 && bA.compare(e, gl, gl + 2) === 0)) {
      if (!r)
        throw new Error("Invalid tar header: unknown format.");
    }
    return i === 0 && s && s[s.length - 1] === "/" && (i = 5), {
      name: s,
      mode: o,
      uid: u,
      gid: a,
      size: l,
      mtime: new Date(1e3 * c),
      type: h,
      linkname: p,
      uname: d,
      gname: f,
      devmajor: m,
      devminor: v
    };
  };
});

// ../node_modules/tar-stream/extract.js
var Hg = g((T4, $g) => {
  var Lg = require("util"), FA = Og(), en = bl(), Ng = zr().Writable, Ug = zr().PassThrough, Wg = /* @__PURE__ */ n(function() {
  }, "noop"), Ig = /* @__PURE__ */ n(function(e) {
    return e &= 511, e && 512 - e;
  }, "overflow"), xA = /* @__PURE__ */ n(function(e, t) {
    var r = new Ns(e, t);
    return r.end(), r;
  }, "emptyStream"), SA = /* @__PURE__ */ n(function(e, t) {
    return t.path && (e.name = t.path), t.linkpath && (e.linkname = t.linkpath), t.size && (e.size = parseInt(t.size, 10)), e.pax = t, e;
  }, "mixinPax"), Ns = /* @__PURE__ */ n(function(e, t) {
    this._parent = e, this.offset = t, Ug.call(this, { autoDestroy: !1 });
  }, "Source");
  Lg.inherits(Ns, Ug);
  Ns.prototype.destroy = function(e) {
    this._parent.destroy(e);
  };
  var xt = /* @__PURE__ */ n(function(e) {
    if (!(this instanceof xt)) return new xt(e);
    Ng.call(this, e), e = e || {}, this._offset = 0, this._buffer = FA(), this._missing = 0, this._partial = !1, this._onparse = Wg, this._header =
    null, this._stream = null, this._overflow = null, this._cb = null, this._locked = !1, this._destroyed = !1, this._pax = null, this._paxGlobal =
    null, this._gnuLongPath = null, this._gnuLongLinkPath = null;
    var t = this, r = t._buffer, i = /* @__PURE__ */ n(function() {
      t._continue();
    }, "oncontinue"), s = /* @__PURE__ */ n(function(d) {
      if (t._locked = !1, d) return t.destroy(d);
      t._stream || i();
    }, "onunlock"), o = /* @__PURE__ */ n(function() {
      t._stream = null;
      var d = Ig(t._header.size);
      d ? t._parse(d, u) : t._parse(512, p), t._locked || i();
    }, "onstreamend"), u = /* @__PURE__ */ n(function() {
      t._buffer.consume(Ig(t._header.size)), t._parse(512, p), i();
    }, "ondrain"), a = /* @__PURE__ */ n(function() {
      var d = t._header.size;
      t._paxGlobal = en.decodePax(r.slice(0, d)), r.consume(d), o();
    }, "onpaxglobalheader"), l = /* @__PURE__ */ n(function() {
      var d = t._header.size;
      t._pax = en.decodePax(r.slice(0, d)), t._paxGlobal && (t._pax = Object.assign({}, t._paxGlobal, t._pax)), r.consume(d), o();
    }, "onpaxheader"), c = /* @__PURE__ */ n(function() {
      var d = t._header.size;
      this._gnuLongPath = en.decodeLongPath(r.slice(0, d), e.filenameEncoding), r.consume(d), o();
    }, "ongnulongpath"), h = /* @__PURE__ */ n(function() {
      var d = t._header.size;
      this._gnuLongLinkPath = en.decodeLongPath(r.slice(0, d), e.filenameEncoding), r.consume(d), o();
    }, "ongnulonglinkpath"), p = /* @__PURE__ */ n(function() {
      var d = t._offset, f;
      try {
        f = t._header = en.decode(r.slice(0, 512), e.filenameEncoding, e.allowUnknownFormat);
      } catch (m) {
        t.emit("error", m);
      }
      if (r.consume(512), !f) {
        t._parse(512, p), i();
        return;
      }
      if (f.type === "gnu-long-path") {
        t._parse(f.size, c), i();
        return;
      }
      if (f.type === "gnu-long-link-path") {
        t._parse(f.size, h), i();
        return;
      }
      if (f.type === "pax-global-header") {
        t._parse(f.size, a), i();
        return;
      }
      if (f.type === "pax-header") {
        t._parse(f.size, l), i();
        return;
      }
      if (t._gnuLongPath && (f.name = t._gnuLongPath, t._gnuLongPath = null), t._gnuLongLinkPath && (f.linkname = t._gnuLongLinkPath, t._gnuLongLinkPath =
      null), t._pax && (t._header = f = SA(f, t._pax), t._pax = null), t._locked = !0, !f.size || f.type === "directory") {
        t._parse(512, p), t.emit("entry", f, xA(t, d), s);
        return;
      }
      t._stream = new Ns(t, d), t.emit("entry", f, t._stream, s), t._parse(f.size, o), i();
    }, "onheader");
    this._onheader = p, this._parse(512, p);
  }, "Extract");
  Lg.inherits(xt, Ng);
  xt.prototype.destroy = function(e) {
    this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.emit("close"));
  };
  xt.prototype._parse = function(e, t) {
    this._destroyed || (this._offset += e, this._missing = e, t === this._onheader && (this._partial = !1), this._onparse = t);
  };
  xt.prototype._continue = function() {
    if (!this._destroyed) {
      var e = this._cb;
      this._cb = Wg, this._overflow ? this._write(this._overflow, void 0, e) : e();
    }
  };
  xt.prototype._write = function(e, t, r) {
    if (!this._destroyed) {
      var i = this._stream, s = this._buffer, o = this._missing;
      if (e.length && (this._partial = !0), e.length < o)
        return this._missing -= e.length, this._overflow = null, i ? i.write(e, r) : (s.append(e), r());
      this._cb = r, this._missing = 0;
      var u = null;
      e.length > o && (u = e.slice(o), e = e.slice(0, o)), i ? i.end(e) : s.append(e), this._overflow = u, this._onparse();
    }
  };
  xt.prototype._final = function(e) {
    if (this._partial) return this.destroy(new Error("Unexpected end of data"));
    e();
  };
  $g.exports = xt;
});

// ../node_modules/fs-constants/index.js
var Vg = g((k4, zg) => {
  zg.exports = require("fs").constants || require("constants");
});

// ../node_modules/tar-stream/pack.js
var Qg = g((B4, Kg) => {
  var Jr = Vg(), Gg = Nr(), Ws = ee(), AA = Buffer.alloc, Jg = zr().Readable, Yr = zr().Writable, TA = require("string_decoder").StringDecoder,
  Us = bl(), RA = parseInt("755", 8), kA = parseInt("644", 8), Yg = AA(1024), vl = /* @__PURE__ */ n(function() {
  }, "noop"), wl = /* @__PURE__ */ n(function(e, t) {
    t &= 511, t && e.push(Yg.slice(0, 512 - t));
  }, "overflow");
  function BA(e) {
    switch (e & Jr.S_IFMT) {
      case Jr.S_IFBLK:
        return "block-device";
      case Jr.S_IFCHR:
        return "character-device";
      case Jr.S_IFDIR:
        return "directory";
      case Jr.S_IFIFO:
        return "fifo";
      case Jr.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  n(BA, "modeToType");
  var $s = /* @__PURE__ */ n(function(e) {
    Yr.call(this), this.written = 0, this._to = e, this._destroyed = !1;
  }, "Sink");
  Ws($s, Yr);
  $s.prototype._write = function(e, t, r) {
    if (this.written += e.length, this._to.push(e)) return r();
    this._to._drain = r;
  };
  $s.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var Hs = /* @__PURE__ */ n(function() {
    Yr.call(this), this.linkname = "", this._decoder = new TA("utf-8"), this._destroyed = !1;
  }, "LinkSink");
  Ws(Hs, Yr);
  Hs.prototype._write = function(e, t, r) {
    this.linkname += this._decoder.write(e), r();
  };
  Hs.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var tn = /* @__PURE__ */ n(function() {
    Yr.call(this), this._destroyed = !1;
  }, "Void");
  Ws(tn, Yr);
  tn.prototype._write = function(e, t, r) {
    r(new Error("No body allowed for this entry"));
  };
  tn.prototype.destroy = function() {
    this._destroyed || (this._destroyed = !0, this.emit("close"));
  };
  var ft = /* @__PURE__ */ n(function(e) {
    if (!(this instanceof ft)) return new ft(e);
    Jg.call(this, e), this._drain = vl, this._finalized = !1, this._finalizing = !1, this._destroyed = !1, this._stream = null;
  }, "Pack");
  Ws(ft, Jg);
  ft.prototype.entry = function(e, t, r) {
    if (this._stream) throw new Error("already piping an entry");
    if (!(this._finalized || this._destroyed)) {
      typeof t == "function" && (r = t, t = null), r || (r = vl);
      var i = this;
      if ((!e.size || e.type === "symlink") && (e.size = 0), e.type || (e.type = BA(e.mode)), e.mode || (e.mode = e.type === "directory" ? RA :
      kA), e.uid || (e.uid = 0), e.gid || (e.gid = 0), e.mtime || (e.mtime = /* @__PURE__ */ new Date()), typeof t == "string" && (t = Buffer.
      from(t)), Buffer.isBuffer(t)) {
        e.size = t.length, this._encode(e);
        var s = this.push(t);
        return wl(i, e.size), s ? process.nextTick(r) : this._drain = r, new tn();
      }
      if (e.type === "symlink" && !e.linkname) {
        var o = new Hs();
        return Gg(o, function(a) {
          if (a)
            return i.destroy(), r(a);
          e.linkname = o.linkname, i._encode(e), r();
        }), o;
      }
      if (this._encode(e), e.type !== "file" && e.type !== "contiguous-file")
        return process.nextTick(r), new tn();
      var u = new $s(this);
      return this._stream = u, Gg(u, function(a) {
        if (i._stream = null, a)
          return i.destroy(), r(a);
        if (u.written !== e.size)
          return i.destroy(), r(new Error("size mismatch"));
        wl(i, e.size), i._finalizing && i.finalize(), r();
      }), u;
    }
  };
  ft.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = !0;
      return;
    }
    this._finalized || (this._finalized = !0, this.push(Yg), this.push(null));
  };
  ft.prototype.destroy = function(e) {
    this._destroyed || (this._destroyed = !0, e && this.emit("error", e), this.emit("close"), this._stream && this._stream.destroy && this._stream.
    destroy());
  };
  ft.prototype._encode = function(e) {
    if (!e.pax) {
      var t = Us.encode(e);
      if (t) {
        this.push(t);
        return;
      }
    }
    this._encodePax(e);
  };
  ft.prototype._encodePax = function(e) {
    var t = Us.encodePax({
      name: e.name,
      linkname: e.linkname,
      pax: e.pax
    }), r = {
      name: "PaxHeader",
      mode: e.mode,
      uid: e.uid,
      gid: e.gid,
      size: t.length,
      mtime: e.mtime,
      type: "pax-header",
      linkname: e.linkname && "PaxHeader",
      uname: e.uname,
      gname: e.gname,
      devmajor: e.devmajor,
      devminor: e.devminor
    };
    this.push(Us.encode(r)), this.push(t), wl(this, t.length), r.size = e.size, r.type = e.type, this.push(Us.encode(r));
  };
  ft.prototype._read = function(e) {
    var t = this._drain;
    this._drain = vl, t();
  };
  Kg.exports = ft;
});

// ../node_modules/tar-stream/index.js
var Xg = g((_l) => {
  _l.extract = Hg();
  _l.pack = Qg();
});

// ../node_modules/mkdirp-classic/index.js
var rb = g((q4, tb) => {
  var zs = require("path"), Zg = require("fs"), eb = parseInt("0777", 8);
  tb.exports = Kr.mkdirp = Kr.mkdirP = Kr;
  function Kr(e, t, r, i) {
    typeof t == "function" ? (r = t, t = {}) : (!t || typeof t != "object") && (t = { mode: t });
    var s = t.mode, o = t.fs || Zg;
    s === void 0 && (s = eb & ~process.umask()), i || (i = null);
    var u = r || function() {
    };
    e = zs.resolve(e), o.mkdir(e, s, function(a) {
      if (!a)
        return i = i || e, u(null, i);
      switch (a.code) {
        case "ENOENT":
          Kr(zs.dirname(e), t, function(l, c) {
            l ? u(l, c) : Kr(e, t, u, c);
          });
          break;
        default:
          o.stat(e, function(l, c) {
            l || !c.isDirectory() ? u(a, i) : u(null, i);
          });
          break;
      }
    });
  }
  n(Kr, "mkdirP");
  Kr.sync = /* @__PURE__ */ n(function e(t, r, i) {
    (!r || typeof r != "object") && (r = { mode: r });
    var s = r.mode, o = r.fs || Zg;
    s === void 0 && (s = eb & ~process.umask()), i || (i = null), t = zs.resolve(t);
    try {
      o.mkdirSync(t, s), i = i || t;
    } catch (a) {
      switch (a.code) {
        case "ENOENT":
          i = e(zs.dirname(t), r, i), e(t, r, i);
          break;
        default:
          var u;
          try {
            u = o.statSync(t);
          } catch {
            throw a;
          }
          if (!u.isDirectory()) throw a;
          break;
      }
    }
    return i;
  }, "sync");
});

// ../node_modules/tar-fs/index.js
var cb = g((Fl) => {
  var OA = ky(), nb = Xg(), sb = Ua(), PA = rb(), ob = require("fs"), We = require("path"), qA = require("os"), rn = qA.platform() === "win3\
2", nn = /* @__PURE__ */ n(function() {
  }, "noop"), Cl = /* @__PURE__ */ n(function(e) {
    return e;
  }, "echo"), El = rn ? function(e) {
    return e.replace(/\\/g, "/").replace(/[:?<>|]/g, "_");
  } : Cl, MA = /* @__PURE__ */ n(function(e, t, r, i, s, o) {
    var u = s || ["."];
    return /* @__PURE__ */ n(function(l) {
      if (!u.length) return l();
      var c = u.shift(), h = We.join(r, c);
      t.call(e, h, function(p, d) {
        if (p) return l(p);
        if (!d.isDirectory()) return l(null, c, d);
        e.readdir(h, function(f, m) {
          if (f) return l(f);
          o && m.sort();
          for (var v = 0; v < m.length; v++)
            i(We.join(r, c, m[v])) || u.push(We.join(c, m[v]));
          l(null, c, d);
        });
      });
    }, "loop");
  }, "statAll"), ub = /* @__PURE__ */ n(function(e, t) {
    return function(r) {
      r.name = r.name.split("/").slice(t).join("/");
      var i = r.linkname;
      return i && (r.type === "link" || We.isAbsolute(i)) && (r.linkname = i.split("/").slice(t).join("/")), e(r);
    };
  }, "strip");
  Fl.pack = function(e, t) {
    e || (e = "."), t || (t = {});
    var r = t.fs || ob, i = t.ignore || t.filter || nn, s = t.map || nn, o = t.mapStream || Cl, u = MA(r, t.dereference ? r.stat : r.lstat, e,
    i, t.entries, t.sort), a = t.strict !== !1, l = typeof t.umask == "number" ? ~t.umask : ~ab(), c = typeof t.dmode == "number" ? t.dmode :
    0, h = typeof t.fmode == "number" ? t.fmode : 0, p = t.pack || nb.pack(), d = t.finish || nn;
    t.strip && (s = ub(s, t.strip)), t.readable && (c |= parseInt(555, 8), h |= parseInt(444, 8)), t.writable && (c |= parseInt(333, 8), h |=
    parseInt(222, 8));
    var f = /* @__PURE__ */ n(function(y, _) {
      r.readlink(We.join(e, y), function(C, w) {
        if (C) return p.destroy(C);
        _.linkname = El(w), p.entry(_, v);
      });
    }, "onsymlink"), m = /* @__PURE__ */ n(function(y, _, C) {
      if (y) return p.destroy(y);
      if (!_)
        return t.finalize !== !1 && p.finalize(), d(p);
      if (C.isSocket()) return v();
      var w = {
        name: El(_),
        mode: (C.mode | (C.isDirectory() ? c : h)) & l,
        mtime: C.mtime,
        size: C.size,
        type: "file",
        uid: C.uid,
        gid: C.gid
      };
      if (C.isDirectory())
        return w.size = 0, w.type = "directory", w = s(w) || w, p.entry(w, v);
      if (C.isSymbolicLink())
        return w.size = 0, w.type = "symlink", w = s(w) || w, f(_, w);
      if (w = s(w) || w, !C.isFile())
        return a ? p.destroy(new Error("unsupported type for " + _)) : v();
      var E = p.entry(w, v);
      if (E) {
        var x = o(r.createReadStream(We.join(e, _), { start: 0, end: w.size > 0 ? w.size - 1 : w.size }), w);
        x.on("error", function(A) {
          E.destroy(A);
        }), sb(x, E);
      }
    }, "onstat"), v = /* @__PURE__ */ n(function(y) {
      if (y) return p.destroy(y);
      u(m);
    }, "onnextentry");
    return v(), p;
  };
  var jA = /* @__PURE__ */ n(function(e) {
    return e.length ? e[e.length - 1] : null;
  }, "head"), IA = /* @__PURE__ */ n(function() {
    return process.getuid ? process.getuid() : -1;
  }, "processGetuid"), ab = /* @__PURE__ */ n(function() {
    return process.umask ? process.umask() : 0;
  }, "processUmask");
  Fl.extract = function(e, t) {
    e || (e = "."), t || (t = {});
    var r = t.fs || ob, i = t.ignore || t.filter || nn, s = t.map || nn, o = t.mapStream || Cl, u = t.chown !== !1 && !rn && IA() === 0, a = t.
    extract || nb.extract(), l = [], c = /* @__PURE__ */ new Date(), h = typeof t.umask == "number" ? ~t.umask : ~ab(), p = typeof t.dmode ==
    "number" ? t.dmode : 0, d = typeof t.fmode == "number" ? t.fmode : 0, f = t.strict !== !1;
    t.strip && (s = ub(s, t.strip)), t.readable && (p |= parseInt(555, 8), d |= parseInt(444, 8)), t.writable && (p |= parseInt(333, 8), d |=
    parseInt(222, 8));
    var m = /* @__PURE__ */ n(function(_, C) {
      for (var w; (w = jA(l)) && _.slice(0, w[0].length) !== w[0]; ) l.pop();
      if (!w) return C();
      r.utimes(w[0], c, w[1], C);
    }, "utimesParent"), v = /* @__PURE__ */ n(function(_, C, w) {
      if (t.utimes === !1) return w();
      if (C.type === "directory") return r.utimes(_, c, C.mtime, w);
      if (C.type === "symlink") return m(_, w);
      r.utimes(_, c, C.mtime, function(E) {
        if (E) return w(E);
        m(_, w);
      });
    }, "utimes"), y = /* @__PURE__ */ n(function(_, C, w) {
      var E = C.type === "symlink", x = E ? r.lchmod : r.chmod, A = E ? r.lchown : r.chown;
      if (!x) return w();
      var O = (C.mode | (C.type === "directory" ? p : d)) & h;
      A && u ? A.call(r, _, C.uid, C.gid, j) : j(null);
      function j(F) {
        if (F) return w(F);
        if (!x) return w();
        x.call(r, _, O, w);
      }
      n(j, "onchown");
    }, "chperm");
    return a.on("entry", function(_, C, w) {
      _ = s(_) || _, _.name = El(_.name);
      var E = We.join(e, We.join("/", _.name));
      if (i(E, _))
        return C.resume(), w();
      var x = /* @__PURE__ */ n(function(P) {
        if (P) return w(P);
        v(E, _, function(M) {
          if (M) return w(M);
          if (rn) return w();
          y(E, _, w);
        });
      }, "stat"), A = /* @__PURE__ */ n(function() {
        if (rn) return w();
        r.unlink(E, function() {
          r.symlink(_.linkname, E, x);
        });
      }, "onsymlink"), O = /* @__PURE__ */ n(function() {
        if (rn) return w();
        r.unlink(E, function() {
          var P = We.join(e, We.join("/", _.linkname));
          r.link(P, E, function(M) {
            if (M && M.code === "EPERM" && t.hardlinkAsFilesFallback)
              return C = r.createReadStream(P), j();
            x(M);
          });
        });
      }, "onlink"), j = /* @__PURE__ */ n(function() {
        var P = r.createWriteStream(E), M = o(C, _);
        P.on("error", function(U) {
          M.destroy(U);
        }), sb(M, P, function(U) {
          if (U) return w(U);
          P.on("close", x);
        });
      }, "onfile");
      if (_.type === "directory")
        return l.push([E, _.mtime]), ib(E, {
          fs: r,
          own: u,
          uid: _.uid,
          gid: _.gid
        }, x);
      var F = We.dirname(E);
      lb(r, F, We.join(e, "."), function(P, M) {
        if (P) return w(P);
        if (!M) return w(new Error(F + " is not a valid path"));
        ib(F, {
          fs: r,
          own: u,
          uid: _.uid,
          gid: _.gid
        }, function(U) {
          if (U) return w(U);
          switch (_.type) {
            case "file":
              return j();
            case "link":
              return O();
            case "symlink":
              return A();
          }
          if (f) return w(new Error("unsupported type for " + E + " (" + _.type + ")"));
          C.resume(), w();
        });
      });
    }), t.finish && a.on("finish", t.finish), a;
  };
  function lb(e, t, r, i) {
    if (t === r) return i(null, !0);
    e.lstat(t, function(s, o) {
      if (s && s.code !== "ENOENT") return i(s);
      if (s || o.isDirectory()) return lb(e, We.join(t, ".."), r, i);
      i(null, !1);
    });
  }
  n(lb, "validate");
  function ib(e, t, r) {
    PA(e, { fs: t.fs }, function(i, s) {
      !i && s && t.own ? OA(s, t.uid, t.gid, r) : r(i);
    });
  }
  n(ib, "mkdirfix");
});

// ../node_modules/process-nextick-args/index.js
var $e = g((L4, xl) => {
  "use strict";
  typeof process > "u" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.
  indexOf("v1.8.") !== 0 ? xl.exports = { nextTick: LA } : xl.exports = process;
  function LA(e, t, r, i) {
    if (typeof e != "function")
      throw new TypeError('"callback" argument must be a function');
    var s = arguments.length, o, u;
    switch (s) {
      case 0:
      case 1:
        return process.nextTick(e);
      case 2:
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.call(null, t);
        }, "afterTickOne"));
      case 3:
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.call(null, t, r);
        }, "afterTickTwo"));
      case 4:
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.call(null, t, r, i);
        }, "afterTickThree"));
      default:
        for (o = new Array(s - 1), u = 0; u < o.length; )
          o[u++] = arguments[u];
        return process.nextTick(/* @__PURE__ */ n(function() {
          e.apply(null, o);
        }, "afterTick"));
    }
  }
  n(LA, "nextTick");
});

// ../node_modules/peek-stream/node_modules/isarray/index.js
var hb = g((U4, fb) => {
  var NA = {}.toString;
  fb.exports = Array.isArray || function(e) {
    return NA.call(e) == "[object Array]";
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/internal/streams/stream.js
var Sl = g((W4, db) => {
  db.exports = require("stream");
});

// ../node_modules/peek-stream/node_modules/safe-buffer/index.js
var Gs = g((Al, Db) => {
  var Vs = require("buffer"), St = Vs.Buffer;
  function pb(e, t) {
    for (var r in e)
      t[r] = e[r];
  }
  n(pb, "copyProps");
  St.from && St.alloc && St.allocUnsafe && St.allocUnsafeSlow ? Db.exports = Vs : (pb(Vs, Al), Al.Buffer = Qr);
  function Qr(e, t, r) {
    return St(e, t, r);
  }
  n(Qr, "SafeBuffer");
  pb(St, Qr);
  Qr.from = function(e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return St(e, t, r);
  };
  Qr.alloc = function(e, t, r) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var i = St(e);
    return t !== void 0 ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
  };
  Qr.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return St(e);
  };
  Qr.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return Vs.SlowBuffer(e);
  };
});

// ../node_modules/core-util-is/lib/util.js
var Oe = g((Be) => {
  function UA(e) {
    return Array.isArray ? Array.isArray(e) : Js(e) === "[object Array]";
  }
  n(UA, "isArray");
  Be.isArray = UA;
  function WA(e) {
    return typeof e == "boolean";
  }
  n(WA, "isBoolean");
  Be.isBoolean = WA;
  function $A(e) {
    return e === null;
  }
  n($A, "isNull");
  Be.isNull = $A;
  function HA(e) {
    return e == null;
  }
  n(HA, "isNullOrUndefined");
  Be.isNullOrUndefined = HA;
  function zA(e) {
    return typeof e == "number";
  }
  n(zA, "isNumber");
  Be.isNumber = zA;
  function VA(e) {
    return typeof e == "string";
  }
  n(VA, "isString");
  Be.isString = VA;
  function GA(e) {
    return typeof e == "symbol";
  }
  n(GA, "isSymbol");
  Be.isSymbol = GA;
  function JA(e) {
    return e === void 0;
  }
  n(JA, "isUndefined");
  Be.isUndefined = JA;
  function YA(e) {
    return Js(e) === "[object RegExp]";
  }
  n(YA, "isRegExp");
  Be.isRegExp = YA;
  function KA(e) {
    return typeof e == "object" && e !== null;
  }
  n(KA, "isObject");
  Be.isObject = KA;
  function QA(e) {
    return Js(e) === "[object Date]";
  }
  n(QA, "isDate");
  Be.isDate = QA;
  function XA(e) {
    return Js(e) === "[object Error]" || e instanceof Error;
  }
  n(XA, "isError");
  Be.isError = XA;
  function ZA(e) {
    return typeof e == "function";
  }
  n(ZA, "isFunction");
  Be.isFunction = ZA;
  function eT(e) {
    return e === null || typeof e == "boolean" || typeof e == "number" || typeof e == "string" || typeof e == "symbol" || // ES6 symbol
    typeof e > "u";
  }
  n(eT, "isPrimitive");
  Be.isPrimitive = eT;
  Be.isBuffer = require("buffer").Buffer.isBuffer;
  function Js(e) {
    return Object.prototype.toString.call(e);
  }
  n(Js, "objectToString");
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var yb = g((V4, Tl) => {
  "use strict";
  function tT(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(tT, "_classCallCheck");
  var mb = Gs().Buffer, sn = require("util");
  function rT(e, t, r) {
    e.copy(t, r);
  }
  n(rT, "copyBuffer");
  Tl.exports = function() {
    function e() {
      tT(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), e.prototype.push = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    }, "push"), e.prototype.unshift = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    }, "unshift"), e.prototype.shift = /* @__PURE__ */ n(function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    }, "shift"), e.prototype.clear = /* @__PURE__ */ n(function() {
      this.head = this.tail = null, this.length = 0;
    }, "clear"), e.prototype.join = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return "";
      for (var i = this.head, s = "" + i.data; i = i.next; )
        s += r + i.data;
      return s;
    }, "join"), e.prototype.concat = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return mb.alloc(0);
      for (var i = mb.allocUnsafe(r >>> 0), s = this.head, o = 0; s; )
        rT(s.data, i, o), o += s.data.length, s = s.next;
      return i;
    }, "concat"), e;
  }();
  sn && sn.inspect && sn.inspect.custom && (Tl.exports.prototype[sn.inspect.custom] = function() {
    var e = sn.inspect({ length: this.length });
    return this.constructor.name + " " + e;
  });
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/internal/streams/destroy.js
var Rl = g((J4, gb) => {
  "use strict";
  var Ys = $e();
  function iT(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ys.nextTick(
    Ks, this, e)) : Ys.nextTick(Ks, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this.
    _writableState.destroyed = !0), this._destroy(e || null, function(o) {
      !t && o ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, Ys.nextTick(Ks, r, o)) : Ys.nextTick(
      Ks, r, o) : t && t(o);
    }), this);
  }
  n(iT, "destroy");
  function nT() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(nT, "undestroy");
  function Ks(e, t) {
    e.emit("error", t);
  }
  n(Ks, "emitErrorNT");
  gb.exports = {
    destroy: iT,
    undestroy: nT
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_writable.js
var Bl = g((K4, xb) => {
  "use strict";
  var pr = $e();
  xb.exports = ye;
  function wb(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      _T(t, e);
    };
  }
  n(wb, "CorkedRequest");
  var sT = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pr.nextTick, Xr;
  ye.WritableState = un;
  var vb = Object.create(Oe());
  vb.inherits = ee();
  var oT = {
    deprecate: $i()
  }, _b = Sl(), Xs = Gs().Buffer, uT = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
  function() {
  };
  function aT(e) {
    return Xs.from(e);
  }
  n(aT, "_uint8ArrayToBuffer");
  function lT(e) {
    return Xs.isBuffer(e) || e instanceof uT;
  }
  n(lT, "_isUint8Array");
  var Eb = Rl();
  vb.inherits(ye, _b);
  function cT() {
  }
  n(cT, "nop");
  function un(e, t) {
    Xr = Xr || Dr(), e = e || {};
    var r = t instanceof Xr;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode);
    var i = e.highWaterMark, s = e.writableHighWaterMark, o = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = o, this.highWaterMark = Math.
    floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed =
    !1;
    var u = e.decodeStrings === !1;
    this.decodeStrings = !u, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(a) {
      yT(t, a);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new wb(this);
  }
  n(un, "WritableState");
  un.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(un.prototype, "buffer", {
        get: oT.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var Qs;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Qs = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(ye, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(e) {
      return Qs.call(this, e) ? !0 : this !== ye ? !1 : e && e._writableState instanceof un;
    }, "value")
  })) : Qs = /* @__PURE__ */ n(function(e) {
    return e instanceof this;
  }, "realHasInstance");
  function ye(e) {
    if (Xr = Xr || Dr(), !Qs.call(ye, this) && !(this instanceof Xr))
      return new ye(e);
    this._writableState = new un(e, this), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), _b.call(this);
  }
  n(ye, "Writable");
  ye.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function fT(e, t) {
    var r = new Error("write after end");
    e.emit("error", r), pr.nextTick(t, r);
  }
  n(fT, "writeAfterEnd");
  function hT(e, t, r, i) {
    var s = !0, o = !1;
    return r === null ? o = new TypeError("May not write null values to stream") : typeof r != "string" && r !== void 0 && !t.objectMode && (o =
    new TypeError("Invalid non-string/buffer chunk")), o && (e.emit("error", o), pr.nextTick(i, o), s = !1), s;
  }
  n(hT, "validChunk");
  ye.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, o = !i.objectMode && lT(e);
    return o && !Xs.isBuffer(e) && (e = aT(e)), typeof t == "function" && (r = t, t = null), o ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = cT), i.ended ? fT(this, r) : (o || hT(this, i, e, r)) && (i.pendingcb++, s = pT(this, i, o, e, t, r)), s;
  };
  ye.prototype.cork = function() {
    var e = this._writableState;
    e.corked++;
  };
  ye.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Cb(this, e));
  };
  ye.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  function dT(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = Xs.from(t, r)), t;
  }
  n(dT, "decodeChunk");
  Object.defineProperty(ye.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function pT(e, t, r, i, s, o) {
    if (!r) {
      var u = dT(t, i, s);
      i !== u && (r = !0, s = "buffer", i = u);
    }
    var a = t.objectMode ? 1 : i.length;
    t.length += a;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: o,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      kl(e, t, !1, a, i, s, o);
    return l;
  }
  n(pT, "writeOrBuffer");
  function kl(e, t, r, i, s, o, u) {
    t.writelen = i, t.writecb = u, t.writing = !0, t.sync = !0, r ? e._writev(s, t.onwrite) : e._write(s, o, t.onwrite), t.sync = !1;
  }
  n(kl, "doWrite");
  function DT(e, t, r, i, s) {
    --t.pendingcb, r ? (pr.nextTick(s, i), pr.nextTick(on, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (s(i), e._writableState.
    errorEmitted = !0, e.emit("error", i), on(e, t));
  }
  n(DT, "onwriteError");
  function mT(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(mT, "onwriteStateUpdate");
  function yT(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (mT(r), t) DT(e, r, i, t, s);
    else {
      var o = Fb(r);
      !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && Cb(e, r), i ? sT(bb, e, r, o, s) : bb(e, r, o, s);
    }
  }
  n(yT, "onwrite");
  function bb(e, t, r, i) {
    r || gT(e, t), t.pendingcb--, i(), on(e, t);
  }
  n(bb, "afterWrite");
  function gT(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(gT, "onwriteDrain");
  function Cb(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), o = t.corkedRequestsFree;
      o.entry = r;
      for (var u = 0, a = !0; r; )
        s[u] = r, r.isBuf || (a = !1), r = r.next, u += 1;
      s.allBuffers = a, kl(e, t, !0, t.length, s, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree =
      o.next, o.next = null) : t.corkedRequestsFree = new wb(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, h = r.callback, p = t.objectMode ? 1 : l.length;
        if (kl(e, t, !1, p, l, c, h), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(Cb, "clearBuffer");
  ye.prototype._write = function(e, t, r) {
    r(new Error("_write() is not implemented"));
  };
  ye.prototype._writev = null;
  ye.prototype.end = function(e, t, r) {
    var i = this._writableState;
    typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked &&
    (i.corked = 1, this.uncork()), i.ending || vT(this, i, r);
  };
  function Fb(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(Fb, "needFinish");
  function bT(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), on(e, t);
    });
  }
  n(bT, "callFinal");
  function wT(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" ? (t.pendingcb++, t.finalCalled = !0, pr.nextTick(bT, e, t)) : (t.prefinished =
    !0, e.emit("prefinish")));
  }
  n(wT, "prefinish");
  function on(e, t) {
    var r = Fb(t);
    return r && (wT(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"))), r;
  }
  n(on, "finishMaybe");
  function vT(e, t, r) {
    t.ending = !0, on(e, t), r && (t.finished ? pr.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(vT, "endWritable");
  function _T(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(_T, "onCorkedFinish");
  Object.defineProperty(ye.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._writableState && (this._writableState.destroyed = e);
    }, "set")
  });
  ye.prototype.destroy = Eb.destroy;
  ye.prototype._undestroy = Eb.undestroy;
  ye.prototype._destroy = function(e, t) {
    this.end(), t(e);
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_duplex.js
var Dr = g((X4, Rb) => {
  "use strict";
  var Sb = $e(), ET = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  Rb.exports = At;
  var Ab = Object.create(Oe());
  Ab.inherits = ee();
  var Tb = ql(), Pl = Bl();
  Ab.inherits(At, Tb);
  for (Ol = ET(Pl.prototype), Zs = 0; Zs < Ol.length; Zs++)
    eo = Ol[Zs], At.prototype[eo] || (At.prototype[eo] = Pl.prototype[eo]);
  var Ol, eo, Zs;
  function At(e) {
    if (!(this instanceof At)) return new At(e);
    Tb.call(this, e), Pl.call(this, e), e && e.readable === !1 && (this.readable = !1), e && e.writable === !1 && (this.writable = !1), this.
    allowHalfOpen = !0, e && e.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", CT);
  }
  n(At, "Duplex");
  Object.defineProperty(At.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function CT() {
    this.allowHalfOpen || this._writableState.ended || Sb.nextTick(FT, this);
  }
  n(CT, "onend");
  function FT(e) {
    e.end();
  }
  n(FT, "onEndNT");
  Object.defineProperty(At.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed =
      e);
    }, "set")
  });
  At.prototype._destroy = function(e, t) {
    this.push(null), this.end(), Sb.nextTick(t, e);
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_readable.js
var ql = g((tL, Wb) => {
  "use strict";
  var ei = $e();
  Wb.exports = ie;
  var xT = hb(), an;
  ie.ReadableState = jb;
  var eL = require("events").EventEmitter, Pb = /* @__PURE__ */ n(function(e, t) {
    return e.listeners(t).length;
  }, "EElistenerCount"), Nl = Sl(), ln = Gs().Buffer, ST = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ?
  self : {}).Uint8Array || function() {
  };
  function AT(e) {
    return ln.from(e);
  }
  n(AT, "_uint8ArrayToBuffer");
  function TT(e) {
    return ln.isBuffer(e) || e instanceof ST;
  }
  n(TT, "_isUint8Array");
  var qb = Object.create(Oe());
  qb.inherits = ee();
  var Ml = require("util"), J = void 0;
  Ml && Ml.debuglog ? J = Ml.debuglog("stream") : J = /* @__PURE__ */ n(function() {
  }, "debug");
  var RT = yb(), Mb = Rl(), Zr;
  qb.inherits(ie, Nl);
  var jl = ["error", "close", "destroy", "pause", "resume"];
  function kT(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : xT(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(kT, "prependListener");
  function jb(e, t) {
    an = an || Dr(), e = e || {};
    var r = t instanceof an;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode);
    var i = e.highWaterMark, s = e.readableHighWaterMark, o = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = o, this.highWaterMark = Math.
    floor(this.highWaterMark), this.buffer = new RT(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended =
    !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening =
    !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore =
    !1, this.decoder = null, this.encoding = null, e.encoding && (Zr || (Zr = require("string_decoder/").StringDecoder), this.decoder = new Zr(
    e.encoding), this.encoding = e.encoding);
  }
  n(jb, "ReadableState");
  function ie(e) {
    if (an = an || Dr(), !(this instanceof ie)) return new ie(e);
    this._readableState = new jb(e, this), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), Nl.call(this);
  }
  n(ie, "Readable");
  Object.defineProperty(ie.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState && (this._readableState.destroyed = e);
    }, "set")
  });
  ie.prototype.destroy = Mb.destroy;
  ie.prototype._undestroy = Mb.undestroy;
  ie.prototype._destroy = function(e, t) {
    this.push(null), t(e);
  };
  ie.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = ln.from(e, t), t = ""), i =
    !0), Ib(this, e, t, !1, i);
  };
  ie.prototype.unshift = function(e) {
    return Ib(this, e, null, !0, !1);
  };
  function Ib(e, t, r, i, s) {
    var o = e._readableState;
    if (t === null)
      o.reading = !1, qT(e, o);
    else {
      var u;
      s || (u = BT(o, t)), u ? e.emit("error", u) : o.objectMode || t && t.length > 0 ? (typeof t != "string" && !o.objectMode && Object.getPrototypeOf(
      t) !== ln.prototype && (t = AT(t)), i ? o.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : Il(e, o, t, !0) :
      o.ended ? e.emit("error", new Error("stream.push() after EOF")) : (o.reading = !1, o.decoder && !r ? (t = o.decoder.write(t), o.objectMode ||
      t.length !== 0 ? Il(e, o, t, !1) : Lb(e, o)) : Il(e, o, t, !1))) : i || (o.reading = !1);
    }
    return OT(o);
  }
  n(Ib, "readableAddChunk");
  function Il(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(
    r) : t.buffer.push(r), t.needReadable && to(e)), Lb(e, t);
  }
  n(Il, "addChunk");
  function BT(e, t) {
    var r;
    return !TT(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new TypeError("Invalid non-string/buffer chunk")), r;
  }
  n(BT, "chunkInvalid");
  function OT(e) {
    return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
  }
  n(OT, "needMoreData");
  ie.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  ie.prototype.setEncoding = function(e) {
    return Zr || (Zr = require("string_decoder/").StringDecoder), this._readableState.decoder = new Zr(e), this._readableState.encoding = e,
    this;
  };
  var kb = 8388608;
  function PT(e) {
    return e >= kb ? e = kb : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(PT, "computeNewHighWaterMark");
  function Bb(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = PT(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(Bb, "howMuchToRead");
  ie.prototype.read = function(e) {
    J("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended))
      return J("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Ll(this) : to(this), null;
    if (e = Bb(e, t), e === 0 && t.ended)
      return t.length === 0 && Ll(this), null;
    var i = t.needReadable;
    J("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, J("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, J("reading or ended", i)) : i && (J("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Bb(r, t)));
    var s;
    return e > 0 ? s = Nb(e, t) : s = null, s === null ? (t.needReadable = !0, e = 0) : t.length -= e, t.length === 0 && (t.ended || (t.needReadable =
    !0), r !== e && t.ended && Ll(this)), s !== null && this.emit("data", s), s;
  };
  function qT(e, t) {
    if (!t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, to(e);
    }
  }
  n(qT, "onEofChunk");
  function to(e) {
    var t = e._readableState;
    t.needReadable = !1, t.emittedReadable || (J("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? ei.nextTick(Ob, e) : Ob(e));
  }
  n(to, "emitReadable");
  function Ob(e) {
    J("emit readable"), e.emit("readable"), Ul(e);
  }
  n(Ob, "emitReadable_");
  function Lb(e, t) {
    t.readingMore || (t.readingMore = !0, ei.nextTick(MT, e, t));
  }
  n(Lb, "maybeReadMore");
  function MT(e, t) {
    for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (J("maybeReadMore read 0"), e.read(0), r !==
    t.length); )
      r = t.length;
    t.readingMore = !1;
  }
  n(MT, "maybeReadMore_");
  ie.prototype._read = function(e) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  ie.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, J("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, o = s ? a : y;
    i.endEmitted ? ei.nextTick(o) : r.once("end", o), e.on("unpipe", u);
    function u(_, C) {
      J("onunpipe"), _ === r && C && C.hasUnpiped === !1 && (C.hasUnpiped = !0, h());
    }
    n(u, "onunpipe");
    function a() {
      J("onend"), e.end();
    }
    n(a, "onend");
    var l = jT(r);
    e.on("drain", l);
    var c = !1;
    function h() {
      J("cleanup"), e.removeListener("close", m), e.removeListener("finish", v), e.removeListener("drain", l), e.removeListener("error", f),
      e.removeListener("unpipe", u), r.removeListener("end", a), r.removeListener("end", y), r.removeListener("data", d), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(h, "cleanup");
    var p = !1;
    r.on("data", d);
    function d(_) {
      J("ondata"), p = !1;
      var C = e.write(_);
      C === !1 && !p && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && Ub(i.pipes, e) !== -1) && !c && (J("false write respons\
e, pause", i.awaitDrain), i.awaitDrain++, p = !0), r.pause());
    }
    n(d, "ondata");
    function f(_) {
      J("onerror", _), y(), e.removeListener("error", f), Pb(e, "error") === 0 && e.emit("error", _);
    }
    n(f, "onerror"), kT(e, "error", f);
    function m() {
      e.removeListener("finish", v), y();
    }
    n(m, "onclose"), e.once("close", m);
    function v() {
      J("onfinish"), e.removeListener("close", m), y();
    }
    n(v, "onfinish"), e.once("finish", v);
    function y() {
      J("unpipe"), r.unpipe(e);
    }
    return n(y, "unpipe"), e.emit("pipe", r), i.flowing || (J("pipe resume"), r.resume()), e;
  };
  function jT(e) {
    return function() {
      var t = e._readableState;
      J("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && Pb(e, "data") && (t.flowing = !0, Ul(e));
    };
  }
  n(jT, "pipeOnDrain");
  ie.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: !1 };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var o = 0; o < s; o++)
        i[o].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var u = Ub(t.pipes, e);
    return u === -1 ? this : (t.pipes.splice(u, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  ie.prototype.on = function(e, t) {
    var r = Nl.prototype.on.call(this, e, t);
    if (e === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (e === "readable") {
      var i = this._readableState;
      !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && to(
      this) : ei.nextTick(IT, this));
    }
    return r;
  };
  ie.prototype.addListener = ie.prototype.on;
  function IT(e) {
    J("readable nexttick read 0"), e.read(0);
  }
  n(IT, "nReadingNextTick");
  ie.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (J("resume"), e.flowing = !0, LT(this, e)), this;
  };
  function LT(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, ei.nextTick(NT, e, t));
  }
  n(LT, "resume");
  function NT(e, t) {
    t.reading || (J("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), Ul(e), t.flowing && !t.reading &&
    e.read(0);
  }
  n(NT, "resume_");
  ie.prototype.pause = function() {
    return J("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (J("pause"), this._readableState.flowing =
    !1, this.emit("pause")), this;
  };
  function Ul(e) {
    var t = e._readableState;
    for (J("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  n(Ul, "flow");
  ie.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (J("wrapped end"), r.decoder && !r.ended) {
        var u = r.decoder.end();
        u && u.length && t.push(u);
      }
      t.push(null);
    }), e.on("data", function(u) {
      if (J("wrapped data"), r.decoder && (u = r.decoder.write(u)), !(r.objectMode && u == null) && !(!r.objectMode && (!u || !u.length))) {
        var a = t.push(u);
        a || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = /* @__PURE__ */ function(u) {
        return function() {
          return e[u].apply(e, arguments);
        };
      }(s));
    for (var o = 0; o < jl.length; o++)
      e.on(jl[o], this.emit.bind(this, jl[o]));
    return this._read = function(u) {
      J("wrapped _read", u), i && (i = !1, e.resume());
    }, this;
  };
  Object.defineProperty(ie.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  ie._fromList = Nb;
  function Nb(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    head.data : r = t.buffer.concat(t.length), t.buffer.clear()) : r = UT(e, t.buffer, t.decoder), r;
  }
  n(Nb, "fromList");
  function UT(e, t, r) {
    var i;
    return e < t.head.data.length ? (i = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? i = t.shift() :
    i = r ? WT(e, t) : $T(e, t), i;
  }
  n(UT, "fromListPartial");
  function WT(e, t) {
    var r = t.head, i = 1, s = r.data;
    for (e -= s.length; r = r.next; ) {
      var o = r.data, u = e > o.length ? o.length : e;
      if (u === o.length ? s += o : s += o.slice(0, e), e -= u, e === 0) {
        u === o.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = o.slice(u));
        break;
      }
      ++i;
    }
    return t.length -= i, s;
  }
  n(WT, "copyFromBufferString");
  function $T(e, t) {
    var r = ln.allocUnsafe(e), i = t.head, s = 1;
    for (i.data.copy(r), e -= i.data.length; i = i.next; ) {
      var o = i.data, u = e > o.length ? o.length : e;
      if (o.copy(r, r.length - e, 0, u), e -= u, e === 0) {
        u === o.length ? (++s, i.next ? t.head = i.next : t.head = t.tail = null) : (t.head = i, i.data = o.slice(u));
        break;
      }
      ++s;
    }
    return t.length -= s, r;
  }
  n($T, "copyFromBuffer");
  function Ll(e) {
    var t = e._readableState;
    if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    t.endEmitted || (t.ended = !0, ei.nextTick(HT, t, e));
  }
  n(Ll, "endReadable");
  function HT(e, t) {
    !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"));
  }
  n(HT, "endReadableNT");
  function Ub(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(Ub, "indexOf");
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_transform.js
var Wl = g((iL, zb) => {
  "use strict";
  zb.exports = Tt;
  var ro = Dr(), Hb = Object.create(Oe());
  Hb.inherits = ee();
  Hb.inherits(Tt, ro);
  function zT(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (!i)
      return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(zT, "afterTransform");
  function Tt(e) {
    if (!(this instanceof Tt)) return new Tt(e);
    ro.call(this, e), this._transformState = {
      afterTransform: zT.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", VT);
  }
  n(Tt, "Transform");
  function VT() {
    var e = this;
    typeof this._flush == "function" ? this._flush(function(t, r) {
      $b(e, t, r);
    }) : $b(this, null, null);
  }
  n(VT, "prefinish");
  Tt.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, ro.prototype.push.call(this, e, t);
  };
  Tt.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented");
  };
  Tt.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  Tt.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) :
    t.needTransform = !0;
  };
  Tt.prototype._destroy = function(e, t) {
    var r = this;
    ro.prototype._destroy.call(this, e, function(i) {
      t(i), r.emit("close");
    });
  };
  function $b(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null);
  }
  n($b, "done");
});

// ../node_modules/peek-stream/node_modules/readable-stream/lib/_stream_passthrough.js
var Yb = g((sL, Jb) => {
  "use strict";
  Jb.exports = cn;
  var Vb = Wl(), Gb = Object.create(Oe());
  Gb.inherits = ee();
  Gb.inherits(cn, Vb);
  function cn(e) {
    if (!(this instanceof cn)) return new cn(e);
    Vb.call(this, e);
  }
  n(cn, "PassThrough");
  cn.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/peek-stream/node_modules/readable-stream/readable.js
var Kb = g((Fe, io) => {
  var ht = require("stream");
  process.env.READABLE_STREAM === "disable" && ht ? (io.exports = ht, Fe = io.exports = ht.Readable, Fe.Readable = ht.Readable, Fe.Writable =
  ht.Writable, Fe.Duplex = ht.Duplex, Fe.Transform = ht.Transform, Fe.PassThrough = ht.PassThrough, Fe.Stream = ht) : (Fe = io.exports = ql(),
  Fe.Stream = ht || Fe, Fe.Readable = Fe, Fe.Writable = Bl(), Fe.Duplex = Dr(), Fe.Transform = Wl(), Fe.PassThrough = Yb());
});

// ../node_modules/stream-shift/index.js
var $l = g((uL, Qb) => {
  Qb.exports = GT;
  function GT(e) {
    var t = e._readableState;
    return t ? t.objectMode || typeof e._duplexState == "number" ? e.read() : e.read(JT(t)) : null;
  }
  n(GT, "shift");
  function JT(e) {
    return e.buffer.length ? e.buffer.head ? e.buffer.head.data.length : e.buffer[0].length : e.length;
  }
  n(JT, "getStateLength");
});

// ../node_modules/peek-stream/node_modules/duplexify/index.js
var r0 = g((lL, t0) => {
  var no = Kb(), Xb = Nr(), YT = ee(), KT = $l(), Zb = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]), Hl = /* @__PURE__ */ n(
  function(e, t) {
    e._corked ? e.once("uncork", t) : t();
  }, "onuncork"), QT = /* @__PURE__ */ n(function(e, t) {
    e._autoDestroy && e.destroy(t);
  }, "autoDestroy"), e0 = /* @__PURE__ */ n(function(e, t) {
    return function(r) {
      r ? QT(e, r.message === "premature close" ? null : r) : t && !e._ended && e.end();
    };
  }, "destroyer"), XT = /* @__PURE__ */ n(function(e, t) {
    if (!e || e._writableState && e._writableState.finished) return t();
    if (e._writableState) return e.end(t);
    e.end(), t();
  }, "end"), ZT = /* @__PURE__ */ n(function(e) {
    return new no.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(e);
  }, "toStreams2"), xe = /* @__PURE__ */ n(function(e, t, r) {
    if (!(this instanceof xe)) return new xe(e, t, r);
    no.Duplex.call(this, r), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r || r.autoDestroy !==
    !1, this._forwardDestroy = !r || r.destroy !== !1, this._forwardEnd = !r || r.end !== !1, this._corked = 1, this._ondrain = null, this._drained =
    !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t &&
    this.setReadable(t);
  }, "Duplexify");
  YT(xe, no.Duplex);
  xe.obj = function(e, t, r) {
    return r || (r = {}), r.objectMode = !0, r.highWaterMark = 16, new xe(e, t, r);
  };
  xe.prototype.cork = function() {
    ++this._corked === 1 && this.emit("cork");
  };
  xe.prototype.uncork = function() {
    this._corked && --this._corked === 0 && this.emit("uncork");
  };
  xe.prototype.setWritable = function(e) {
    if (this._unwrite && this._unwrite(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.end();
      return;
    }
    var t = this, r = Xb(e, { writable: !0, readable: !1 }, e0(this, this._forwardEnd)), i = /* @__PURE__ */ n(function() {
      var o = t._ondrain;
      t._ondrain = null, o && o();
    }, "ondrain"), s = /* @__PURE__ */ n(function() {
      t._writable.removeListener("drain", i), r();
    }, "clear");
    this._unwrite && process.nextTick(i), this._writable = e, this._writable.on("drain", i), this._unwrite = s, this.uncork();
  };
  xe.prototype.setReadable = function(e) {
    if (this._unread && this._unread(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.push(null), this.resume();
      return;
    }
    var t = this, r = Xb(e, { writable: !1, readable: !0 }, e0(this)), i = /* @__PURE__ */ n(function() {
      t._forward();
    }, "onreadable"), s = /* @__PURE__ */ n(function() {
      t.push(null);
    }, "onend"), o = /* @__PURE__ */ n(function() {
      t._readable2.removeListener("readable", i), t._readable2.removeListener("end", s), r();
    }, "clear");
    this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : ZT(e), this._readable2.on("readable", i), this._readable2.
    on("end", s), this._unread = o, this._forward();
  };
  xe.prototype._read = function() {
    this._drained = !0, this._forward();
  };
  xe.prototype._forward = function() {
    if (!(this._forwarding || !this._readable2 || !this._drained)) {
      this._forwarding = !0;
      for (var e; this._drained && (e = KT(this._readable2)) !== null; )
        this.destroyed || (this._drained = this.push(e));
      this._forwarding = !1;
    }
  };
  xe.prototype.destroy = function(e) {
    if (!this.destroyed) {
      this.destroyed = !0;
      var t = this;
      process.nextTick(function() {
        t._destroy(e);
      });
    }
  };
  xe.prototype._destroy = function(e) {
    if (e) {
      var t = this._ondrain;
      this._ondrain = null, t ? t(e) : this.emit("error", e);
    }
    this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy &&
    this._writable.destroy()), this.emit("close");
  };
  xe.prototype._write = function(e, t, r) {
    if (this.destroyed) return r();
    if (this._corked) return Hl(this, this._write.bind(this, e, t, r));
    if (e === Zb) return this._finish(r);
    if (!this._writable) return r();
    this._writable.write(e) === !1 ? this._ondrain = r : r();
  };
  xe.prototype._finish = function(e) {
    var t = this;
    this.emit("preend"), Hl(this, function() {
      XT(t._forwardEnd && t._writable, function() {
        t._writableState.prefinished === !1 && (t._writableState.prefinished = !0), t.emit("prefinish"), Hl(t, e);
      });
    });
  };
  xe.prototype.end = function(e, t, r) {
    return typeof e == "function" ? this.end(null, null, e) : typeof t == "function" ? this.end(e, null, t) : (this._ended = !0, e && this.write(
    e), this._writableState.ending || this.write(Zb), no.Writable.prototype.end.call(this, r));
  };
  t0.exports = xe;
});

// ../node_modules/through2/node_modules/isarray/index.js
var n0 = g((fL, i0) => {
  var eR = {}.toString;
  i0.exports = Array.isArray || function(e) {
    return eR.call(e) == "[object Array]";
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream.js
var zl = g((hL, s0) => {
  s0.exports = require("stream");
});

// ../node_modules/through2/node_modules/safe-buffer/index.js
var oo = g((Vl, u0) => {
  var so = require("buffer"), Rt = so.Buffer;
  function o0(e, t) {
    for (var r in e)
      t[r] = e[r];
  }
  n(o0, "copyProps");
  Rt.from && Rt.alloc && Rt.allocUnsafe && Rt.allocUnsafeSlow ? u0.exports = so : (o0(so, Vl), Vl.Buffer = ti);
  function ti(e, t, r) {
    return Rt(e, t, r);
  }
  n(ti, "SafeBuffer");
  o0(Rt, ti);
  ti.from = function(e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return Rt(e, t, r);
  };
  ti.alloc = function(e, t, r) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var i = Rt(e);
    return t !== void 0 ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
  };
  ti.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return Rt(e);
  };
  ti.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return so.SlowBuffer(e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var l0 = g((pL, Gl) => {
  "use strict";
  function tR(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(tR, "_classCallCheck");
  var a0 = oo().Buffer, fn = require("util");
  function rR(e, t, r) {
    e.copy(t, r);
  }
  n(rR, "copyBuffer");
  Gl.exports = function() {
    function e() {
      tR(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), e.prototype.push = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    }, "push"), e.prototype.unshift = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    }, "unshift"), e.prototype.shift = /* @__PURE__ */ n(function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    }, "shift"), e.prototype.clear = /* @__PURE__ */ n(function() {
      this.head = this.tail = null, this.length = 0;
    }, "clear"), e.prototype.join = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return "";
      for (var i = this.head, s = "" + i.data; i = i.next; )
        s += r + i.data;
      return s;
    }, "join"), e.prototype.concat = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return a0.alloc(0);
      for (var i = a0.allocUnsafe(r >>> 0), s = this.head, o = 0; s; )
        rR(s.data, i, o), o += s.data.length, s = s.next;
      return i;
    }, "concat"), e;
  }();
  fn && fn.inspect && fn.inspect.custom && (Gl.exports.prototype[fn.inspect.custom] = function() {
    var e = fn.inspect({ length: this.length });
    return this.constructor.name + " " + e;
  });
});

// ../node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js
var Jl = g((mL, c0) => {
  "use strict";
  var uo = $e();
  function iR(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, uo.nextTick(
    ao, this, e)) : uo.nextTick(ao, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this.
    _writableState.destroyed = !0), this._destroy(e || null, function(o) {
      !t && o ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, uo.nextTick(ao, r, o)) : uo.nextTick(
      ao, r, o) : t && t(o);
    }), this);
  }
  n(iR, "destroy");
  function nR() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(nR, "undestroy");
  function ao(e, t) {
    e.emit("error", t);
  }
  n(ao, "emitErrorNT");
  c0.exports = {
    destroy: iR,
    undestroy: nR
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js
var Kl = g((gL, g0) => {
  "use strict";
  var mr = $e();
  g0.exports = ge;
  function h0(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      _R(t, e);
    };
  }
  n(h0, "CorkedRequest");
  var sR = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : mr.nextTick, ri;
  ge.WritableState = dn;
  var d0 = Object.create(Oe());
  d0.inherits = ee();
  var oR = {
    deprecate: $i()
  }, p0 = zl(), co = oo().Buffer, uR = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
  function() {
  };
  function aR(e) {
    return co.from(e);
  }
  n(aR, "_uint8ArrayToBuffer");
  function lR(e) {
    return co.isBuffer(e) || e instanceof uR;
  }
  n(lR, "_isUint8Array");
  var D0 = Jl();
  d0.inherits(ge, p0);
  function cR() {
  }
  n(cR, "nop");
  function dn(e, t) {
    ri = ri || yr(), e = e || {};
    var r = t instanceof ri;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode);
    var i = e.highWaterMark, s = e.writableHighWaterMark, o = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = o, this.highWaterMark = Math.
    floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed =
    !1;
    var u = e.decodeStrings === !1;
    this.decodeStrings = !u, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(a) {
      yR(t, a);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new h0(this);
  }
  n(dn, "WritableState");
  dn.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(dn.prototype, "buffer", {
        get: oR.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var lo;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (lo = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(ge, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(e) {
      return lo.call(this, e) ? !0 : this !== ge ? !1 : e && e._writableState instanceof dn;
    }, "value")
  })) : lo = /* @__PURE__ */ n(function(e) {
    return e instanceof this;
  }, "realHasInstance");
  function ge(e) {
    if (ri = ri || yr(), !lo.call(ge, this) && !(this instanceof ri))
      return new ge(e);
    this._writableState = new dn(e, this), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), p0.call(this);
  }
  n(ge, "Writable");
  ge.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function fR(e, t) {
    var r = new Error("write after end");
    e.emit("error", r), mr.nextTick(t, r);
  }
  n(fR, "writeAfterEnd");
  function hR(e, t, r, i) {
    var s = !0, o = !1;
    return r === null ? o = new TypeError("May not write null values to stream") : typeof r != "string" && r !== void 0 && !t.objectMode && (o =
    new TypeError("Invalid non-string/buffer chunk")), o && (e.emit("error", o), mr.nextTick(i, o), s = !1), s;
  }
  n(hR, "validChunk");
  ge.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, o = !i.objectMode && lR(e);
    return o && !co.isBuffer(e) && (e = aR(e)), typeof t == "function" && (r = t, t = null), o ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = cR), i.ended ? fR(this, r) : (o || hR(this, i, e, r)) && (i.pendingcb++, s = pR(this, i, o, e, t, r)), s;
  };
  ge.prototype.cork = function() {
    var e = this._writableState;
    e.corked++;
  };
  ge.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && m0(this, e));
  };
  ge.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  function dR(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = co.from(t, r)), t;
  }
  n(dR, "decodeChunk");
  Object.defineProperty(ge.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function pR(e, t, r, i, s, o) {
    if (!r) {
      var u = dR(t, i, s);
      i !== u && (r = !0, s = "buffer", i = u);
    }
    var a = t.objectMode ? 1 : i.length;
    t.length += a;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: o,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      Yl(e, t, !1, a, i, s, o);
    return l;
  }
  n(pR, "writeOrBuffer");
  function Yl(e, t, r, i, s, o, u) {
    t.writelen = i, t.writecb = u, t.writing = !0, t.sync = !0, r ? e._writev(s, t.onwrite) : e._write(s, o, t.onwrite), t.sync = !1;
  }
  n(Yl, "doWrite");
  function DR(e, t, r, i, s) {
    --t.pendingcb, r ? (mr.nextTick(s, i), mr.nextTick(hn, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (s(i), e._writableState.
    errorEmitted = !0, e.emit("error", i), hn(e, t));
  }
  n(DR, "onwriteError");
  function mR(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(mR, "onwriteStateUpdate");
  function yR(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (mR(r), t) DR(e, r, i, t, s);
    else {
      var o = y0(r);
      !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && m0(e, r), i ? sR(f0, e, r, o, s) : f0(e, r, o, s);
    }
  }
  n(yR, "onwrite");
  function f0(e, t, r, i) {
    r || gR(e, t), t.pendingcb--, i(), hn(e, t);
  }
  n(f0, "afterWrite");
  function gR(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(gR, "onwriteDrain");
  function m0(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), o = t.corkedRequestsFree;
      o.entry = r;
      for (var u = 0, a = !0; r; )
        s[u] = r, r.isBuf || (a = !1), r = r.next, u += 1;
      s.allBuffers = a, Yl(e, t, !0, t.length, s, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree =
      o.next, o.next = null) : t.corkedRequestsFree = new h0(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, h = r.callback, p = t.objectMode ? 1 : l.length;
        if (Yl(e, t, !1, p, l, c, h), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(m0, "clearBuffer");
  ge.prototype._write = function(e, t, r) {
    r(new Error("_write() is not implemented"));
  };
  ge.prototype._writev = null;
  ge.prototype.end = function(e, t, r) {
    var i = this._writableState;
    typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked &&
    (i.corked = 1, this.uncork()), i.ending || vR(this, i, r);
  };
  function y0(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(y0, "needFinish");
  function bR(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), hn(e, t);
    });
  }
  n(bR, "callFinal");
  function wR(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" ? (t.pendingcb++, t.finalCalled = !0, mr.nextTick(bR, e, t)) : (t.prefinished =
    !0, e.emit("prefinish")));
  }
  n(wR, "prefinish");
  function hn(e, t) {
    var r = y0(t);
    return r && (wR(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"))), r;
  }
  n(hn, "finishMaybe");
  function vR(e, t, r) {
    t.ending = !0, hn(e, t), r && (t.finished ? mr.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(vR, "endWritable");
  function _R(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(_R, "onCorkedFinish");
  Object.defineProperty(ge.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._writableState && (this._writableState.destroyed = e);
    }, "set")
  });
  ge.prototype.destroy = D0.destroy;
  ge.prototype._undestroy = D0.undestroy;
  ge.prototype._destroy = function(e, t) {
    this.end(), t(e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js
var yr = g((wL, _0) => {
  "use strict";
  var b0 = $e(), ER = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  _0.exports = kt;
  var w0 = Object.create(Oe());
  w0.inherits = ee();
  var v0 = Zl(), Xl = Kl();
  w0.inherits(kt, v0);
  for (Ql = ER(Xl.prototype), fo = 0; fo < Ql.length; fo++)
    ho = Ql[fo], kt.prototype[ho] || (kt.prototype[ho] = Xl.prototype[ho]);
  var Ql, ho, fo;
  function kt(e) {
    if (!(this instanceof kt)) return new kt(e);
    v0.call(this, e), Xl.call(this, e), e && e.readable === !1 && (this.readable = !1), e && e.writable === !1 && (this.writable = !1), this.
    allowHalfOpen = !0, e && e.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", CR);
  }
  n(kt, "Duplex");
  Object.defineProperty(kt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function CR() {
    this.allowHalfOpen || this._writableState.ended || b0.nextTick(FR, this);
  }
  n(CR, "onend");
  function FR(e) {
    e.end();
  }
  n(FR, "onEndNT");
  Object.defineProperty(kt.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed =
      e);
    }, "set")
  });
  kt.prototype._destroy = function(e, t) {
    this.push(null), this.end(), b0.nextTick(t, e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js
var Zl = g((EL, P0) => {
  "use strict";
  var ni = $e();
  P0.exports = ne;
  var xR = n0(), pn;
  ne.ReadableState = T0;
  var _L = require("events").EventEmitter, x0 = /* @__PURE__ */ n(function(e, t) {
    return e.listeners(t).length;
  }, "EElistenerCount"), nc = zl(), Dn = oo().Buffer, SR = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ?
  self : {}).Uint8Array || function() {
  };
  function AR(e) {
    return Dn.from(e);
  }
  n(AR, "_uint8ArrayToBuffer");
  function TR(e) {
    return Dn.isBuffer(e) || e instanceof SR;
  }
  n(TR, "_isUint8Array");
  var S0 = Object.create(Oe());
  S0.inherits = ee();
  var ec = require("util"), Y = void 0;
  ec && ec.debuglog ? Y = ec.debuglog("stream") : Y = /* @__PURE__ */ n(function() {
  }, "debug");
  var RR = l0(), A0 = Jl(), ii;
  S0.inherits(ne, nc);
  var tc = ["error", "close", "destroy", "pause", "resume"];
  function kR(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : xR(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(kR, "prependListener");
  function T0(e, t) {
    pn = pn || yr(), e = e || {};
    var r = t instanceof pn;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode);
    var i = e.highWaterMark, s = e.readableHighWaterMark, o = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = o, this.highWaterMark = Math.
    floor(this.highWaterMark), this.buffer = new RR(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended =
    !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening =
    !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore =
    !1, this.decoder = null, this.encoding = null, e.encoding && (ii || (ii = require("string_decoder/").StringDecoder), this.decoder = new ii(
    e.encoding), this.encoding = e.encoding);
  }
  n(T0, "ReadableState");
  function ne(e) {
    if (pn = pn || yr(), !(this instanceof ne)) return new ne(e);
    this._readableState = new T0(e, this), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), nc.call(this);
  }
  n(ne, "Readable");
  Object.defineProperty(ne.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState && (this._readableState.destroyed = e);
    }, "set")
  });
  ne.prototype.destroy = A0.destroy;
  ne.prototype._undestroy = A0.undestroy;
  ne.prototype._destroy = function(e, t) {
    this.push(null), t(e);
  };
  ne.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = Dn.from(e, t), t = ""), i =
    !0), R0(this, e, t, !1, i);
  };
  ne.prototype.unshift = function(e) {
    return R0(this, e, null, !0, !1);
  };
  function R0(e, t, r, i, s) {
    var o = e._readableState;
    if (t === null)
      o.reading = !1, qR(e, o);
    else {
      var u;
      s || (u = BR(o, t)), u ? e.emit("error", u) : o.objectMode || t && t.length > 0 ? (typeof t != "string" && !o.objectMode && Object.getPrototypeOf(
      t) !== Dn.prototype && (t = AR(t)), i ? o.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : rc(e, o, t, !0) :
      o.ended ? e.emit("error", new Error("stream.push() after EOF")) : (o.reading = !1, o.decoder && !r ? (t = o.decoder.write(t), o.objectMode ||
      t.length !== 0 ? rc(e, o, t, !1) : k0(e, o)) : rc(e, o, t, !1))) : i || (o.reading = !1);
    }
    return OR(o);
  }
  n(R0, "readableAddChunk");
  function rc(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(
    r) : t.buffer.push(r), t.needReadable && po(e)), k0(e, t);
  }
  n(rc, "addChunk");
  function BR(e, t) {
    var r;
    return !TR(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new TypeError("Invalid non-string/buffer chunk")), r;
  }
  n(BR, "chunkInvalid");
  function OR(e) {
    return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
  }
  n(OR, "needMoreData");
  ne.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  ne.prototype.setEncoding = function(e) {
    return ii || (ii = require("string_decoder/").StringDecoder), this._readableState.decoder = new ii(e), this._readableState.encoding = e,
    this;
  };
  var E0 = 8388608;
  function PR(e) {
    return e >= E0 ? e = E0 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(PR, "computeNewHighWaterMark");
  function C0(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = PR(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(C0, "howMuchToRead");
  ne.prototype.read = function(e) {
    Y("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended))
      return Y("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? ic(this) : po(this), null;
    if (e = C0(e, t), e === 0 && t.ended)
      return t.length === 0 && ic(this), null;
    var i = t.needReadable;
    Y("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, Y("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, Y("reading or ended", i)) : i && (Y("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = C0(r, t)));
    var s;
    return e > 0 ? s = B0(e, t) : s = null, s === null ? (t.needReadable = !0, e = 0) : t.length -= e, t.length === 0 && (t.ended || (t.needReadable =
    !0), r !== e && t.ended && ic(this)), s !== null && this.emit("data", s), s;
  };
  function qR(e, t) {
    if (!t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, po(e);
    }
  }
  n(qR, "onEofChunk");
  function po(e) {
    var t = e._readableState;
    t.needReadable = !1, t.emittedReadable || (Y("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? ni.nextTick(F0, e) : F0(e));
  }
  n(po, "emitReadable");
  function F0(e) {
    Y("emit readable"), e.emit("readable"), sc(e);
  }
  n(F0, "emitReadable_");
  function k0(e, t) {
    t.readingMore || (t.readingMore = !0, ni.nextTick(MR, e, t));
  }
  n(k0, "maybeReadMore");
  function MR(e, t) {
    for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (Y("maybeReadMore read 0"), e.read(0), r !==
    t.length); )
      r = t.length;
    t.readingMore = !1;
  }
  n(MR, "maybeReadMore_");
  ne.prototype._read = function(e) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  ne.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, Y("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, o = s ? a : y;
    i.endEmitted ? ni.nextTick(o) : r.once("end", o), e.on("unpipe", u);
    function u(_, C) {
      Y("onunpipe"), _ === r && C && C.hasUnpiped === !1 && (C.hasUnpiped = !0, h());
    }
    n(u, "onunpipe");
    function a() {
      Y("onend"), e.end();
    }
    n(a, "onend");
    var l = jR(r);
    e.on("drain", l);
    var c = !1;
    function h() {
      Y("cleanup"), e.removeListener("close", m), e.removeListener("finish", v), e.removeListener("drain", l), e.removeListener("error", f),
      e.removeListener("unpipe", u), r.removeListener("end", a), r.removeListener("end", y), r.removeListener("data", d), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(h, "cleanup");
    var p = !1;
    r.on("data", d);
    function d(_) {
      Y("ondata"), p = !1;
      var C = e.write(_);
      C === !1 && !p && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && O0(i.pipes, e) !== -1) && !c && (Y("false write respons\
e, pause", i.awaitDrain), i.awaitDrain++, p = !0), r.pause());
    }
    n(d, "ondata");
    function f(_) {
      Y("onerror", _), y(), e.removeListener("error", f), x0(e, "error") === 0 && e.emit("error", _);
    }
    n(f, "onerror"), kR(e, "error", f);
    function m() {
      e.removeListener("finish", v), y();
    }
    n(m, "onclose"), e.once("close", m);
    function v() {
      Y("onfinish"), e.removeListener("close", m), y();
    }
    n(v, "onfinish"), e.once("finish", v);
    function y() {
      Y("unpipe"), r.unpipe(e);
    }
    return n(y, "unpipe"), e.emit("pipe", r), i.flowing || (Y("pipe resume"), r.resume()), e;
  };
  function jR(e) {
    return function() {
      var t = e._readableState;
      Y("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && x0(e, "data") && (t.flowing = !0, sc(e));
    };
  }
  n(jR, "pipeOnDrain");
  ne.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: !1 };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var o = 0; o < s; o++)
        i[o].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var u = O0(t.pipes, e);
    return u === -1 ? this : (t.pipes.splice(u, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  ne.prototype.on = function(e, t) {
    var r = nc.prototype.on.call(this, e, t);
    if (e === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (e === "readable") {
      var i = this._readableState;
      !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && po(
      this) : ni.nextTick(IR, this));
    }
    return r;
  };
  ne.prototype.addListener = ne.prototype.on;
  function IR(e) {
    Y("readable nexttick read 0"), e.read(0);
  }
  n(IR, "nReadingNextTick");
  ne.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (Y("resume"), e.flowing = !0, LR(this, e)), this;
  };
  function LR(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, ni.nextTick(NR, e, t));
  }
  n(LR, "resume");
  function NR(e, t) {
    t.reading || (Y("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), sc(e), t.flowing && !t.reading &&
    e.read(0);
  }
  n(NR, "resume_");
  ne.prototype.pause = function() {
    return Y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Y("pause"), this._readableState.flowing =
    !1, this.emit("pause")), this;
  };
  function sc(e) {
    var t = e._readableState;
    for (Y("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  n(sc, "flow");
  ne.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (Y("wrapped end"), r.decoder && !r.ended) {
        var u = r.decoder.end();
        u && u.length && t.push(u);
      }
      t.push(null);
    }), e.on("data", function(u) {
      if (Y("wrapped data"), r.decoder && (u = r.decoder.write(u)), !(r.objectMode && u == null) && !(!r.objectMode && (!u || !u.length))) {
        var a = t.push(u);
        a || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = /* @__PURE__ */ function(u) {
        return function() {
          return e[u].apply(e, arguments);
        };
      }(s));
    for (var o = 0; o < tc.length; o++)
      e.on(tc[o], this.emit.bind(this, tc[o]));
    return this._read = function(u) {
      Y("wrapped _read", u), i && (i = !1, e.resume());
    }, this;
  };
  Object.defineProperty(ne.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  ne._fromList = B0;
  function B0(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    head.data : r = t.buffer.concat(t.length), t.buffer.clear()) : r = UR(e, t.buffer, t.decoder), r;
  }
  n(B0, "fromList");
  function UR(e, t, r) {
    var i;
    return e < t.head.data.length ? (i = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? i = t.shift() :
    i = r ? WR(e, t) : $R(e, t), i;
  }
  n(UR, "fromListPartial");
  function WR(e, t) {
    var r = t.head, i = 1, s = r.data;
    for (e -= s.length; r = r.next; ) {
      var o = r.data, u = e > o.length ? o.length : e;
      if (u === o.length ? s += o : s += o.slice(0, e), e -= u, e === 0) {
        u === o.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = o.slice(u));
        break;
      }
      ++i;
    }
    return t.length -= i, s;
  }
  n(WR, "copyFromBufferString");
  function $R(e, t) {
    var r = Dn.allocUnsafe(e), i = t.head, s = 1;
    for (i.data.copy(r), e -= i.data.length; i = i.next; ) {
      var o = i.data, u = e > o.length ? o.length : e;
      if (o.copy(r, r.length - e, 0, u), e -= u, e === 0) {
        u === o.length ? (++s, i.next ? t.head = i.next : t.head = t.tail = null) : (t.head = i, i.data = o.slice(u));
        break;
      }
      ++s;
    }
    return t.length -= s, r;
  }
  n($R, "copyFromBuffer");
  function ic(e) {
    var t = e._readableState;
    if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    t.endEmitted || (t.ended = !0, ni.nextTick(HR, t, e));
  }
  n(ic, "endReadable");
  function HR(e, t) {
    !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"));
  }
  n(HR, "endReadableNT");
  function O0(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(O0, "indexOf");
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js
var oc = g((FL, j0) => {
  "use strict";
  j0.exports = Bt;
  var Do = yr(), M0 = Object.create(Oe());
  M0.inherits = ee();
  M0.inherits(Bt, Do);
  function zR(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (!i)
      return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(zR, "afterTransform");
  function Bt(e) {
    if (!(this instanceof Bt)) return new Bt(e);
    Do.call(this, e), this._transformState = {
      afterTransform: zR.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", VR);
  }
  n(Bt, "Transform");
  function VR() {
    var e = this;
    typeof this._flush == "function" ? this._flush(function(t, r) {
      q0(e, t, r);
    }) : q0(this, null, null);
  }
  n(VR, "prefinish");
  Bt.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, Do.prototype.push.call(this, e, t);
  };
  Bt.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented");
  };
  Bt.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  Bt.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) :
    t.needTransform = !0;
  };
  Bt.prototype._destroy = function(e, t) {
    var r = this;
    Do.prototype._destroy.call(this, e, function(i) {
      t(i), r.emit("close");
    });
  };
  function q0(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null);
  }
  n(q0, "done");
});

// ../node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js
var U0 = g((SL, N0) => {
  "use strict";
  N0.exports = mn;
  var I0 = oc(), L0 = Object.create(Oe());
  L0.inherits = ee();
  L0.inherits(mn, I0);
  function mn(e) {
    if (!(this instanceof mn)) return new mn(e);
    I0.call(this, e);
  }
  n(mn, "PassThrough");
  mn.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/through2/node_modules/readable-stream/readable.js
var W0 = g((Se, mo) => {
  var dt = require("stream");
  process.env.READABLE_STREAM === "disable" && dt ? (mo.exports = dt, Se = mo.exports = dt.Readable, Se.Readable = dt.Readable, Se.Writable =
  dt.Writable, Se.Duplex = dt.Duplex, Se.Transform = dt.Transform, Se.PassThrough = dt.PassThrough, Se.Stream = dt) : (Se = mo.exports = Zl(),
  Se.Stream = dt || Se, Se.Readable = Se, Se.Writable = Kl(), Se.Duplex = yr(), Se.Transform = oc(), Se.PassThrough = U0());
});

// ../node_modules/xtend/immutable.js
var H0 = g((TL, $0) => {
  $0.exports = JR;
  var GR = Object.prototype.hasOwnProperty;
  function JR() {
    for (var e = {}, t = 0; t < arguments.length; t++) {
      var r = arguments[t];
      for (var i in r)
        GR.call(r, i) && (e[i] = r[i]);
    }
    return e;
  }
  n(JR, "extend");
});

// ../node_modules/through2/through2.js
var ac = g((kL, yo) => {
  var z0 = W0().Transform, V0 = require("util").inherits, G0 = H0();
  function si(e) {
    z0.call(this, e), this._destroyed = !1;
  }
  n(si, "DestroyableTransform");
  V0(si, z0);
  si.prototype.destroy = function(e) {
    if (!this._destroyed) {
      this._destroyed = !0;
      var t = this;
      process.nextTick(function() {
        e && t.emit("error", e), t.emit("close");
      });
    }
  };
  function YR(e, t, r) {
    r(null, e);
  }
  n(YR, "noop");
  function uc(e) {
    return function(t, r, i) {
      return typeof t == "function" && (i = r, r = t, t = {}), typeof r != "function" && (r = YR), typeof i != "function" && (i = null), e(t,
      r, i);
    };
  }
  n(uc, "through2");
  yo.exports = uc(function(e, t, r) {
    var i = new si(e);
    return i._transform = t, r && (i._flush = r), i;
  });
  yo.exports.ctor = uc(function(e, t, r) {
    function i(s) {
      if (!(this instanceof i))
        return new i(s);
      this.options = G0(e, s), si.call(this, this.options);
    }
    return n(i, "Through2"), V0(i, si), i.prototype._transform = t, r && (i.prototype._flush = r), i;
  });
  yo.exports.obj = uc(function(e, t, r) {
    var i = new si(G0({ objectMode: !0, highWaterMark: 16 }, e));
    return i._transform = t, r && (i._flush = r), i;
  });
});

// ../node_modules/buffer-from/index.js
var Y0 = g((OL, J0) => {
  var KR = Object.prototype.toString, lc = typeof Buffer < "u" && typeof Buffer.alloc == "function" && typeof Buffer.allocUnsafe == "functio\
n" && typeof Buffer.from == "function";
  function QR(e) {
    return KR.call(e).slice(8, -1) === "ArrayBuffer";
  }
  n(QR, "isArrayBuffer");
  function XR(e, t, r) {
    t >>>= 0;
    var i = e.byteLength - t;
    if (i < 0)
      throw new RangeError("'offset' is out of bounds");
    if (r === void 0)
      r = i;
    else if (r >>>= 0, r > i)
      throw new RangeError("'length' is out of bounds");
    return lc ? Buffer.from(e.slice(t, t + r)) : new Buffer(new Uint8Array(e.slice(t, t + r)));
  }
  n(XR, "fromArrayBuffer");
  function ZR(e, t) {
    if ((typeof t != "string" || t === "") && (t = "utf8"), !Buffer.isEncoding(t))
      throw new TypeError('"encoding" must be a valid string encoding');
    return lc ? Buffer.from(e, t) : new Buffer(e, t);
  }
  n(ZR, "fromString");
  function e8(e, t, r) {
    if (typeof e == "number")
      throw new TypeError('"value" argument must not be a number');
    return QR(e) ? XR(e, t, r) : typeof e == "string" ? ZR(e, t) : lc ? Buffer.from(e) : new Buffer(e);
  }
  n(e8, "bufferFrom");
  J0.exports = e8;
});

// ../node_modules/peek-stream/index.js
var X0 = g((qL, Q0) => {
  var t8 = r0(), r8 = ac(), i8 = Y0(), n8 = /* @__PURE__ */ n(function(e) {
    return !Buffer.isBuffer(e) && typeof e != "string";
  }, "isObject"), K0 = /* @__PURE__ */ n(function(e, t) {
    if (typeof e == "number" && (e = { maxBuffer: e }), typeof e == "function") return K0(null, e);
    e || (e = {});
    var r = typeof e.maxBuffer == "number" ? e.maxBuffer : 65535, i = e.strict, s = e.newline !== !1, o = [], u = 0, a = t8.obj(), l = r8.obj(
    { highWaterMark: 1 }, function(p, d, f) {
      if (n8(p)) return h(p, null, f);
      if (Buffer.isBuffer(p) || (p = i8(p)), s) {
        var m = Array.prototype.indexOf.call(p, 10);
        if (m > 0 && p[m - 1] === 13 && m--, m > -1)
          return o.push(p.slice(0, m)), h(Buffer.concat(o), p.slice(m), f);
      }
      if (o.push(p), u += p.length, u < r) return f();
      if (i) return f(new Error("No newline found"));
      h(Buffer.concat(o), null, f);
    }), c = /* @__PURE__ */ n(function() {
      if (i) return a.destroy(new Error("No newline found"));
      a.cork(), h(Buffer.concat(o), null, function(p) {
        if (p) return a.destroy(p);
        a.uncork();
      });
    }, "onpreend"), h = /* @__PURE__ */ n(function(p, d, f) {
      a.removeListener("preend", c), t(p, function(m, v) {
        if (m) return f(m);
        a.setWritable(v), a.setReadable(v), p && v.write(p), d && v.write(d), d = o = l = null, f();
      });
    }, "ready");
    return a.on("preend", c), a.setWritable(l), a;
  }, "peek");
  Q0.exports = K0;
});

// ../node_modules/pumpify/node_modules/pump/index.js
var tw = g((jL, ew) => {
  var s8 = _s(), o8 = Nr(), cc = require("fs"), yn = /* @__PURE__ */ n(function() {
  }, "noop"), u8 = /^v?\.0/.test(process.version), go = /* @__PURE__ */ n(function(e) {
    return typeof e == "function";
  }, "isFn"), a8 = /* @__PURE__ */ n(function(e) {
    return !u8 || !cc ? !1 : (e instanceof (cc.ReadStream || yn) || e instanceof (cc.WriteStream || yn)) && go(e.close);
  }, "isFS"), l8 = /* @__PURE__ */ n(function(e) {
    return e.setHeader && go(e.abort);
  }, "isRequest"), c8 = /* @__PURE__ */ n(function(e, t, r, i) {
    i = s8(i);
    var s = !1;
    e.on("close", function() {
      s = !0;
    }), o8(e, { readable: t, writable: r }, function(u) {
      if (u) return i(u);
      s = !0, i();
    });
    var o = !1;
    return function(u) {
      if (!s && !o) {
        if (o = !0, a8(e)) return e.close(yn);
        if (l8(e)) return e.abort();
        if (go(e.destroy)) return e.destroy();
        i(u || new Error("stream was destroyed"));
      }
    };
  }, "destroyer"), Z0 = /* @__PURE__ */ n(function(e) {
    e();
  }, "call"), f8 = /* @__PURE__ */ n(function(e, t) {
    return e.pipe(t);
  }, "pipe"), h8 = /* @__PURE__ */ n(function() {
    var e = Array.prototype.slice.call(arguments), t = go(e[e.length - 1] || yn) && e.pop() || yn;
    if (Array.isArray(e[0]) && (e = e[0]), e.length < 2) throw new Error("pump requires two streams per minimum");
    var r, i = e.map(function(s, o) {
      var u = o < e.length - 1, a = o > 0;
      return c8(s, u, a, function(l) {
        r || (r = l), l && i.forEach(Z0), !u && (i.forEach(Z0), t(r));
      });
    });
    e.reduce(f8);
  }, "pump");
  ew.exports = h8;
});

// ../node_modules/pumpify/node_modules/isarray/index.js
var iw = g((LL, rw) => {
  var d8 = {}.toString;
  rw.exports = Array.isArray || function(e) {
    return d8.call(e) == "[object Array]";
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/stream.js
var fc = g((NL, nw) => {
  nw.exports = require("stream");
});

// ../node_modules/pumpify/node_modules/safe-buffer/index.js
var wo = g((hc, ow) => {
  var bo = require("buffer"), Ot = bo.Buffer;
  function sw(e, t) {
    for (var r in e)
      t[r] = e[r];
  }
  n(sw, "copyProps");
  Ot.from && Ot.alloc && Ot.allocUnsafe && Ot.allocUnsafeSlow ? ow.exports = bo : (sw(bo, hc), hc.Buffer = oi);
  function oi(e, t, r) {
    return Ot(e, t, r);
  }
  n(oi, "SafeBuffer");
  sw(Ot, oi);
  oi.from = function(e, t, r) {
    if (typeof e == "number")
      throw new TypeError("Argument must not be a number");
    return Ot(e, t, r);
  };
  oi.alloc = function(e, t, r) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    var i = Ot(e);
    return t !== void 0 ? typeof r == "string" ? i.fill(t, r) : i.fill(t) : i.fill(0), i;
  };
  oi.allocUnsafe = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return Ot(e);
  };
  oi.allocUnsafeSlow = function(e) {
    if (typeof e != "number")
      throw new TypeError("Argument must be a number");
    return bo.SlowBuffer(e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/BufferList.js
var aw = g((WL, dc) => {
  "use strict";
  function p8(e, t) {
    if (!(e instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }
  n(p8, "_classCallCheck");
  var uw = wo().Buffer, gn = require("util");
  function D8(e, t, r) {
    e.copy(t, r);
  }
  n(D8, "copyBuffer");
  dc.exports = function() {
    function e() {
      p8(this, e), this.head = null, this.tail = null, this.length = 0;
    }
    return n(e, "BufferList"), e.prototype.push = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: null };
      this.length > 0 ? this.tail.next = i : this.head = i, this.tail = i, ++this.length;
    }, "push"), e.prototype.unshift = /* @__PURE__ */ n(function(r) {
      var i = { data: r, next: this.head };
      this.length === 0 && (this.tail = i), this.head = i, ++this.length;
    }, "unshift"), e.prototype.shift = /* @__PURE__ */ n(function() {
      if (this.length !== 0) {
        var r = this.head.data;
        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, r;
      }
    }, "shift"), e.prototype.clear = /* @__PURE__ */ n(function() {
      this.head = this.tail = null, this.length = 0;
    }, "clear"), e.prototype.join = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return "";
      for (var i = this.head, s = "" + i.data; i = i.next; )
        s += r + i.data;
      return s;
    }, "join"), e.prototype.concat = /* @__PURE__ */ n(function(r) {
      if (this.length === 0) return uw.alloc(0);
      for (var i = uw.allocUnsafe(r >>> 0), s = this.head, o = 0; s; )
        D8(s.data, i, o), o += s.data.length, s = s.next;
      return i;
    }, "concat"), e;
  }();
  gn && gn.inspect && gn.inspect.custom && (dc.exports.prototype[gn.inspect.custom] = function() {
    var e = gn.inspect({ length: this.length });
    return this.constructor.name + " " + e;
  });
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/internal/streams/destroy.js
var pc = g((HL, lw) => {
  "use strict";
  var vo = $e();
  function m8(e, t) {
    var r = this, i = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
    return i || s ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, vo.nextTick(
    _o, this, e)) : vo.nextTick(_o, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this.
    _writableState.destroyed = !0), this._destroy(e || null, function(o) {
      !t && o ? r._writableState ? r._writableState.errorEmitted || (r._writableState.errorEmitted = !0, vo.nextTick(_o, r, o)) : vo.nextTick(
      _o, r, o) : t && t(o);
    }), this);
  }
  n(m8, "destroy");
  function y8() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.
    endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending =
    !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted =
    !1);
  }
  n(y8, "undestroy");
  function _o(e, t) {
    e.emit("error", t);
  }
  n(_o, "emitErrorNT");
  lw.exports = {
    destroy: m8,
    undestroy: y8
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_writable.js
var mc = g((VL, yw) => {
  "use strict";
  var gr = $e();
  yw.exports = be;
  function fw(e) {
    var t = this;
    this.next = null, this.entry = null, this.finish = function() {
      q8(t, e);
    };
  }
  n(fw, "CorkedRequest");
  var g8 = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : gr.nextTick, ui;
  be.WritableState = wn;
  var hw = Object.create(Oe());
  hw.inherits = ee();
  var b8 = {
    deprecate: $i()
  }, dw = fc(), Co = wo().Buffer, w8 = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array ||
  function() {
  };
  function v8(e) {
    return Co.from(e);
  }
  n(v8, "_uint8ArrayToBuffer");
  function _8(e) {
    return Co.isBuffer(e) || e instanceof w8;
  }
  n(_8, "_isUint8Array");
  var pw = pc();
  hw.inherits(be, dw);
  function E8() {
  }
  n(E8, "nop");
  function wn(e, t) {
    ui = ui || br(), e = e || {};
    var r = t instanceof ui;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.writableObjectMode);
    var i = e.highWaterMark, s = e.writableHighWaterMark, o = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = o, this.highWaterMark = Math.
    floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed =
    !1;
    var u = e.decodeStrings === !1;
    this.decodeStrings = !u, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync =
    !0, this.bufferProcessing = !1, this.onwrite = function(a) {
      R8(t, a);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished =
    !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new fw(this);
  }
  n(wn, "WritableState");
  wn.prototype.getBuffer = /* @__PURE__ */ n(function() {
    for (var t = this.bufferedRequest, r = []; t; )
      r.push(t), t = t.next;
    return r;
  }, "getBuffer");
  (function() {
    try {
      Object.defineProperty(wn.prototype, "buffer", {
        get: b8.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  })();
  var Eo;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Eo = Function.prototype[Symbol.
  hasInstance], Object.defineProperty(be, Symbol.hasInstance, {
    value: /* @__PURE__ */ n(function(e) {
      return Eo.call(this, e) ? !0 : this !== be ? !1 : e && e._writableState instanceof wn;
    }, "value")
  })) : Eo = /* @__PURE__ */ n(function(e) {
    return e instanceof this;
  }, "realHasInstance");
  function be(e) {
    if (ui = ui || br(), !Eo.call(be, this) && !(this instanceof ui))
      return new be(e);
    this._writableState = new wn(e, this), this.writable = !0, e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev ==
    "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this.
    _final = e.final)), dw.call(this);
  }
  n(be, "Writable");
  be.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function C8(e, t) {
    var r = new Error("write after end");
    e.emit("error", r), gr.nextTick(t, r);
  }
  n(C8, "writeAfterEnd");
  function F8(e, t, r, i) {
    var s = !0, o = !1;
    return r === null ? o = new TypeError("May not write null values to stream") : typeof r != "string" && r !== void 0 && !t.objectMode && (o =
    new TypeError("Invalid non-string/buffer chunk")), o && (e.emit("error", o), gr.nextTick(i, o), s = !1), s;
  }
  n(F8, "validChunk");
  be.prototype.write = function(e, t, r) {
    var i = this._writableState, s = !1, o = !i.objectMode && _8(e);
    return o && !Co.isBuffer(e) && (e = v8(e)), typeof t == "function" && (r = t, t = null), o ? t = "buffer" : t || (t = i.defaultEncoding),
    typeof r != "function" && (r = E8), i.ended ? C8(this, r) : (o || F8(this, i, e, r)) && (i.pendingcb++, s = S8(this, i, o, e, t, r)), s;
  };
  be.prototype.cork = function() {
    var e = this._writableState;
    e.corked++;
  };
  be.prototype.uncork = function() {
    var e = this._writableState;
    e.corked && (e.corked--, !e.writing && !e.corked && !e.bufferProcessing && e.bufferedRequest && Dw(this, e));
  };
  be.prototype.setDefaultEncoding = /* @__PURE__ */ n(function(t) {
    if (typeof t == "string" && (t = t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "\
utf-16le", "raw"].indexOf((t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + t);
    return this._writableState.defaultEncoding = t, this;
  }, "setDefaultEncoding");
  function x8(e, t, r) {
    return !e.objectMode && e.decodeStrings !== !1 && typeof t == "string" && (t = Co.from(t, r)), t;
  }
  n(x8, "decodeChunk");
  Object.defineProperty(be.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function S8(e, t, r, i, s, o) {
    if (!r) {
      var u = x8(t, i, s);
      i !== u && (r = !0, s = "buffer", i = u);
    }
    var a = t.objectMode ? 1 : i.length;
    t.length += a;
    var l = t.length < t.highWaterMark;
    if (l || (t.needDrain = !0), t.writing || t.corked) {
      var c = t.lastBufferedRequest;
      t.lastBufferedRequest = {
        chunk: i,
        encoding: s,
        isBuf: r,
        callback: o,
        next: null
      }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;
    } else
      Dc(e, t, !1, a, i, s, o);
    return l;
  }
  n(S8, "writeOrBuffer");
  function Dc(e, t, r, i, s, o, u) {
    t.writelen = i, t.writecb = u, t.writing = !0, t.sync = !0, r ? e._writev(s, t.onwrite) : e._write(s, o, t.onwrite), t.sync = !1;
  }
  n(Dc, "doWrite");
  function A8(e, t, r, i, s) {
    --t.pendingcb, r ? (gr.nextTick(s, i), gr.nextTick(bn, e, t), e._writableState.errorEmitted = !0, e.emit("error", i)) : (s(i), e._writableState.
    errorEmitted = !0, e.emit("error", i), bn(e, t));
  }
  n(A8, "onwriteError");
  function T8(e) {
    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;
  }
  n(T8, "onwriteStateUpdate");
  function R8(e, t) {
    var r = e._writableState, i = r.sync, s = r.writecb;
    if (T8(r), t) A8(e, r, i, t, s);
    else {
      var o = mw(r);
      !o && !r.corked && !r.bufferProcessing && r.bufferedRequest && Dw(e, r), i ? g8(cw, e, r, o, s) : cw(e, r, o, s);
    }
  }
  n(R8, "onwrite");
  function cw(e, t, r, i) {
    r || k8(e, t), t.pendingcb--, i(), bn(e, t);
  }
  n(cw, "afterWrite");
  function k8(e, t) {
    t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain"));
  }
  n(k8, "onwriteDrain");
  function Dw(e, t) {
    t.bufferProcessing = !0;
    var r = t.bufferedRequest;
    if (e._writev && r && r.next) {
      var i = t.bufferedRequestCount, s = new Array(i), o = t.corkedRequestsFree;
      o.entry = r;
      for (var u = 0, a = !0; r; )
        s[u] = r, r.isBuf || (a = !1), r = r.next, u += 1;
      s.allBuffers = a, Dc(e, t, !0, t.length, s, "", o.finish), t.pendingcb++, t.lastBufferedRequest = null, o.next ? (t.corkedRequestsFree =
      o.next, o.next = null) : t.corkedRequestsFree = new fw(t), t.bufferedRequestCount = 0;
    } else {
      for (; r; ) {
        var l = r.chunk, c = r.encoding, h = r.callback, p = t.objectMode ? 1 : l.length;
        if (Dc(e, t, !1, p, l, c, h), r = r.next, t.bufferedRequestCount--, t.writing)
          break;
      }
      r === null && (t.lastBufferedRequest = null);
    }
    t.bufferedRequest = r, t.bufferProcessing = !1;
  }
  n(Dw, "clearBuffer");
  be.prototype._write = function(e, t, r) {
    r(new Error("_write() is not implemented"));
  };
  be.prototype._writev = null;
  be.prototype.end = function(e, t, r) {
    var i = this._writableState;
    typeof e == "function" ? (r = e, e = null, t = null) : typeof t == "function" && (r = t, t = null), e != null && this.write(e, t), i.corked &&
    (i.corked = 1, this.uncork()), i.ending || P8(this, i, r);
  };
  function mw(e) {
    return e.ending && e.length === 0 && e.bufferedRequest === null && !e.finished && !e.writing;
  }
  n(mw, "needFinish");
  function B8(e, t) {
    e._final(function(r) {
      t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), bn(e, t);
    });
  }
  n(B8, "callFinal");
  function O8(e, t) {
    !t.prefinished && !t.finalCalled && (typeof e._final == "function" ? (t.pendingcb++, t.finalCalled = !0, gr.nextTick(B8, e, t)) : (t.prefinished =
    !0, e.emit("prefinish")));
  }
  n(O8, "prefinish");
  function bn(e, t) {
    var r = mw(t);
    return r && (O8(e, t), t.pendingcb === 0 && (t.finished = !0, e.emit("finish"))), r;
  }
  n(bn, "finishMaybe");
  function P8(e, t, r) {
    t.ending = !0, bn(e, t), r && (t.finished ? gr.nextTick(r) : e.once("finish", r)), t.ended = !0, e.writable = !1;
  }
  n(P8, "endWritable");
  function q8(e, t, r) {
    var i = e.entry;
    for (e.entry = null; i; ) {
      var s = i.callback;
      t.pendingcb--, s(r), i = i.next;
    }
    t.corkedRequestsFree.next = e;
  }
  n(q8, "onCorkedFinish");
  Object.defineProperty(be.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._writableState && (this._writableState.destroyed = e);
    }, "set")
  });
  be.prototype.destroy = pw.destroy;
  be.prototype._undestroy = pw.undestroy;
  be.prototype._destroy = function(e, t) {
    this.end(), t(e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_duplex.js
var br = g((JL, vw) => {
  "use strict";
  var gw = $e(), M8 = Object.keys || function(e) {
    var t = [];
    for (var r in e)
      t.push(r);
    return t;
  };
  vw.exports = Pt;
  var bw = Object.create(Oe());
  bw.inherits = ee();
  var ww = bc(), gc = mc();
  bw.inherits(Pt, ww);
  for (yc = M8(gc.prototype), Fo = 0; Fo < yc.length; Fo++)
    xo = yc[Fo], Pt.prototype[xo] || (Pt.prototype[xo] = gc.prototype[xo]);
  var yc, xo, Fo;
  function Pt(e) {
    if (!(this instanceof Pt)) return new Pt(e);
    ww.call(this, e), gc.call(this, e), e && e.readable === !1 && (this.readable = !1), e && e.writable === !1 && (this.writable = !1), this.
    allowHalfOpen = !0, e && e.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", j8);
  }
  n(Pt, "Duplex");
  Object.defineProperty(Pt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._writableState.highWaterMark;
    }, "get")
  });
  function j8() {
    this.allowHalfOpen || this._writableState.ended || gw.nextTick(I8, this);
  }
  n(j8, "onend");
  function I8(e) {
    e.end();
  }
  n(I8, "onEndNT");
  Object.defineProperty(Pt.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = e, this._writableState.destroyed =
      e);
    }, "set")
  });
  Pt.prototype._destroy = function(e, t) {
    this.push(null), this.end(), gw.nextTick(t, e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_readable.js
var bc = g((QL, Ow) => {
  "use strict";
  var li = $e();
  Ow.exports = se;
  var L8 = iw(), vn;
  se.ReadableState = Aw;
  var KL = require("events").EventEmitter, Fw = /* @__PURE__ */ n(function(e, t) {
    return e.listeners(t).length;
  }, "EElistenerCount"), Cc = fc(), _n = wo().Buffer, N8 = (typeof global < "u" ? global : typeof window < "u" ? window : typeof self < "u" ?
  self : {}).Uint8Array || function() {
  };
  function U8(e) {
    return _n.from(e);
  }
  n(U8, "_uint8ArrayToBuffer");
  function W8(e) {
    return _n.isBuffer(e) || e instanceof N8;
  }
  n(W8, "_isUint8Array");
  var xw = Object.create(Oe());
  xw.inherits = ee();
  var wc = require("util"), K = void 0;
  wc && wc.debuglog ? K = wc.debuglog("stream") : K = /* @__PURE__ */ n(function() {
  }, "debug");
  var $8 = aw(), Sw = pc(), ai;
  xw.inherits(se, Cc);
  var vc = ["error", "close", "destroy", "pause", "resume"];
  function H8(e, t, r) {
    if (typeof e.prependListener == "function") return e.prependListener(t, r);
    !e._events || !e._events[t] ? e.on(t, r) : L8(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]];
  }
  n(H8, "prependListener");
  function Aw(e, t) {
    vn = vn || br(), e = e || {};
    var r = t instanceof vn;
    this.objectMode = !!e.objectMode, r && (this.objectMode = this.objectMode || !!e.readableObjectMode);
    var i = e.highWaterMark, s = e.readableHighWaterMark, o = this.objectMode ? 16 : 16 * 1024;
    i || i === 0 ? this.highWaterMark = i : r && (s || s === 0) ? this.highWaterMark = s : this.highWaterMark = o, this.highWaterMark = Math.
    floor(this.highWaterMark), this.buffer = new $8(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended =
    !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening =
    !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore =
    !1, this.decoder = null, this.encoding = null, e.encoding && (ai || (ai = require("string_decoder/").StringDecoder), this.decoder = new ai(
    e.encoding), this.encoding = e.encoding);
  }
  n(Aw, "ReadableState");
  function se(e) {
    if (vn = vn || br(), !(this instanceof se)) return new se(e);
    this._readableState = new Aw(e, this), this.readable = !0, e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy ==
    "function" && (this._destroy = e.destroy)), Cc.call(this);
  }
  n(se, "Readable");
  Object.defineProperty(se.prototype, "destroyed", {
    get: /* @__PURE__ */ n(function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    }, "get"),
    set: /* @__PURE__ */ n(function(e) {
      this._readableState && (this._readableState.destroyed = e);
    }, "set")
  });
  se.prototype.destroy = Sw.destroy;
  se.prototype._undestroy = Sw.undestroy;
  se.prototype._destroy = function(e, t) {
    this.push(null), t(e);
  };
  se.prototype.push = function(e, t) {
    var r = this._readableState, i;
    return r.objectMode ? i = !0 : typeof e == "string" && (t = t || r.defaultEncoding, t !== r.encoding && (e = _n.from(e, t), t = ""), i =
    !0), Tw(this, e, t, !1, i);
  };
  se.prototype.unshift = function(e) {
    return Tw(this, e, null, !0, !1);
  };
  function Tw(e, t, r, i, s) {
    var o = e._readableState;
    if (t === null)
      o.reading = !1, J8(e, o);
    else {
      var u;
      s || (u = z8(o, t)), u ? e.emit("error", u) : o.objectMode || t && t.length > 0 ? (typeof t != "string" && !o.objectMode && Object.getPrototypeOf(
      t) !== _n.prototype && (t = U8(t)), i ? o.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : _c(e, o, t, !0) :
      o.ended ? e.emit("error", new Error("stream.push() after EOF")) : (o.reading = !1, o.decoder && !r ? (t = o.decoder.write(t), o.objectMode ||
      t.length !== 0 ? _c(e, o, t, !1) : Rw(e, o)) : _c(e, o, t, !1))) : i || (o.reading = !1);
    }
    return V8(o);
  }
  n(Tw, "readableAddChunk");
  function _c(e, t, r, i) {
    t.flowing && t.length === 0 && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, i ? t.buffer.unshift(
    r) : t.buffer.push(r), t.needReadable && So(e)), Rw(e, t);
  }
  n(_c, "addChunk");
  function z8(e, t) {
    var r;
    return !W8(t) && typeof t != "string" && t !== void 0 && !e.objectMode && (r = new TypeError("Invalid non-string/buffer chunk")), r;
  }
  n(z8, "chunkInvalid");
  function V8(e) {
    return !e.ended && (e.needReadable || e.length < e.highWaterMark || e.length === 0);
  }
  n(V8, "needMoreData");
  se.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  };
  se.prototype.setEncoding = function(e) {
    return ai || (ai = require("string_decoder/").StringDecoder), this._readableState.decoder = new ai(e), this._readableState.encoding = e,
    this;
  };
  var _w = 8388608;
  function G8(e) {
    return e >= _w ? e = _w : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;
  }
  n(G8, "computeNewHighWaterMark");
  function Ew(e, t) {
    return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : e !== e ? t.flowing && t.length ? t.buffer.head.data.length : t.length :
    (e > t.highWaterMark && (t.highWaterMark = G8(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));
  }
  n(Ew, "howMuchToRead");
  se.prototype.read = function(e) {
    K("read", e), e = parseInt(e, 10);
    var t = this._readableState, r = e;
    if (e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && (t.length >= t.highWaterMark || t.ended))
      return K("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? Ec(this) : So(this), null;
    if (e = Ew(e, t), e === 0 && t.ended)
      return t.length === 0 && Ec(this), null;
    var i = t.needReadable;
    K("need readable", i), (t.length === 0 || t.length - e < t.highWaterMark) && (i = !0, K("length less than watermark", i)), t.ended || t.
    reading ? (i = !1, K("reading or ended", i)) : i && (K("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0),
    this._read(t.highWaterMark), t.sync = !1, t.reading || (e = Ew(r, t)));
    var s;
    return e > 0 ? s = kw(e, t) : s = null, s === null ? (t.needReadable = !0, e = 0) : t.length -= e, t.length === 0 && (t.ended || (t.needReadable =
    !0), r !== e && t.ended && Ec(this)), s !== null && this.emit("data", s), s;
  };
  function J8(e, t) {
    if (!t.ended) {
      if (t.decoder) {
        var r = t.decoder.end();
        r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length);
      }
      t.ended = !0, So(e);
    }
  }
  n(J8, "onEofChunk");
  function So(e) {
    var t = e._readableState;
    t.needReadable = !1, t.emittedReadable || (K("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? li.nextTick(Cw, e) : Cw(e));
  }
  n(So, "emitReadable");
  function Cw(e) {
    K("emit readable"), e.emit("readable"), Fc(e);
  }
  n(Cw, "emitReadable_");
  function Rw(e, t) {
    t.readingMore || (t.readingMore = !0, li.nextTick(Y8, e, t));
  }
  n(Rw, "maybeReadMore");
  function Y8(e, t) {
    for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (K("maybeReadMore read 0"), e.read(0), r !==
    t.length); )
      r = t.length;
    t.readingMore = !1;
  }
  n(Y8, "maybeReadMore_");
  se.prototype._read = function(e) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  se.prototype.pipe = function(e, t) {
    var r = this, i = this._readableState;
    switch (i.pipesCount) {
      case 0:
        i.pipes = e;
        break;
      case 1:
        i.pipes = [i.pipes, e];
        break;
      default:
        i.pipes.push(e);
        break;
    }
    i.pipesCount += 1, K("pipe count=%d opts=%j", i.pipesCount, t);
    var s = (!t || t.end !== !1) && e !== process.stdout && e !== process.stderr, o = s ? a : y;
    i.endEmitted ? li.nextTick(o) : r.once("end", o), e.on("unpipe", u);
    function u(_, C) {
      K("onunpipe"), _ === r && C && C.hasUnpiped === !1 && (C.hasUnpiped = !0, h());
    }
    n(u, "onunpipe");
    function a() {
      K("onend"), e.end();
    }
    n(a, "onend");
    var l = K8(r);
    e.on("drain", l);
    var c = !1;
    function h() {
      K("cleanup"), e.removeListener("close", m), e.removeListener("finish", v), e.removeListener("drain", l), e.removeListener("error", f),
      e.removeListener("unpipe", u), r.removeListener("end", a), r.removeListener("end", y), r.removeListener("data", d), c = !0, i.awaitDrain &&
      (!e._writableState || e._writableState.needDrain) && l();
    }
    n(h, "cleanup");
    var p = !1;
    r.on("data", d);
    function d(_) {
      K("ondata"), p = !1;
      var C = e.write(_);
      C === !1 && !p && ((i.pipesCount === 1 && i.pipes === e || i.pipesCount > 1 && Bw(i.pipes, e) !== -1) && !c && (K("false write respons\
e, pause", i.awaitDrain), i.awaitDrain++, p = !0), r.pause());
    }
    n(d, "ondata");
    function f(_) {
      K("onerror", _), y(), e.removeListener("error", f), Fw(e, "error") === 0 && e.emit("error", _);
    }
    n(f, "onerror"), H8(e, "error", f);
    function m() {
      e.removeListener("finish", v), y();
    }
    n(m, "onclose"), e.once("close", m);
    function v() {
      K("onfinish"), e.removeListener("close", m), y();
    }
    n(v, "onfinish"), e.once("finish", v);
    function y() {
      K("unpipe"), r.unpipe(e);
    }
    return n(y, "unpipe"), e.emit("pipe", r), i.flowing || (K("pipe resume"), r.resume()), e;
  };
  function K8(e) {
    return function() {
      var t = e._readableState;
      K("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, t.awaitDrain === 0 && Fw(e, "data") && (t.flowing = !0, Fc(e));
    };
  }
  n(K8, "pipeOnDrain");
  se.prototype.unpipe = function(e) {
    var t = this._readableState, r = { hasUnpiped: !1 };
    if (t.pipesCount === 0) return this;
    if (t.pipesCount === 1)
      return e && e !== t.pipes ? this : (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r),
      this);
    if (!e) {
      var i = t.pipes, s = t.pipesCount;
      t.pipes = null, t.pipesCount = 0, t.flowing = !1;
      for (var o = 0; o < s; o++)
        i[o].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var u = Bw(t.pipes, e);
    return u === -1 ? this : (t.pipes.splice(u, 1), t.pipesCount -= 1, t.pipesCount === 1 && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r),
    this);
  };
  se.prototype.on = function(e, t) {
    var r = Cc.prototype.on.call(this, e, t);
    if (e === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (e === "readable") {
      var i = this._readableState;
      !i.endEmitted && !i.readableListening && (i.readableListening = i.needReadable = !0, i.emittedReadable = !1, i.reading ? i.length && So(
      this) : li.nextTick(Q8, this));
    }
    return r;
  };
  se.prototype.addListener = se.prototype.on;
  function Q8(e) {
    K("readable nexttick read 0"), e.read(0);
  }
  n(Q8, "nReadingNextTick");
  se.prototype.resume = function() {
    var e = this._readableState;
    return e.flowing || (K("resume"), e.flowing = !0, X8(this, e)), this;
  };
  function X8(e, t) {
    t.resumeScheduled || (t.resumeScheduled = !0, li.nextTick(Z8, e, t));
  }
  n(X8, "resume");
  function Z8(e, t) {
    t.reading || (K("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), Fc(e), t.flowing && !t.reading &&
    e.read(0);
  }
  n(Z8, "resume_");
  se.prototype.pause = function() {
    return K("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (K("pause"), this._readableState.flowing =
    !1, this.emit("pause")), this;
  };
  function Fc(e) {
    var t = e._readableState;
    for (K("flow", t.flowing); t.flowing && e.read() !== null; )
      ;
  }
  n(Fc, "flow");
  se.prototype.wrap = function(e) {
    var t = this, r = this._readableState, i = !1;
    e.on("end", function() {
      if (K("wrapped end"), r.decoder && !r.ended) {
        var u = r.decoder.end();
        u && u.length && t.push(u);
      }
      t.push(null);
    }), e.on("data", function(u) {
      if (K("wrapped data"), r.decoder && (u = r.decoder.write(u)), !(r.objectMode && u == null) && !(!r.objectMode && (!u || !u.length))) {
        var a = t.push(u);
        a || (i = !0, e.pause());
      }
    });
    for (var s in e)
      this[s] === void 0 && typeof e[s] == "function" && (this[s] = /* @__PURE__ */ function(u) {
        return function() {
          return e[u].apply(e, arguments);
        };
      }(s));
    for (var o = 0; o < vc.length; o++)
      e.on(vc[o], this.emit.bind(this, vc[o]));
    return this._read = function(u) {
      K("wrapped _read", u), i && (i = !1, e.resume());
    }, this;
  };
  Object.defineProperty(se.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: /* @__PURE__ */ n(function() {
      return this._readableState.highWaterMark;
    }, "get")
  });
  se._fromList = kw;
  function kw(e, t) {
    if (t.length === 0) return null;
    var r;
    return t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? r = t.buffer.join("") : t.buffer.length === 1 ? r = t.buffer.
    head.data : r = t.buffer.concat(t.length), t.buffer.clear()) : r = ek(e, t.buffer, t.decoder), r;
  }
  n(kw, "fromList");
  function ek(e, t, r) {
    var i;
    return e < t.head.data.length ? (i = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : e === t.head.data.length ? i = t.shift() :
    i = r ? tk(e, t) : rk(e, t), i;
  }
  n(ek, "fromListPartial");
  function tk(e, t) {
    var r = t.head, i = 1, s = r.data;
    for (e -= s.length; r = r.next; ) {
      var o = r.data, u = e > o.length ? o.length : e;
      if (u === o.length ? s += o : s += o.slice(0, e), e -= u, e === 0) {
        u === o.length ? (++i, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = o.slice(u));
        break;
      }
      ++i;
    }
    return t.length -= i, s;
  }
  n(tk, "copyFromBufferString");
  function rk(e, t) {
    var r = _n.allocUnsafe(e), i = t.head, s = 1;
    for (i.data.copy(r), e -= i.data.length; i = i.next; ) {
      var o = i.data, u = e > o.length ? o.length : e;
      if (o.copy(r, r.length - e, 0, u), e -= u, e === 0) {
        u === o.length ? (++s, i.next ? t.head = i.next : t.head = t.tail = null) : (t.head = i, i.data = o.slice(u));
        break;
      }
      ++s;
    }
    return t.length -= s, r;
  }
  n(rk, "copyFromBuffer");
  function Ec(e) {
    var t = e._readableState;
    if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    t.endEmitted || (t.ended = !0, li.nextTick(ik, t, e));
  }
  n(Ec, "endReadable");
  function ik(e, t) {
    !e.endEmitted && e.length === 0 && (e.endEmitted = !0, t.readable = !1, t.emit("end"));
  }
  n(ik, "endReadableNT");
  function Bw(e, t) {
    for (var r = 0, i = e.length; r < i; r++)
      if (e[r] === t) return r;
    return -1;
  }
  n(Bw, "indexOf");
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_transform.js
var xc = g((ZL, Mw) => {
  "use strict";
  Mw.exports = qt;
  var Ao = br(), qw = Object.create(Oe());
  qw.inherits = ee();
  qw.inherits(qt, Ao);
  function nk(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var i = r.writecb;
    if (!i)
      return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, t != null && this.push(t), i(e);
    var s = this._readableState;
    s.reading = !1, (s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
  }
  n(nk, "afterTransform");
  function qt(e) {
    if (!(this instanceof qt)) return new qt(e);
    Ao.call(this, e), this._transformState = {
      afterTransform: nk.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.
    transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", sk);
  }
  n(qt, "Transform");
  function sk() {
    var e = this;
    typeof this._flush == "function" ? this._flush(function(t, r) {
      Pw(e, t, r);
    }) : Pw(this, null, null);
  }
  n(sk, "prefinish");
  qt.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, Ao.prototype.push.call(this, e, t);
  };
  qt.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented");
  };
  qt.prototype._write = function(e, t, r) {
    var i = this._transformState;
    if (i.writecb = r, i.writechunk = e, i.writeencoding = t, !i.transforming) {
      var s = this._readableState;
      (i.needTransform || s.needReadable || s.length < s.highWaterMark) && this._read(s.highWaterMark);
    }
  };
  qt.prototype._read = function(e) {
    var t = this._transformState;
    t.writechunk !== null && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) :
    t.needTransform = !0;
  };
  qt.prototype._destroy = function(e, t) {
    var r = this;
    Ao.prototype._destroy.call(this, e, function(i) {
      t(i), r.emit("close");
    });
  };
  function Pw(e, t, r) {
    if (t) return e.emit("error", t);
    if (r != null && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null);
  }
  n(Pw, "done");
});

// ../node_modules/pumpify/node_modules/readable-stream/lib/_stream_passthrough.js
var Nw = g((t7, Lw) => {
  "use strict";
  Lw.exports = En;
  var jw = xc(), Iw = Object.create(Oe());
  Iw.inherits = ee();
  Iw.inherits(En, jw);
  function En(e) {
    if (!(this instanceof En)) return new En(e);
    jw.call(this, e);
  }
  n(En, "PassThrough");
  En.prototype._transform = function(e, t, r) {
    r(null, e);
  };
});

// ../node_modules/pumpify/node_modules/readable-stream/readable.js
var Uw = g((Ae, To) => {
  var pt = require("stream");
  process.env.READABLE_STREAM === "disable" && pt ? (To.exports = pt, Ae = To.exports = pt.Readable, Ae.Readable = pt.Readable, Ae.Writable =
  pt.Writable, Ae.Duplex = pt.Duplex, Ae.Transform = pt.Transform, Ae.PassThrough = pt.PassThrough, Ae.Stream = pt) : (Ae = To.exports = bc(),
  Ae.Stream = pt || Ae, Ae.Readable = Ae, Ae.Writable = mc(), Ae.Duplex = br(), Ae.Transform = xc(), Ae.PassThrough = Nw());
});

// ../node_modules/pumpify/node_modules/duplexify/index.js
var Vw = g((i7, zw) => {
  var Ro = Uw(), Ww = Nr(), ok = ee(), uk = $l(), $w = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from([0]) : new Buffer([0]), Sc = /* @__PURE__ */ n(
  function(e, t) {
    e._corked ? e.once("uncork", t) : t();
  }, "onuncork"), ak = /* @__PURE__ */ n(function(e, t) {
    e._autoDestroy && e.destroy(t);
  }, "autoDestroy"), Hw = /* @__PURE__ */ n(function(e, t) {
    return function(r) {
      r ? ak(e, r.message === "premature close" ? null : r) : t && !e._ended && e.end();
    };
  }, "destroyer"), lk = /* @__PURE__ */ n(function(e, t) {
    if (!e || e._writableState && e._writableState.finished) return t();
    if (e._writableState) return e.end(t);
    e.end(), t();
  }, "end"), ck = /* @__PURE__ */ n(function(e) {
    return new Ro.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(e);
  }, "toStreams2"), Te = /* @__PURE__ */ n(function(e, t, r) {
    if (!(this instanceof Te)) return new Te(e, t, r);
    Ro.Duplex.call(this, r), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !r || r.autoDestroy !==
    !1, this._forwardDestroy = !r || r.destroy !== !1, this._forwardEnd = !r || r.end !== !1, this._corked = 1, this._ondrain = null, this._drained =
    !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, e && this.setWritable(e), t &&
    this.setReadable(t);
  }, "Duplexify");
  ok(Te, Ro.Duplex);
  Te.obj = function(e, t, r) {
    return r || (r = {}), r.objectMode = !0, r.highWaterMark = 16, new Te(e, t, r);
  };
  Te.prototype.cork = function() {
    ++this._corked === 1 && this.emit("cork");
  };
  Te.prototype.uncork = function() {
    this._corked && --this._corked === 0 && this.emit("uncork");
  };
  Te.prototype.setWritable = function(e) {
    if (this._unwrite && this._unwrite(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.end();
      return;
    }
    var t = this, r = Ww(e, { writable: !0, readable: !1 }, Hw(this, this._forwardEnd)), i = /* @__PURE__ */ n(function() {
      var o = t._ondrain;
      t._ondrain = null, o && o();
    }, "ondrain"), s = /* @__PURE__ */ n(function() {
      t._writable.removeListener("drain", i), r();
    }, "clear");
    this._unwrite && process.nextTick(i), this._writable = e, this._writable.on("drain", i), this._unwrite = s, this.uncork();
  };
  Te.prototype.setReadable = function(e) {
    if (this._unread && this._unread(), this.destroyed) {
      e && e.destroy && e.destroy();
      return;
    }
    if (e === null || e === !1) {
      this.push(null), this.resume();
      return;
    }
    var t = this, r = Ww(e, { writable: !1, readable: !0 }, Hw(this)), i = /* @__PURE__ */ n(function() {
      t._forward();
    }, "onreadable"), s = /* @__PURE__ */ n(function() {
      t.push(null);
    }, "onend"), o = /* @__PURE__ */ n(function() {
      t._readable2.removeListener("readable", i), t._readable2.removeListener("end", s), r();
    }, "clear");
    this._drained = !0, this._readable = e, this._readable2 = e._readableState ? e : ck(e), this._readable2.on("readable", i), this._readable2.
    on("end", s), this._unread = o, this._forward();
  };
  Te.prototype._read = function() {
    this._drained = !0, this._forward();
  };
  Te.prototype._forward = function() {
    if (!(this._forwarding || !this._readable2 || !this._drained)) {
      this._forwarding = !0;
      for (var e; this._drained && (e = uk(this._readable2)) !== null; )
        this.destroyed || (this._drained = this.push(e));
      this._forwarding = !1;
    }
  };
  Te.prototype.destroy = function(e) {
    if (!this.destroyed) {
      this.destroyed = !0;
      var t = this;
      process.nextTick(function() {
        t._destroy(e);
      });
    }
  };
  Te.prototype._destroy = function(e) {
    if (e) {
      var t = this._ondrain;
      this._ondrain = null, t ? t(e) : this.emit("error", e);
    }
    this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy &&
    this._writable.destroy()), this.emit("close");
  };
  Te.prototype._write = function(e, t, r) {
    if (this.destroyed) return r();
    if (this._corked) return Sc(this, this._write.bind(this, e, t, r));
    if (e === $w) return this._finish(r);
    if (!this._writable) return r();
    this._writable.write(e) === !1 ? this._ondrain = r : r();
  };
  Te.prototype._finish = function(e) {
    var t = this;
    this.emit("preend"), Sc(this, function() {
      lk(t._forwardEnd && t._writable, function() {
        t._writableState.prefinished === !1 && (t._writableState.prefinished = !0), t.emit("prefinish"), Sc(t, e);
      });
    });
  };
  Te.prototype.end = function(e, t, r) {
    return typeof e == "function" ? this.end(null, null, e) : typeof t == "function" ? this.end(e, null, t) : (this._ended = !0, e && this.write(
    e), this._writableState.ending || this.write($w), Ro.Writable.prototype.end.call(this, r));
  };
  zw.exports = Te;
});

// ../node_modules/pumpify/index.js
var Yw = g((s7, ko) => {
  var fk = tw(), hk = ee(), Gw = Vw(), Jw = /* @__PURE__ */ n(function(e) {
    return e.length ? Array.isArray(e[0]) ? e[0] : Array.prototype.slice.call(e) : [];
  }, "toArray"), Ac = /* @__PURE__ */ n(function(e) {
    var t = /* @__PURE__ */ n(function() {
      var r = Jw(arguments);
      if (!(this instanceof t)) return new t(r);
      Gw.call(this, null, null, e), r.length && this.setPipeline(r);
    }, "Pumpify");
    return hk(t, Gw), t.prototype.setPipeline = function() {
      var r = Jw(arguments), i = this, s = !1, o = r[0], u = r[r.length - 1];
      u = u.readable ? u : null, o = o.writable ? o : null;
      var a = /* @__PURE__ */ n(function() {
        r[0].emit("error", new Error("stream was destroyed"));
      }, "onclose");
      if (this.on("close", a), this.on("prefinish", function() {
        s || i.cork();
      }), fk(r, function(l) {
        if (i.removeListener("close", a), l) return i.destroy(l.message === "premature close" ? null : l);
        s = !0, i._autoDestroy === !1 && (i._autoDestroy = !0), i.uncork();
      }), this.destroyed) return a();
      this.setWritable(o), this.setReadable(u);
    }, t;
  }, "define");
  ko.exports = Ac({ autoDestroy: !1, destroy: !1 });
  ko.exports.obj = Ac({ autoDestroy: !1, destroy: !1, objectMode: !0, highWaterMark: 16 });
  ko.exports.ctor = Ac;
});

// ../node_modules/is-gzip/index.js
var Qw = g((u7, Kw) => {
  "use strict";
  Kw.exports = function(e) {
    return !e || e.length < 3 ? !1 : e[0] === 31 && e[1] === 139 && e[2] === 8;
  };
});

// ../node_modules/is-deflate/index.js
var Zw = g((a7, Xw) => {
  "use strict";
  Xw.exports = function(e) {
    return !e || e.length < 2 ? !1 : e[0] === 120 && (e[1] === 1 || e[1] === 156 || e[1] === 218);
  };
});

// ../node_modules/gunzip-maybe/index.js
var iv = g((l7, rv) => {
  var ev = require("zlib"), dk = X0(), pk = ac(), tv = Yw(), Dk = Qw(), mk = Zw(), yk = /* @__PURE__ */ n(function(e) {
    return Dk(e) ? 1 : mk(e) ? 2 : 0;
  }, "isCompressed"), Tc = /* @__PURE__ */ n(function(e) {
    return e === void 0 && (e = 3), dk({ newline: !1, maxBuffer: 10 }, function(t, r) {
      if (e < 0) return r(new Error("Maximum recursion reached"));
      switch (yk(t)) {
        case 1:
          r(null, tv(ev.createGunzip(), Tc(e - 1)));
          break;
        case 2:
          r(null, tv(ev.createInflate(), Tc(e - 1)));
          break;
        default:
          r(null, pk());
      }
    });
  }, "gunzip");
  rv.exports = Tc;
});

// ../node_modules/@ndelangen/get-tarball/dist/index.js
var Xv = g((d7, Qv) => {
  "use strict";
  var gk = Object.create, Wo = Object.defineProperty, bk = Object.getOwnPropertyDescriptor, Av = Object.getOwnPropertyNames, wk = Object.getPrototypeOf,
  vk = Object.prototype.hasOwnProperty, V = /* @__PURE__ */ n((e, t) => /* @__PURE__ */ n(function() {
    return t || (0, e[Av(e)[0]])((t = { exports: {} }).exports, t), t.exports;
  }, "__require"), "__commonJS"), _k = /* @__PURE__ */ n((e, t) => {
    for (var r in t)
      Wo(e, r, { get: t[r], enumerable: !0 });
  }, "__export"), Tv = /* @__PURE__ */ n((e, t, r, i) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let s of Av(t))
        !vk.call(e, s) && s !== r && Wo(e, s, { get: /* @__PURE__ */ n(() => t[s], "get"), enumerable: !(i = bk(t, s)) || i.enumerable });
    return e;
  }, "__copyProps"), we = /* @__PURE__ */ n((e, t, r) => (r = e != null ? gk(wk(e)) : {}, Tv(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    t || !e || !e.__esModule ? Wo(r, "default", { value: e, enumerable: !0 }) : r,
    e
  )), "__toESM"), Ek = /* @__PURE__ */ n((e) => Tv(Wo({}, "__esModule", { value: !0 }), e), "__toCommonJS"), Ck = V({
    "node_modules/.pnpm/defer-to-connect@2.0.1/node_modules/defer-to-connect/dist/source/index.js"(e, t) {
      "use strict";
      Object.defineProperty(e, "__esModule", { value: !0 });
      function r(s) {
        return s.encrypted;
      }
      n(r, "isTLSSocket");
      var i = /* @__PURE__ */ n((s, o) => {
        let u;
        typeof o == "function" ? u = { connect: o } : u = o;
        let a = typeof u.connect == "function", l = typeof u.secureConnect == "function", c = typeof u.close == "function", h = /* @__PURE__ */ n(
        () => {
          a && u.connect(), r(s) && l && (s.authorized ? u.secureConnect() : s.authorizationError || s.once("secureConnect", u.secureConnect)),
          c && s.once("close", u.close);
        }, "onConnect");
        s.writable && !s.connecting ? h() : s.connecting ? s.once("connect", h) : s.destroyed && c && u.close(s._hadError);
      }, "deferToConnect2");
      e.default = i, t.exports = i, t.exports.default = i;
    }
  }), Fk = V({
    "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(e, t) {
      "use strict";
      var { PassThrough: r } = require("stream");
      t.exports = (i) => {
        i = { ...i };
        let { array: s } = i, { encoding: o } = i, u = o === "buffer", a = !1;
        s ? a = !(o || u) : o = o || "utf8", u && (o = null);
        let l = new r({ objectMode: a });
        o && l.setEncoding(o);
        let c = 0, h = [];
        return l.on("data", (p) => {
          h.push(p), a ? c = h.length : c += p.length;
        }), l.getBufferedValue = () => s ? h : u ? Buffer.concat(h, c) : h.join(""), l.getBufferedLength = () => c, l;
      };
    }
  }), Rv = V({
    "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(e, t) {
      "use strict";
      var { constants: r } = require("buffer"), i = require("stream"), { promisify: s } = require("util"), o = Fk(), u = s(i.pipeline), a = class extends Error {
        static {
          n(this, "MaxBufferError");
        }
        constructor() {
          super("maxBuffer exceeded"), this.name = "MaxBufferError";
        }
      };
      async function l(c, h) {
        if (!c)
          throw new Error("Expected a stream");
        h = {
          maxBuffer: 1 / 0,
          ...h
        };
        let { maxBuffer: p } = h, d = o(h);
        return await new Promise((f, m) => {
          let v = /* @__PURE__ */ n((y) => {
            y && d.getBufferedLength() <= r.MAX_LENGTH && (y.bufferedData = d.getBufferedValue()), m(y);
          }, "rejectPromise");
          (async () => {
            try {
              await u(c, d), f();
            } catch (y) {
              v(y);
            }
          })(), d.on("data", () => {
            d.getBufferedLength() > p && v(new a());
          });
        }), d.getBufferedValue();
      }
      n(l, "getStream2"), t.exports = l, t.exports.buffer = (c, h) => l(c, { ...h, encoding: "buffer" }), t.exports.array = (c, h) => l(c, {
      ...h, array: !0 }), t.exports.MaxBufferError = a;
    }
  }), xk = V({
    "node_modules/.pnpm/http-cache-semantics@4.1.1/node_modules/http-cache-semantics/index.js"(e, t) {
      "use strict";
      var r = /* @__PURE__ */ new Set([
        200,
        203,
        204,
        206,
        300,
        301,
        308,
        404,
        405,
        410,
        414,
        501
      ]), i = /* @__PURE__ */ new Set([
        200,
        203,
        204,
        300,
        301,
        302,
        303,
        307,
        308,
        404,
        405,
        410,
        414,
        501
      ]), s = /* @__PURE__ */ new Set([
        500,
        502,
        503,
        504
      ]), o = {
        date: !0,
        // included, because we add Age update Date
        connection: !0,
        "keep-alive": !0,
        "proxy-authenticate": !0,
        "proxy-authorization": !0,
        te: !0,
        trailer: !0,
        "transfer-encoding": !0,
        upgrade: !0
      }, u = {
        // Since the old body is reused, it doesn't make sense to change properties of the body
        "content-length": !0,
        "content-encoding": !0,
        "transfer-encoding": !0,
        "content-range": !0
      };
      function a(p) {
        let d = parseInt(p, 10);
        return isFinite(d) ? d : 0;
      }
      n(a, "toNumberOrZero");
      function l(p) {
        return p ? s.has(p.status) : !0;
      }
      n(l, "isErrorResponse");
      function c(p) {
        let d = {};
        if (!p)
          return d;
        let f = p.trim().split(/,/);
        for (let m of f) {
          let [v, y] = m.split(/=/, 2);
          d[v.trim()] = y === void 0 ? !0 : y.trim().replace(/^"|"$/g, "");
        }
        return d;
      }
      n(c, "parseCacheControl");
      function h(p) {
        let d = [];
        for (let f in p) {
          let m = p[f];
          d.push(m === !0 ? f : f + "=" + m);
        }
        if (d.length)
          return d.join(", ");
      }
      n(h, "formatCacheControl"), t.exports = class {
        static {
          n(this, "CachePolicy");
        }
        constructor(d, f, {
          shared: m,
          cacheHeuristic: v,
          immutableMinTimeToLive: y,
          ignoreCargoCult: _,
          _fromObject: C
        } = {}) {
          if (C) {
            this._fromObject(C);
            return;
          }
          if (!f || !f.headers)
            throw Error("Response headers missing");
          this._assertRequestHasHeaders(d), this._responseTime = this.now(), this._isShared = m !== !1, this._cacheHeuristic = v !== void 0 ?
          v : 0.1, this._immutableMinTtl = y !== void 0 ? y : 24 * 3600 * 1e3, this._status = "status" in f ? f.status : 200, this._resHeaders =
          f.headers, this._rescc = c(f.headers["cache-control"]), this._method = "method" in d ? d.method : "GET", this._url = d.url, this._host =
          d.headers.host, this._noAuthorization = !d.headers.authorization, this._reqHeaders = f.headers.vary ? d.headers : null, this._reqcc =
          c(d.headers["cache-control"]), _ && "pre-check" in this._rescc && "post-check" in this._rescc && (delete this._rescc["pre-check"],
          delete this._rescc["post-check"], delete this._rescc["no-cache"], delete this._rescc["no-store"], delete this._rescc["must-revalid\
ate"], this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": h(this._rescc)
          }), delete this._resHeaders.expires, delete this._resHeaders.pragma), f.headers["cache-control"] == null && /no-cache/.test(f.headers.
          pragma) && (this._rescc["no-cache"] = !0);
        }
        now() {
          return Date.now();
        }
        storable() {
          return !!(!this._reqcc["no-store"] && // A cache MUST NOT store a response to any request, unless:
          // The request method is understood by the cache and defined as being cacheable, and
          (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && // the response status code is understood by the cache, and
          i.has(this._status) && // the "no-store" cache directive does not appear in request or response header fields, and
          !this._rescc["no-store"] && // the "private" response directive does not appear in the response, if the cache is shared, and
          (!this._isShared || !this._rescc.private) && // the Authorization header field does not appear in the request, if the cache is shared,
          (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && // the response either:
          // contains an Expires header field, or
          (this._resHeaders.expires || // contains a max-age response directive, or
          // contains a s-maxage response directive and the cache is shared, or
          // contains a public response directive.
          this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || // has a status code that is defined as cacheable by default
          r.has(this._status)));
        }
        _hasExplicitExpiration() {
          return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
        }
        _assertRequestHasHeaders(d) {
          if (!d || !d.headers)
            throw Error("Request headers missing");
        }
        satisfiesWithoutRevalidation(d) {
          this._assertRequestHasHeaders(d);
          let f = c(d.headers["cache-control"]);
          return f["no-cache"] || /no-cache/.test(d.headers.pragma) || f["max-age"] && this.age() > f["max-age"] || f["min-fresh"] && this.timeToLive() <
          1e3 * f["min-fresh"] || this.stale() && !(f["max-stale"] && !this._rescc["must-revalidate"] && (f["max-stale"] === !0 || f["max-st\
ale"] > this.age() - this.maxAge())) ? !1 : this._requestMatches(d, !1);
        }
        _requestMatches(d, f) {
          return (!this._url || this._url === d.url) && this._host === d.headers.host && // the request method associated with the stored response allows it to be used for the presented request, and
          (!d.method || this._method === d.method || f && d.method === "HEAD") && // selecting header fields nominated by the stored response (if any) match those presented, and
          this._varyMatches(d);
        }
        _allowsStoringAuthenticated() {
          return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
        }
        _varyMatches(d) {
          if (!this._resHeaders.vary)
            return !0;
          if (this._resHeaders.vary === "*")
            return !1;
          let f = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
          for (let m of f)
            if (d.headers[m] !== this._reqHeaders[m])
              return !1;
          return !0;
        }
        _copyWithoutHopByHopHeaders(d) {
          let f = {};
          for (let m in d)
            o[m] || (f[m] = d[m]);
          if (d.connection) {
            let m = d.connection.trim().split(/\s*,\s*/);
            for (let v of m)
              delete f[v];
          }
          if (f.warning) {
            let m = f.warning.split(/,/).filter((v) => !/^\s*1[0-9][0-9]/.test(v));
            m.length ? f.warning = m.join(",").trim() : delete f.warning;
          }
          return f;
        }
        responseHeaders() {
          let d = this._copyWithoutHopByHopHeaders(this._resHeaders), f = this.age();
          return f > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24 && (d.warning = (d.warning ? `${d.warning}, ` :
          "") + '113 - "rfc7234 5.5.4"'), d.age = `${Math.round(f)}`, d.date = new Date(this.now()).toUTCString(), d;
        }
        /**
         * Value of the Date response header or current time if Date was invalid
         * @return timestamp
         */
        date() {
          let d = Date.parse(this._resHeaders.date);
          return isFinite(d) ? d : this._responseTime;
        }
        /**
         * Value of the Age header, in seconds, updated for the current time.
         * May be fractional.
         *
         * @return Number
         */
        age() {
          let d = this._ageValue(), f = (this.now() - this._responseTime) / 1e3;
          return d + f;
        }
        _ageValue() {
          return a(this._resHeaders.age);
        }
        /**
         * Value of applicable max-age (or heuristic equivalent) in seconds. This counts since response's `Date`.
         *
         * For an up-to-date value, see `timeToLive()`.
         *
         * @return Number
         */
        maxAge() {
          if (!this.storable() || this._rescc["no-cache"] || this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this.
          _rescc.immutable || this._resHeaders.vary === "*")
            return 0;
          if (this._isShared) {
            if (this._rescc["proxy-revalidate"])
              return 0;
            if (this._rescc["s-maxage"])
              return a(this._rescc["s-maxage"]);
          }
          if (this._rescc["max-age"])
            return a(this._rescc["max-age"]);
          let d = this._rescc.immutable ? this._immutableMinTtl : 0, f = this.date();
          if (this._resHeaders.expires) {
            let m = Date.parse(this._resHeaders.expires);
            return Number.isNaN(m) || m < f ? 0 : Math.max(d, (m - f) / 1e3);
          }
          if (this._resHeaders["last-modified"]) {
            let m = Date.parse(this._resHeaders["last-modified"]);
            if (isFinite(m) && f > m)
              return Math.max(
                d,
                (f - m) / 1e3 * this._cacheHeuristic
              );
          }
          return d;
        }
        timeToLive() {
          let d = this.maxAge() - this.age(), f = d + a(this._rescc["stale-if-error"]), m = d + a(this._rescc["stale-while-revalidate"]);
          return Math.max(0, d, f, m) * 1e3;
        }
        stale() {
          return this.maxAge() <= this.age();
        }
        _useStaleIfError() {
          return this.maxAge() + a(this._rescc["stale-if-error"]) > this.age();
        }
        useStaleWhileRevalidate() {
          return this.maxAge() + a(this._rescc["stale-while-revalidate"]) > this.age();
        }
        static fromObject(d) {
          return new this(void 0, void 0, { _fromObject: d });
        }
        _fromObject(d) {
          if (this._responseTime)
            throw Error("Reinitialized");
          if (!d || d.v !== 1)
            throw Error("Invalid serialization");
          this._responseTime = d.t, this._isShared = d.sh, this._cacheHeuristic = d.ch, this._immutableMinTtl = d.imm !== void 0 ? d.imm : 24 *
          3600 * 1e3, this._status = d.st, this._resHeaders = d.resh, this._rescc = d.rescc, this._method = d.m, this._url = d.u, this._host =
          d.h, this._noAuthorization = d.a, this._reqHeaders = d.reqh, this._reqcc = d.reqcc;
        }
        toObject() {
          return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc
          };
        }
        /**
         * Headers for sending to the origin server to revalidate stale response.
         * Allows server to return 304 to allow reuse of the previous response.
         *
         * Hop by hop headers are always stripped.
         * Revalidation headers may be added or removed, depending on request.
         */
        revalidationHeaders(d) {
          this._assertRequestHasHeaders(d);
          let f = this._copyWithoutHopByHopHeaders(d.headers);
          if (delete f["if-range"], !this._requestMatches(d, !0) || !this.storable())
            return delete f["if-none-match"], delete f["if-modified-since"], f;
          if (this._resHeaders.etag && (f["if-none-match"] = f["if-none-match"] ? `${f["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.
          etag), f["accept-ranges"] || f["if-match"] || f["if-unmodified-since"] || this._method && this._method != "GET") {
            if (delete f["if-modified-since"], f["if-none-match"]) {
              let v = f["if-none-match"].split(/,/).filter((y) => !/^\s*W\//.test(y));
              v.length ? f["if-none-match"] = v.join(",").trim() : delete f["if-none-match"];
            }
          } else this._resHeaders["last-modified"] && !f["if-modified-since"] && (f["if-modified-since"] = this._resHeaders["last-modified"]);
          return f;
        }
        /**
         * Creates new CachePolicy with information combined from the previews response,
         * and the new revalidation response.
         *
         * Returns {policy, modified} where modified is a boolean indicating
         * whether the response body has been modified, and old cached body can't be used.
         *
         * @return {Object} {policy: CachePolicy, modified: Boolean}
         */
        revalidatedPolicy(d, f) {
          if (this._assertRequestHasHeaders(d), this._useStaleIfError() && l(f))
            return {
              modified: !1,
              matches: !1,
              policy: this
            };
          if (!f || !f.headers)
            throw Error("Response headers missing");
          let m = !1;
          if (f.status !== void 0 && f.status != 304 ? m = !1 : f.headers.etag && !/^\s*W\//.test(f.headers.etag) ? m = this._resHeaders.etag &&
          this._resHeaders.etag.replace(/^\s*W\//, "") === f.headers.etag : this._resHeaders.etag && f.headers.etag ? m = this._resHeaders.etag.
          replace(/^\s*W\//, "") === f.headers.etag.replace(/^\s*W\//, "") : this._resHeaders["last-modified"] ? m = this._resHeaders["last-\
modified"] === f.headers["last-modified"] : !this._resHeaders.etag && !this._resHeaders["last-modified"] && !f.headers.etag && !f.headers["l\
ast-modified"] && (m = !0), !m)
            return {
              policy: new this.constructor(d, f),
              // Client receiving 304 without body, even if it's invalid/mismatched has no option
              // but to reuse a cached body. We don't have a good way to tell clients to do
              // error recovery in such case.
              modified: f.status != 304,
              matches: !1
            };
          let v = {};
          for (let _ in this._resHeaders)
            v[_] = _ in f.headers && !u[_] ? f.headers[_] : this._resHeaders[_];
          let y = Object.assign({}, f, {
            status: this._status,
            method: this._method,
            headers: v
          });
          return {
            policy: new this.constructor(d, y, {
              shared: this._isShared,
              cacheHeuristic: this._cacheHeuristic,
              immutableMinTimeToLive: this._immutableMinTtl
            }),
            modified: !1,
            matches: !0
          };
        }
      };
    }
  }), Sk = V({
    "node_modules/.pnpm/json-buffer@3.0.1/node_modules/json-buffer/index.js"(e) {
      e.stringify = /* @__PURE__ */ n(function t(r) {
        if (typeof r > "u")
          return r;
        if (r && Buffer.isBuffer(r))
          return JSON.stringify(":base64:" + r.toString("base64"));
        if (r && r.toJSON && (r = r.toJSON()), r && typeof r == "object") {
          var i = "", s = Array.isArray(r);
          i = s ? "[" : "{";
          var o = !0;
          for (var u in r) {
            var a = typeof r[u] == "function" || !s && typeof r[u] > "u";
            Object.hasOwnProperty.call(r, u) && !a && (o || (i += ","), o = !1, s ? r[u] == null ? i += "null" : i += t(r[u]) : r[u] !== void 0 &&
            (i += t(u) + ":" + t(r[u])));
          }
          return i += s ? "]" : "}", i;
        } else return typeof r == "string" ? JSON.stringify(/^:/.test(r) ? ":" + r : r) : typeof r > "u" ? "null" : JSON.stringify(r);
      }, "stringify"), e.parse = function(t) {
        return JSON.parse(t, function(r, i) {
          return typeof i == "string" ? /^:base64:/.test(i) ? Buffer.from(i.substring(8), "base64") : /^:/.test(i) ? i.substring(1) : i : i;
        });
      };
    }
  }), Ak = V({
    "node_modules/.pnpm/keyv@4.5.2/node_modules/keyv/src/index.js"(e, t) {
      "use strict";
      var r = require("events"), i = Sk(), s = /* @__PURE__ */ n((a) => {
        let l = {
          redis: "@keyv/redis",
          rediss: "@keyv/redis",
          mongodb: "@keyv/mongo",
          mongo: "@keyv/mongo",
          sqlite: "@keyv/sqlite",
          postgresql: "@keyv/postgres",
          postgres: "@keyv/postgres",
          mysql: "@keyv/mysql",
          etcd: "@keyv/etcd",
          offline: "@keyv/offline",
          tiered: "@keyv/tiered"
        };
        if (a.adapter || a.uri) {
          let c = a.adapter || /^[^:+]*/.exec(a.uri)[0];
          return new (require(l[c]))(a);
        }
        return /* @__PURE__ */ new Map();
      }, "loadStore"), o = [
        "sqlite",
        "postgres",
        "mysql",
        "mongo",
        "redis",
        "tiered"
      ], u = class extends r {
        static {
          n(this, "Keyv2");
        }
        constructor(a, { emitErrors: l = !0, ...c } = {}) {
          if (super(), this.opts = {
            namespace: "keyv",
            serialize: i.stringify,
            deserialize: i.parse,
            ...typeof a == "string" ? { uri: a } : a,
            ...c
          }, !this.opts.store) {
            let p = { ...this.opts };
            this.opts.store = s(p);
          }
          if (this.opts.compression) {
            let p = this.opts.compression;
            this.opts.serialize = p.serialize.bind(p), this.opts.deserialize = p.deserialize.bind(p);
          }
          typeof this.opts.store.on == "function" && l && this.opts.store.on("error", (p) => this.emit("error", p)), this.opts.store.namespace =
          this.opts.namespace;
          let h = /* @__PURE__ */ n((p) => async function* () {
            for await (let [d, f] of typeof p == "function" ? p(this.opts.store.namespace) : p) {
              let m = this.opts.deserialize(f);
              if (!(this.opts.store.namespace && !d.includes(this.opts.store.namespace))) {
                if (typeof m.expires == "number" && Date.now() > m.expires) {
                  this.delete(d);
                  continue;
                }
                yield [this._getKeyUnprefix(d), m.value];
              }
            }
          }, "generateIterator");
          typeof this.opts.store[Symbol.iterator] == "function" && this.opts.store instanceof Map ? this.iterator = h(this.opts.store) : typeof this.
          opts.store.iterator == "function" && this.opts.store.opts && this._checkIterableAdaptar() && (this.iterator = h(this.opts.store.iterator.
          bind(this.opts.store)));
        }
        _checkIterableAdaptar() {
          return o.includes(this.opts.store.opts.dialect) || o.findIndex((a) => this.opts.store.opts.url.includes(a)) >= 0;
        }
        _getKeyPrefix(a) {
          return `${this.opts.namespace}:${a}`;
        }
        _getKeyPrefixArray(a) {
          return a.map((l) => `${this.opts.namespace}:${l}`);
        }
        _getKeyUnprefix(a) {
          return a.split(":").splice(1).join(":");
        }
        get(a, l) {
          let { store: c } = this.opts, h = Array.isArray(a), p = h ? this._getKeyPrefixArray(a) : this._getKeyPrefix(a);
          if (h && c.getMany === void 0) {
            let d = [];
            for (let f of p)
              d.push(
                Promise.resolve().then(() => c.get(f)).then((m) => typeof m == "string" ? this.opts.deserialize(m) : this.opts.compression ?
                this.opts.deserialize(m) : m).then((m) => {
                  if (m != null)
                    return typeof m.expires == "number" && Date.now() > m.expires ? this.delete(f).then(() => {
                    }) : l && l.raw ? m : m.value;
                })
              );
            return Promise.allSettled(d).then((f) => {
              let m = [];
              for (let v of f)
                m.push(v.value);
              return m;
            });
          }
          return Promise.resolve().then(() => h ? c.getMany(p) : c.get(p)).then((d) => typeof d == "string" ? this.opts.deserialize(d) : this.
          opts.compression ? this.opts.deserialize(d) : d).then((d) => {
            if (d != null) {
              if (h) {
                let f = [];
                for (let m of d) {
                  if (typeof m == "string" && (m = this.opts.deserialize(m)), m == null) {
                    f.push(void 0);
                    continue;
                  }
                  typeof m.expires == "number" && Date.now() > m.expires ? (this.delete(a).then(() => {
                  }), f.push(void 0)) : f.push(l && l.raw ? m : m.value);
                }
                return f;
              }
              return typeof d.expires == "number" && Date.now() > d.expires ? this.delete(a).then(() => {
              }) : l && l.raw ? d : d.value;
            }
          });
        }
        set(a, l, c) {
          let h = this._getKeyPrefix(a);
          typeof c > "u" && (c = this.opts.ttl), c === 0 && (c = void 0);
          let { store: p } = this.opts;
          return Promise.resolve().then(() => {
            let d = typeof c == "number" ? Date.now() + c : null;
            return typeof l == "symbol" && this.emit("error", "symbol cannot be serialized"), l = { value: l, expires: d }, this.opts.serialize(
            l);
          }).then((d) => p.set(h, d, c)).then(() => !0);
        }
        delete(a) {
          let { store: l } = this.opts;
          if (Array.isArray(a)) {
            let h = this._getKeyPrefixArray(a);
            if (l.deleteMany === void 0) {
              let p = [];
              for (let d of h)
                p.push(l.delete(d));
              return Promise.allSettled(p).then((d) => d.every((f) => f.value === !0));
            }
            return Promise.resolve().then(() => l.deleteMany(h));
          }
          let c = this._getKeyPrefix(a);
          return Promise.resolve().then(() => l.delete(c));
        }
        clear() {
          let { store: a } = this.opts;
          return Promise.resolve().then(() => a.clear());
        }
        has(a) {
          let l = this._getKeyPrefix(a), { store: c } = this.opts;
          return Promise.resolve().then(async () => typeof c.has == "function" ? c.has(l) : await c.get(l) !== void 0);
        }
        disconnect() {
          let { store: a } = this.opts;
          if (typeof a.disconnect == "function")
            return a.disconnect();
        }
      };
      t.exports = u;
    }
  }), Tk = V({
    "node_modules/.pnpm/mimic-response@3.1.0/node_modules/mimic-response/index.js"(e, t) {
      "use strict";
      var r = [
        "aborted",
        "complete",
        "headers",
        "httpVersion",
        "httpVersionMinor",
        "httpVersionMajor",
        "method",
        "rawHeaders",
        "rawTrailers",
        "setTimeout",
        "socket",
        "statusCode",
        "statusMessage",
        "trailers",
        "url"
      ];
      t.exports = (i, s) => {
        if (s._readableState.autoDestroy)
          throw new Error("The second stream must have the `autoDestroy` option set to `false`");
        let o = new Set(Object.keys(i).concat(r)), u = {};
        for (let a of o)
          a in s || (u[a] = {
            get() {
              let l = i[a];
              return typeof l == "function" ? l.bind(i) : l;
            },
            set(l) {
              i[a] = l;
            },
            enumerable: !0,
            configurable: !1
          });
        return Object.defineProperties(s, u), i.once("aborted", () => {
          s.destroy(), s.emit("aborted");
        }), i.once("close", () => {
          i.complete && s.readable ? s.once("end", () => {
            s.emit("close");
          }) : s.emit("close");
        }), s;
      };
    }
  }), Rk = V({
    "node_modules/.pnpm/decompress-response@6.0.0/node_modules/decompress-response/index.js"(e, t) {
      "use strict";
      var { Transform: r, PassThrough: i } = require("stream"), s = require("zlib"), o = Tk();
      t.exports = (u) => {
        let a = (u.headers["content-encoding"] || "").toLowerCase();
        if (!["gzip", "deflate", "br"].includes(a))
          return u;
        let l = a === "br";
        if (l && typeof s.createBrotliDecompress != "function")
          return u.destroy(new Error("Brotli is not supported on Node.js < 12")), u;
        let c = !0, h = new r({
          transform(f, m, v) {
            c = !1, v(null, f);
          },
          flush(f) {
            f();
          }
        }), p = new i({
          autoDestroy: !1,
          destroy(f, m) {
            u.destroy(), m(f);
          }
        }), d = l ? s.createBrotliDecompress() : s.createUnzip();
        return d.once("error", (f) => {
          if (c && !u.readable) {
            p.end();
            return;
          }
          p.destroy(f);
        }), o(u, p), u.pipe(h).pipe(d).pipe(p), p;
      };
    }
  }), kv = V({
    "node_modules/.pnpm/quick-lru@5.1.1/node_modules/quick-lru/index.js"(e, t) {
      "use strict";
      var r = class {
        static {
          n(this, "QuickLRU");
        }
        constructor(i = {}) {
          if (!(i.maxSize && i.maxSize > 0))
            throw new TypeError("`maxSize` must be a number greater than 0");
          this.maxSize = i.maxSize, this.onEviction = i.onEviction, this.cache = /* @__PURE__ */ new Map(), this.oldCache = /* @__PURE__ */ new Map(),
          this._size = 0;
        }
        _set(i, s) {
          if (this.cache.set(i, s), this._size++, this._size >= this.maxSize) {
            if (this._size = 0, typeof this.onEviction == "function")
              for (let [o, u] of this.oldCache.entries())
                this.onEviction(o, u);
            this.oldCache = this.cache, this.cache = /* @__PURE__ */ new Map();
          }
        }
        get(i) {
          if (this.cache.has(i))
            return this.cache.get(i);
          if (this.oldCache.has(i)) {
            let s = this.oldCache.get(i);
            return this.oldCache.delete(i), this._set(i, s), s;
          }
        }
        set(i, s) {
          return this.cache.has(i) ? this.cache.set(i, s) : this._set(i, s), this;
        }
        has(i) {
          return this.cache.has(i) || this.oldCache.has(i);
        }
        peek(i) {
          if (this.cache.has(i))
            return this.cache.get(i);
          if (this.oldCache.has(i))
            return this.oldCache.get(i);
        }
        delete(i) {
          let s = this.cache.delete(i);
          return s && this._size--, this.oldCache.delete(i) || s;
        }
        clear() {
          this.cache.clear(), this.oldCache.clear(), this._size = 0;
        }
        *keys() {
          for (let [i] of this)
            yield i;
        }
        *values() {
          for (let [, i] of this)
            yield i;
        }
        *[Symbol.iterator]() {
          for (let i of this.cache)
            yield i;
          for (let i of this.oldCache) {
            let [s] = i;
            this.cache.has(s) || (yield i);
          }
        }
        get size() {
          let i = 0;
          for (let s of this.oldCache.keys())
            this.cache.has(s) || i++;
          return Math.min(this._size + i, this.maxSize);
        }
      };
      t.exports = r;
    }
  }), Bv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/delay-async-destroy.js"(e, t) {
      "use strict";
      t.exports = (r) => {
        if (r.listenerCount("error") !== 0)
          return r;
        r.__destroy = r._destroy, r._destroy = (...s) => {
          let o = s.pop();
          r.__destroy(...s, async (u) => {
            await Promise.resolve(), o(u);
          });
        };
        let i = /* @__PURE__ */ n((s) => {
          Promise.resolve().then(() => {
            r.emit("error", s);
          });
        }, "onError");
        return r.once("error", i), Promise.resolve().then(() => {
          r.off("error", i);
        }), r;
      };
    }
  }), hi = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/agent.js"(e, t) {
      "use strict";
      var { URL: r } = require("url"), i = require("events"), s = require("tls"), o = require("http2"), u = kv(), a = Bv(), l = Symbol("curr\
entStreamCount"), c = Symbol("request"), h = Symbol("cachedOriginSet"), p = Symbol("gracefullyClosing"), d = Symbol("length"), f = [
        // Not an Agent option actually
        "createConnection",
        // `http2.connect()` options
        "maxDeflateDynamicTableSize",
        "maxSettings",
        "maxSessionMemory",
        "maxHeaderListPairs",
        "maxOutstandingPings",
        "maxReservedRemoteStreams",
        "maxSendHeaderBlockLength",
        "paddingStrategy",
        "peerMaxConcurrentStreams",
        "settings",
        // `tls.connect()` source options
        "family",
        "localAddress",
        "rejectUnauthorized",
        // `tls.connect()` secure context options
        "pskCallback",
        "minDHSize",
        // `tls.connect()` destination options
        // - `servername` is automatically validated, skip it
        // - `host` and `port` just describe the destination server,
        "path",
        "socket",
        // `tls.createSecureContext()` options
        "ca",
        "cert",
        "sigalgs",
        "ciphers",
        "clientCertEngine",
        "crl",
        "dhparam",
        "ecdhCurve",
        "honorCipherOrder",
        "key",
        "privateKeyEngine",
        "privateKeyIdentifier",
        "maxVersion",
        "minVersion",
        "pfx",
        "secureOptions",
        "secureProtocol",
        "sessionIdContext",
        "ticketKeys"
      ], m = /* @__PURE__ */ n((E, x, A) => {
        let O = 0, j = E.length;
        for (; O < j; ) {
          let F = O + j >>> 1;
          A(E[F], x) ? O = F + 1 : j = F;
        }
        return O;
      }, "getSortedIndex"), v = /* @__PURE__ */ n((E, x) => E.remoteSettings.maxConcurrentStreams > x.remoteSettings.maxConcurrentStreams, "\
compareSessions"), y = /* @__PURE__ */ n((E, x) => {
        for (let A = 0; A < E.length; A++) {
          let O = E[A];
          // Unfortunately `.every()` returns true for an empty array
          O[h].length > 0 && O[h].length < x[h].length && O[h].every((j) => x[h].includes(j)) && O[l] + x[l] <= x.remoteSettings.maxConcurrentStreams &&
          C(O);
        }
      }, "closeCoveredSessions"), _ = /* @__PURE__ */ n((E, x) => {
        for (let A = 0; A < E.length; A++) {
          let O = E[A];
          if (x[h].length > 0 && x[h].length < O[h].length && x[h].every((j) => O[h].includes(j)) && x[l] + O[l] <= O.remoteSettings.maxConcurrentStreams)
            return C(x), !0;
        }
        return !1;
      }, "closeSessionIfCovered"), C = /* @__PURE__ */ n((E) => {
        E[p] = !0, E[l] === 0 && E.close();
      }, "gracefullyClose"), w = class extends i {
        static {
          n(this, "Agent");
        }
        constructor({ timeout: E = 0, maxSessions: x = Number.POSITIVE_INFINITY, maxEmptySessions: A = 10, maxCachedTlsSessions: O = 100 } = {}) {
          super(), this.sessions = {}, this.queue = {}, this.timeout = E, this.maxSessions = x, this.maxEmptySessions = A, this._emptySessionCount =
          0, this._sessionCount = 0, this.settings = {
            enablePush: !1,
            initialWindowSize: 1024 * 1024 * 32
            // 32MB, see https://github.com/nodejs/node/issues/38426
          }, this.tlsSessionCache = new u({ maxSize: O });
        }
        get protocol() {
          return "https:";
        }
        normalizeOptions(E) {
          let x = "";
          for (let A = 0; A < f.length; A++) {
            let O = f[A];
            x += ":", E && E[O] !== void 0 && (x += E[O]);
          }
          return x;
        }
        _processQueue() {
          if (this._sessionCount >= this.maxSessions) {
            this.closeEmptySessions(this.maxSessions - this._sessionCount + 1);
            return;
          }
          for (let E in this.queue)
            for (let x in this.queue[E]) {
              let A = this.queue[E][x];
              A.completed || (A.completed = !0, A());
            }
        }
        _isBetterSession(E, x) {
          return E > x;
        }
        _accept(E, x, A, O) {
          let j = 0;
          for (; j < x.length && E[l] < E.remoteSettings.maxConcurrentStreams; )
            x[j].resolve(E), j++;
          x.splice(0, j), x.length > 0 && (this.getSession(A, O, x), x.length = 0);
        }
        getSession(E, x, A) {
          return new Promise((O, j) => {
            Array.isArray(A) && A.length > 0 ? (A = [...A], O()) : A = [{ resolve: O, reject: j }];
            try {
              if (typeof E == "string")
                E = new r(E);
              else if (!(E instanceof r))
                throw new TypeError("The `origin` argument needs to be a string or an URL object");
              if (x) {
                let { servername: B } = x, { hostname: T } = E;
                if (B && T !== B)
                  throw new Error(`Origin ${T} differs from servername ${B}`);
              }
            } catch (B) {
              for (let T = 0; T < A.length; T++)
                A[T].reject(B);
              return;
            }
            let F = this.normalizeOptions(x), P = E.origin;
            if (F in this.sessions) {
              let B = this.sessions[F], T = -1, q = -1, L;
              for (let I = 0; I < B.length; I++) {
                let R = B[I], N = R.remoteSettings.maxConcurrentStreams;
                if (N < T)
                  break;
                if (!R[h].includes(P))
                  continue;
                let $ = R[l];
                $ >= N || R[p] || R.destroyed || (L || (T = N), this._isBetterSession($, q) && (L = R, q = $));
              }
              if (L) {
                this._accept(L, A, P, x);
                return;
              }
            }
            if (F in this.queue) {
              if (P in this.queue[F]) {
                this.queue[F][P].listeners.push(...A);
                return;
              }
            } else
              this.queue[F] = {
                [d]: 0
              };
            let M = /* @__PURE__ */ n(() => {
              F in this.queue && this.queue[F][P] === U && (delete this.queue[F][P], --this.queue[F][d] === 0 && delete this.queue[F]);
            }, "removeFromQueue"), U = /* @__PURE__ */ n(async () => {
              this._sessionCount++;
              let B = `${P}:${F}`, T = !1, q;
              try {
                let L = { ...x };
                L.settings === void 0 && (L.settings = this.settings), L.session === void 0 && (L.session = this.tlsSessionCache.get(B)), q =
                await (L.createConnection || this.createConnection).call(this, E, L), L.createConnection = () => q;
                let R = o.connect(E, L);
                R[l] = 0, R[p] = !1;
                let N = /* @__PURE__ */ n(() => {
                  let { socket: H } = R, re;
                  return H.servername === !1 ? (H.servername = H.remoteAddress, re = R.originSet, H.servername = !1) : re = R.originSet, re;
                }, "getOriginSet"), $ = /* @__PURE__ */ n(() => R[l] < R.remoteSettings.maxConcurrentStreams, "isFree");
                R.socket.once("session", (H) => {
                  this.tlsSessionCache.set(B, H);
                }), R.once("error", (H) => {
                  for (let re = 0; re < A.length; re++)
                    A[re].reject(H);
                  this.tlsSessionCache.delete(B);
                }), R.setTimeout(this.timeout, () => {
                  R.destroy();
                }), R.once("close", () => {
                  if (this._sessionCount--, T) {
                    this._emptySessionCount--;
                    let H = this.sessions[F];
                    H.length === 1 ? delete this.sessions[F] : H.splice(H.indexOf(R), 1);
                  } else {
                    M();
                    let H = new Error("Session closed without receiving a SETTINGS frame");
                    H.code = "HTTP2WRAPPER_NOSETTINGS";
                    for (let re = 0; re < A.length; re++)
                      A[re].reject(H);
                  }
                  this._processQueue();
                });
                let gi = /* @__PURE__ */ n(() => {
                  let H = this.queue[F];
                  if (!H)
                    return;
                  let re = R[h];
                  for (let rt = 0; rt < re.length; rt++) {
                    let bi = re[rt];
                    if (bi in H) {
                      let { listeners: Af, completed: wE } = H[bi], Wn = 0;
                      for (; Wn < Af.length && $(); )
                        Af[Wn].resolve(R), Wn++;
                      if (H[bi].listeners.splice(0, Wn), H[bi].listeners.length === 0 && !wE && (delete H[bi], --H[d] === 0)) {
                        delete this.queue[F];
                        break;
                      }
                      if (!$())
                        break;
                    }
                  }
                }, "processListeners");
                R.on("origin", () => {
                  R[h] = N() || [], R[p] = !1, _(this.sessions[F], R), !(R[p] || !$()) && (gi(), $() && y(this.sessions[F], R));
                }), R.once("remoteSettings", () => {
                  if (U.destroyed) {
                    let H = new Error("Agent has been destroyed");
                    for (let re = 0; re < A.length; re++)
                      A[re].reject(H);
                    R.destroy();
                    return;
                  }
                  if (R.setLocalWindowSize && R.setLocalWindowSize(1024 * 1024 * 4), R[h] = N() || [], R.socket.encrypted) {
                    let H = R[h][0];
                    if (H !== P) {
                      let re = new Error(`Requested origin ${P} does not match server ${H}`);
                      for (let rt = 0; rt < A.length; rt++)
                        A[rt].reject(re);
                      R.destroy();
                      return;
                    }
                  }
                  M();
                  {
                    let H = this.sessions;
                    if (F in H) {
                      let re = H[F];
                      re.splice(m(re, R, v), 0, R);
                    } else
                      H[F] = [R];
                  }
                  T = !0, this._emptySessionCount++, this.emit("session", R), this._accept(R, A, P, x), R[l] === 0 && this._emptySessionCount >
                  this.maxEmptySessions && this.closeEmptySessions(this._emptySessionCount - this.maxEmptySessions), R.on("remoteSettings", () => {
                    $() && (gi(), $() && y(this.sessions[F], R));
                  });
                }), R[c] = R.request, R.request = (H, re) => {
                  if (R[p])
                    throw new Error("The session is gracefully closing. No new streams are allowed.");
                  let rt = R[c](H, re);
                  return R.ref(), R[l]++ === 0 && this._emptySessionCount--, rt.once("close", () => {
                    if (--R[l] === 0 && (this._emptySessionCount++, R.unref(), this._emptySessionCount > this.maxEmptySessions || R[p])) {
                      R.close();
                      return;
                    }
                    R.destroyed || R.closed || $() && !_(this.sessions[F], R) && (y(this.sessions[F], R), gi(), R[l] === 0 && this._processQueue());
                  }), rt;
                };
              } catch (L) {
                M(), this._sessionCount--;
                for (let I = 0; I < A.length; I++)
                  A[I].reject(L);
              }
            }, "entry");
            U.listeners = A, U.completed = !1, U.destroyed = !1, this.queue[F][P] = U, this.queue[F][d]++, this._processQueue();
          });
        }
        request(E, x, A, O) {
          return new Promise((j, F) => {
            this.getSession(E, x, [{
              reject: F,
              resolve: /* @__PURE__ */ n((P) => {
                try {
                  let M = P.request(A, O);
                  a(M), j(M);
                } catch (M) {
                  F(M);
                }
              }, "resolve")
            }]);
          });
        }
        async createConnection(E, x) {
          return w.connect(E, x);
        }
        static connect(E, x) {
          x.ALPNProtocols = ["h2"];
          let A = E.port || 443, O = E.hostname;
          typeof x.servername > "u" && (x.servername = O);
          let j = s.connect(A, O, x);
          return x.socket && (j._peername = {
            family: void 0,
            address: void 0,
            port: A
          }), j;
        }
        closeEmptySessions(E = Number.POSITIVE_INFINITY) {
          let x = 0, { sessions: A } = this;
          for (let O in A) {
            let j = A[O];
            for (let F = 0; F < j.length; F++) {
              let P = j[F];
              if (P[l] === 0 && (x++, P.close(), x >= E))
                return x;
            }
          }
          return x;
        }
        destroy(E) {
          let { sessions: x, queue: A } = this;
          for (let O in x) {
            let j = x[O];
            for (let F = 0; F < j.length; F++)
              j[F].destroy(E);
          }
          for (let O in A) {
            let j = A[O];
            for (let F in j)
              j[F].destroyed = !0;
          }
          this.queue = {}, this.tlsSessionCache.clear();
        }
        get emptySessionCount() {
          return this._emptySessionCount;
        }
        get pendingSessionCount() {
          return this._sessionCount - this._emptySessionCount;
        }
        get sessionCount() {
          return this._sessionCount;
        }
      };
      w.kCurrentStreamCount = l, w.kGracefullyClosing = p, t.exports = {
        Agent: w,
        globalAgent: new w()
      };
    }
  }), Ov = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/incoming-message.js"(e, t) {
      "use strict";
      var { Readable: r } = require("stream"), i = class extends r {
        static {
          n(this, "IncomingMessage");
        }
        constructor(s, o) {
          super({
            emitClose: !1,
            autoDestroy: !0,
            highWaterMark: o
          }), this.statusCode = null, this.statusMessage = "", this.httpVersion = "2.0", this.httpVersionMajor = 2, this.httpVersionMinor = 0,
          this.headers = {}, this.trailers = {}, this.req = null, this.aborted = !1, this.complete = !1, this.upgrade = null, this.rawHeaders =
          [], this.rawTrailers = [], this.socket = s, this._dumped = !1;
        }
        get connection() {
          return this.socket;
        }
        set connection(s) {
          this.socket = s;
        }
        _destroy(s, o) {
          this.readableEnded || (this.aborted = !0), o(), this.req._request.destroy(s);
        }
        setTimeout(s, o) {
          return this.req.setTimeout(s, o), this;
        }
        _dump() {
          this._dumped || (this._dumped = !0, this.removeAllListeners("data"), this.resume());
        }
        _read() {
          this.req && this.req._request.resume();
        }
      };
      t.exports = i;
    }
  }), kk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/proxy-events.js"(e, t) {
      "use strict";
      t.exports = (r, i, s) => {
        for (let o of s)
          r.on(o, (...u) => i.emit(o, ...u));
      };
    }
  }), $o = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/errors.js"(e, t) {
      "use strict";
      var r = /* @__PURE__ */ n((i, s, o) => {
        t.exports[s] = class extends i {
          static {
            n(this, "NodeError");
          }
          constructor(...a) {
            super(typeof o == "string" ? o : o(a)), this.name = `${super.name} [${s}]`, this.code = s;
          }
        };
      }, "makeError");
      r(TypeError, "ERR_INVALID_ARG_TYPE", (i) => {
        let s = i[0].includes(".") ? "property" : "argument", o = i[1], u = Array.isArray(o);
        return u && (o = `${o.slice(0, -1).join(", ")} or ${o.slice(-1)}`), `The "${i[0]}" ${s} must be ${u ? "one of" : "of"} type ${o}. Re\
ceived ${typeof i[2]}`;
      }), r(
        TypeError,
        "ERR_INVALID_PROTOCOL",
        (i) => `Protocol "${i[0]}" not supported. Expected "${i[1]}"`
      ), r(
        Error,
        "ERR_HTTP_HEADERS_SENT",
        (i) => `Cannot ${i[0]} headers after they are sent to the client`
      ), r(
        TypeError,
        "ERR_INVALID_HTTP_TOKEN",
        (i) => `${i[0]} must be a valid HTTP token [${i[1]}]`
      ), r(
        TypeError,
        "ERR_HTTP_INVALID_HEADER_VALUE",
        (i) => `Invalid value "${i[0]} for header "${i[1]}"`
      ), r(
        TypeError,
        "ERR_INVALID_CHAR",
        (i) => `Invalid character in ${i[0]} [${i[1]}]`
      ), r(
        Error,
        "ERR_HTTP2_NO_SOCKET_MANIPULATION",
        "HTTP/2 sockets should not be directly manipulated (e.g. read and written)"
      );
    }
  }), Bk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js"(e, t) {
      "use strict";
      t.exports = (r) => {
        switch (r) {
          case ":method":
          case ":scheme":
          case ":authority":
          case ":path":
            return !0;
          default:
            return !1;
        }
      };
    }
  }), Pv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/validate-header-name.js"(e, t) {
      "use strict";
      var { ERR_INVALID_HTTP_TOKEN: r } = $o(), i = Bk(), s = /^[\^`\-\w!#$%&*+.|~]+$/;
      t.exports = (o) => {
        if (typeof o != "string" || !s.test(o) && !i(o))
          throw new r("Header name", o);
      };
    }
  }), qv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/validate-header-value.js"(e, t) {
      "use strict";
      var {
        ERR_HTTP_INVALID_HEADER_VALUE: r,
        ERR_INVALID_CHAR: i
      } = $o(), s = /[^\t\u0020-\u007E\u0080-\u00FF]/;
      t.exports = (o, u) => {
        if (typeof u > "u")
          throw new r(u, o);
        if (s.test(u))
          throw new i("header content", o);
      };
    }
  }), Ok = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/proxy-socket-handler.js"(e, t) {
      "use strict";
      var { ERR_HTTP2_NO_SOCKET_MANIPULATION: r } = $o(), i = {
        has(s, o) {
          let u = s.session === void 0 ? s : s.session.socket;
          return o in s || o in u;
        },
        get(s, o) {
          switch (o) {
            case "on":
            case "once":
            case "end":
            case "emit":
            case "destroy":
              return s[o].bind(s);
            case "writable":
            case "destroyed":
              return s[o];
            case "readable":
              return s.destroyed ? !1 : s.readable;
            case "setTimeout": {
              let { session: u } = s;
              return u !== void 0 ? u.setTimeout.bind(u) : s.setTimeout.bind(s);
            }
            case "write":
            case "read":
            case "pause":
            case "resume":
              throw new r();
            default: {
              let u = s.session === void 0 ? s : s.session.socket, a = u[o];
              return typeof a == "function" ? a.bind(u) : a;
            }
          }
        },
        getPrototypeOf(s) {
          return s.session !== void 0 ? Reflect.getPrototypeOf(s.session.socket) : Reflect.getPrototypeOf(s);
        },
        set(s, o, u) {
          switch (o) {
            case "writable":
            case "readable":
            case "destroyed":
            case "on":
            case "once":
            case "end":
            case "emit":
            case "destroy":
              return s[o] = u, !0;
            case "setTimeout": {
              let { session: a } = s;
              return a === void 0 ? s.setTimeout = u : a.setTimeout = u, !0;
            }
            case "write":
            case "read":
            case "pause":
            case "resume":
              throw new r();
            default: {
              let a = s.session === void 0 ? s : s.session.socket;
              return a[o] = u, !0;
            }
          }
        }
      };
      t.exports = i;
    }
  }), Mv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/client-request.js"(e, t) {
      "use strict";
      var { URL: r, urlToHttpOptions: i } = require("url"), s = require("http2"), { Writable: o } = require("stream"), { Agent: u, globalAgent: a } = hi(),
      l = Ov(), c = kk(), {
        ERR_INVALID_ARG_TYPE: h,
        ERR_INVALID_PROTOCOL: p,
        ERR_HTTP_HEADERS_SENT: d
      } = $o(), f = Pv(), m = qv(), v = Ok(), {
        HTTP2_HEADER_STATUS: y,
        HTTP2_HEADER_METHOD: _,
        HTTP2_HEADER_PATH: C,
        HTTP2_HEADER_AUTHORITY: w,
        HTTP2_METHOD_CONNECT: E
      } = s.constants, x = Symbol("headers"), A = Symbol("origin"), O = Symbol("session"), j = Symbol("options"), F = Symbol("flushedHeaders"),
      P = Symbol("jobs"), M = Symbol("pendingAgentPromise"), U = class extends o {
        static {
          n(this, "ClientRequest");
        }
        constructor(B, T, q) {
          if (super({
            autoDestroy: !1,
            emitClose: !1
          }), typeof B == "string" ? B = i(new r(B)) : B instanceof r ? B = i(B) : B = { ...B }, typeof T == "function" || T === void 0 ? (q =
          T, T = B) : T = Object.assign(B, T), T.h2session) {
            if (this[O] = T.h2session, this[O].destroyed)
              throw new Error("The session has been closed already");
            this.protocol = this[O].socket.encrypted ? "https:" : "http:";
          } else if (T.agent === !1)
            this.agent = new u({ maxEmptySessions: 0 });
          else if (typeof T.agent > "u" || T.agent === null)
            this.agent = a;
          else if (typeof T.agent.request == "function")
            this.agent = T.agent;
          else
            throw new h("options.agent", ["http2wrapper.Agent-like Object", "undefined", "false"], T.agent);
          if (this.agent && (this.protocol = this.agent.protocol), T.protocol && T.protocol !== this.protocol)
            throw new p(T.protocol, this.protocol);
          T.port || (T.port = T.defaultPort || this.agent && this.agent.defaultPort || 443), T.host = T.hostname || T.host || "localhost", delete T.
          hostname;
          let { timeout: L } = T;
          T.timeout = void 0, this[x] = /* @__PURE__ */ Object.create(null), this[P] = [], this[M] = void 0, this.socket = null, this.connection =
          null, this.method = T.method || "GET", this.method === "CONNECT" && (T.path === "/" || T.path === void 0) || (this.path = T.path),
          this.res = null, this.aborted = !1, this.reusedSocket = !1;
          let { headers: I } = T;
          if (I)
            for (let N in I)
              this.setHeader(N, I[N]);
          T.auth && !("authorization" in this[x]) && (this[x].authorization = "Basic " + Buffer.from(T.auth).toString("base64")), T.session =
          T.tlsSession, T.path = T.socketPath, this[j] = T, this[A] = new r(`${this.protocol}//${T.servername || T.host}:${T.port}`);
          let R = T._reuseSocket;
          R && (T.createConnection = (...N) => R.destroyed ? this.agent.createConnection(...N) : R, this.agent.getSession(this[A], this[j]).
          catch(() => {
          })), L && this.setTimeout(L), q && this.once("response", q), this[F] = !1;
        }
        get method() {
          return this[x][_];
        }
        set method(B) {
          B && (this[x][_] = B.toUpperCase());
        }
        get path() {
          let B = this.method === "CONNECT" ? w : C;
          return this[x][B];
        }
        set path(B) {
          if (B) {
            let T = this.method === "CONNECT" ? w : C;
            this[x][T] = B;
          }
        }
        get host() {
          return this[A].hostname;
        }
        set host(B) {
        }
        get _mustNotHaveABody() {
          return this.method === "GET" || this.method === "HEAD" || this.method === "DELETE";
        }
        _write(B, T, q) {
          if (this._mustNotHaveABody) {
            q(new Error("The GET, HEAD and DELETE methods must NOT have a body"));
            return;
          }
          this.flushHeaders();
          let L = /* @__PURE__ */ n(() => this._request.write(B, T, q), "callWrite");
          this._request ? L() : this[P].push(L);
        }
        _final(B) {
          this.flushHeaders();
          let T = /* @__PURE__ */ n(() => {
            if (this._mustNotHaveABody || this.method === "CONNECT") {
              B();
              return;
            }
            this._request.end(B);
          }, "callEnd");
          this._request ? T() : this[P].push(T);
        }
        abort() {
          this.res && this.res.complete || (this.aborted || process.nextTick(() => this.emit("abort")), this.aborted = !0, this.destroy());
        }
        async _destroy(B, T) {
          this.res && this.res._dump(), this._request ? this._request.destroy() : process.nextTick(() => {
            this.emit("close");
          });
          try {
            await this[M];
          } catch (q) {
            this.aborted && (B = q);
          }
          T(B);
        }
        async flushHeaders() {
          if (this[F] || this.destroyed)
            return;
          this[F] = !0;
          let B = this.method === E, T = /* @__PURE__ */ n((q) => {
            if (this._request = q, this.destroyed) {
              q.destroy();
              return;
            }
            B || c(q, this, ["timeout", "continue"]), q.once("error", (I) => {
              this.destroy(I);
            }), q.once("aborted", () => {
              let { res: I } = this;
              I ? (I.aborted = !0, I.emit("aborted"), I.destroy()) : this.destroy(new Error("The server aborted the HTTP/2 stream"));
            });
            let L = /* @__PURE__ */ n((I, R, N) => {
              let $ = new l(this.socket, q.readableHighWaterMark);
              this.res = $, $.url = `${this[A].origin}${this.path}`, $.req = this, $.statusCode = I[y], $.headers = I, $.rawHeaders = N, $.once(
              "end", () => {
                $.complete = !0, $.socket = null, $.connection = null;
              }), B ? ($.upgrade = !0, this.emit("connect", $, q, Buffer.alloc(0)) ? this.emit("close") : q.destroy()) : (q.on("data", (gi) => {
                !$._dumped && !$.push(gi) && q.pause();
              }), q.once("end", () => {
                this.aborted || $.push(null);
              }), this.emit("response", $) || $._dump());
            }, "onResponse");
            q.once("response", L), q.once("headers", (I) => this.emit("information", { statusCode: I[y] })), q.once("trailers", (I, R, N) => {
              let { res: $ } = this;
              if ($ === null) {
                L(I, R, N);
                return;
              }
              $.trailers = I, $.rawTrailers = N;
            }), q.once("close", () => {
              let { aborted: I, res: R } = this;
              if (R) {
                I && (R.aborted = !0, R.emit("aborted"), R.destroy());
                let N = /* @__PURE__ */ n(() => {
                  R.emit("close"), this.destroy(), this.emit("close");
                }, "finish");
                R.readable ? R.once("end", N) : N();
                return;
              }
              if (!this.destroyed) {
                this.destroy(new Error("The HTTP/2 stream has been early terminated")), this.emit("close");
                return;
              }
              this.destroy(), this.emit("close");
            }), this.socket = new Proxy(q, v);
            for (let I of this[P])
              I();
            this[P].length = 0, this.emit("socket", this.socket);
          }, "onStream");
          if (!(w in this[x]) && !B && (this[x][w] = this[A].host), this[O])
            try {
              T(this[O].request(this[x]));
            } catch (q) {
              this.destroy(q);
            }
          else {
            this.reusedSocket = !0;
            try {
              let q = this.agent.request(this[A], this[j], this[x]);
              this[M] = q, T(await q), this[M] = !1;
            } catch (q) {
              this[M] = !1, this.destroy(q);
            }
          }
        }
        get connection() {
          return this.socket;
        }
        set connection(B) {
          this.socket = B;
        }
        getHeaderNames() {
          return Object.keys(this[x]);
        }
        hasHeader(B) {
          if (typeof B != "string")
            throw new h("name", "string", B);
          return !!this[x][B.toLowerCase()];
        }
        getHeader(B) {
          if (typeof B != "string")
            throw new h("name", "string", B);
          return this[x][B.toLowerCase()];
        }
        get headersSent() {
          return this[F];
        }
        removeHeader(B) {
          if (typeof B != "string")
            throw new h("name", "string", B);
          if (this.headersSent)
            throw new d("remove");
          delete this[x][B.toLowerCase()];
        }
        setHeader(B, T) {
          if (this.headersSent)
            throw new d("set");
          f(B), m(B, T);
          let q = B.toLowerCase();
          if (q === "connection") {
            if (T.toLowerCase() === "keep-alive")
              return;
            throw new Error(`Invalid 'connection' header: ${T}`);
          }
          q === "host" && this.method === "CONNECT" ? this[x][w] = T : this[x][q] = T;
        }
        setNoDelay() {
        }
        setSocketKeepAlive() {
        }
        setTimeout(B, T) {
          let q = /* @__PURE__ */ n(() => this._request.setTimeout(B, T), "applyTimeout");
          return this._request ? q() : this[P].push(q), this;
        }
        get maxHeadersCount() {
          if (!this.destroyed && this._request)
            return this._request.session.localSettings.maxHeaderListSize;
        }
        set maxHeadersCount(B) {
        }
      };
      t.exports = U;
    }
  }), Pk = V({
    "node_modules/.pnpm/resolve-alpn@1.2.1/node_modules/resolve-alpn/index.js"(e, t) {
      "use strict";
      var r = require("tls");
      t.exports = (i = {}, s = r.connect) => new Promise((o, u) => {
        let a = !1, l, c = /* @__PURE__ */ n(async () => {
          await p, l.off("timeout", h), l.off("error", u), i.resolveSocket ? (o({ alpnProtocol: l.alpnProtocol, socket: l, timeout: a }), a &&
          (await Promise.resolve(), l.emit("timeout"))) : (l.destroy(), o({ alpnProtocol: l.alpnProtocol, timeout: a }));
        }, "callback"), h = /* @__PURE__ */ n(async () => {
          a = !0, c();
        }, "onTimeout"), p = (async () => {
          try {
            l = await s(i, c), l.on("error", u), l.once("timeout", h);
          } catch (d) {
            u(d);
          }
        })();
      });
    }
  }), qk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/calculate-server-name.js"(e, t) {
      "use strict";
      var { isIP: r } = require("net"), i = require("assert"), s = /* @__PURE__ */ n((o) => {
        if (o[0] === "[") {
          let a = o.indexOf("]");
          return i(a !== -1), o.slice(1, a);
        }
        let u = o.indexOf(":");
        return u === -1 ? o : o.slice(0, u);
      }, "getHost");
      t.exports = (o) => {
        let u = s(o);
        return r(u) ? "" : u;
      };
    }
  }), Mk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/auto.js"(e, t) {
      "use strict";
      var { URL: r, urlToHttpOptions: i } = require("url"), s = require("http"), o = require("https"), u = Pk(), a = kv(), { Agent: l, globalAgent: c } = hi(),
      h = Mv(), p = qk(), d = Bv(), f = new a({ maxSize: 100 }), m = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ n((C, w, E) => {
        w._httpMessage = { shouldKeepAlive: !0 };
        let x = /* @__PURE__ */ n(() => {
          C.emit("free", w, E);
        }, "onFree");
        w.on("free", x);
        let A = /* @__PURE__ */ n(() => {
          C.removeSocket(w, E);
        }, "onClose");
        w.on("close", A);
        let O = /* @__PURE__ */ n(() => {
          let { freeSockets: F } = C;
          for (let P of Object.values(F))
            if (P.includes(w)) {
              w.destroy();
              return;
            }
        }, "onTimeout");
        w.on("timeout", O);
        let j = /* @__PURE__ */ n(() => {
          C.removeSocket(w, E), w.off("close", A), w.off("free", x), w.off("timeout", O), w.off("agentRemove", j);
        }, "onRemove");
        w.on("agentRemove", j), C.emit("free", w, E);
      }, "installSocket"), y = /* @__PURE__ */ n((C, w = /* @__PURE__ */ new Map(), E = void 0) => async (x) => {
        let A = `${x.host}:${x.port}:${x.ALPNProtocols.sort()}`;
        if (!C.has(A)) {
          if (w.has(A))
            return { alpnProtocol: (await w.get(A)).alpnProtocol };
          let { path: O } = x;
          x.path = x.socketPath;
          let j = u(x, E);
          w.set(A, j);
          try {
            let F = await j;
            return C.set(A, F.alpnProtocol), w.delete(A), x.path = O, F;
          } catch (F) {
            throw w.delete(A), x.path = O, F;
          }
        }
        return { alpnProtocol: C.get(A) };
      }, "createResolveProtocol"), _ = y(f, m);
      t.exports = async (C, w, E) => {
        if (typeof C == "string" ? C = i(new r(C)) : C instanceof r ? C = i(C) : C = { ...C }, typeof w == "function" || w === void 0 ? (E =
        w, w = C) : w = Object.assign(C, w), w.ALPNProtocols = w.ALPNProtocols || ["h2", "http/1.1"], !Array.isArray(w.ALPNProtocols) || w.ALPNProtocols.
        length === 0)
          throw new Error("The `ALPNProtocols` option must be an Array with at least one entry");
        w.protocol = w.protocol || "https:";
        let x = w.protocol === "https:";
        w.host = w.hostname || w.host || "localhost", w.session = w.tlsSession, w.servername = w.servername || p(w.headers && w.headers.host ||
        w.host), w.port = w.port || (x ? 443 : 80), w._defaultAgent = x ? o.globalAgent : s.globalAgent;
        let A = w.resolveProtocol || _, { agent: O } = w;
        if (O !== void 0 && O !== !1 && O.constructor.name !== "Object")
          throw new Error("The `options.agent` can be only an object `http`, `https` or `http2` properties");
        if (x) {
          w.resolveSocket = !0;
          let { socket: j, alpnProtocol: F, timeout: P } = await A(w);
          if (P) {
            j && j.destroy();
            let U = new Error(`Timed out resolving ALPN: ${w.timeout} ms`);
            throw U.code = "ETIMEDOUT", U.ms = w.timeout, U;
          }
          j && w.createConnection && (j.destroy(), j = void 0), delete w.resolveSocket;
          let M = F === "h2";
          if (O && (O = M ? O.http2 : O.https, w.agent = O), O === void 0 && (O = M ? c : o.globalAgent), j)
            if (O === !1)
              j.destroy();
            else {
              let U = (M ? l : o.Agent).prototype.createConnection;
              O.createConnection === U ? M ? w._reuseSocket = j : v(O, j, w) : j.destroy();
            }
          if (M)
            return d(new h(w, E));
        } else O && (w.agent = O.http);
        return d(s.request(w, E));
      }, t.exports.protocolCache = f, t.exports.resolveProtocol = _, t.exports.createResolveProtocol = y;
    }
  }), jv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/js-stream-socket.js"(e, t) {
      "use strict";
      var r = require("stream"), i = require("tls"), s = new i.TLSSocket(new r.PassThrough())._handle._parentWrap.constructor;
      t.exports = s;
    }
  }), Iv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/unexpected-status-code-error.js"(e, t) {
      "use strict";
      var r = class extends Error {
        static {
          n(this, "UnexpectedStatusCodeError");
        }
        constructor(i, s = "") {
          super(`The proxy server rejected the request with status code ${i} (${s || "empty status message"})`), this.statusCode = i, this.statusMessage =
          s;
        }
      };
      t.exports = r;
    }
  }), jk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/utils/check-type.js"(e, t) {
      "use strict";
      var r = /* @__PURE__ */ n((i, s, o) => {
        if (!o.some((a) => typeof a === "string" ? typeof s === a : s instanceof a)) {
          let a = o.map((l) => typeof l == "string" ? l : l.name);
          throw new TypeError(`Expected '${i}' to be a type of ${a.join(" or ")}, got ${typeof s}`);
        }
      }, "checkType");
      t.exports = r;
    }
  }), Lv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/initialize.js"(e, t) {
      "use strict";
      var { URL: r } = require("url"), i = jk();
      t.exports = (s, o) => {
        i("proxyOptions", o, ["object"]), i("proxyOptions.headers", o.headers, ["object", "undefined"]), i("proxyOptions.raw", o.raw, ["bool\
ean", "undefined"]), i("proxyOptions.url", o.url, [r, "string"]);
        let u = new r(o.url);
        s.proxyOptions = {
          raw: !0,
          ...o,
          headers: { ...o.headers },
          url: u
        };
      };
    }
  }), Uc = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/get-auth-headers.js"(e, t) {
      "use strict";
      t.exports = (r) => {
        let { username: i, password: s } = r.proxyOptions.url;
        if (i || s) {
          let o = `${i}:${s}`, u = `Basic ${Buffer.from(o).toString("base64")}`;
          return {
            "proxy-authorization": u,
            authorization: u
          };
        }
        return {};
      };
    }
  }), Ik = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h1-over-h2.js"(e, t) {
      "use strict";
      var r = require("tls"), i = require("http"), s = require("https"), o = jv(), { globalAgent: u } = hi(), a = Iv(), l = Lv(), c = Uc(), h = /* @__PURE__ */ n(
      (f, m, v) => {
        (async () => {
          try {
            let { proxyOptions: y } = f, { url: _, headers: C, raw: w } = y, E = await u.request(_, y, {
              ...c(f),
              ...C,
              ":method": "CONNECT",
              ":authority": `${m.host}:${m.port}`
            });
            E.once("error", v), E.once("response", (x) => {
              let A = x[":status"];
              if (A !== 200) {
                v(new a(A, ""));
                return;
              }
              let O = f instanceof s.Agent;
              if (w && O) {
                m.socket = E;
                let F = r.connect(m);
                F.once("close", () => {
                  E.destroy();
                }), v(null, F);
                return;
              }
              let j = new o(E);
              j.encrypted = !1, j._handle.getpeername = (F) => {
                F.family = void 0, F.address = void 0, F.port = void 0;
              }, v(null, j);
            });
          } catch (y) {
            v(y);
          }
        })();
      }, "createConnection"), p = class extends i.Agent {
        static {
          n(this, "HttpOverHttp2");
        }
        constructor(f) {
          super(f), l(this, f.proxyOptions);
        }
        createConnection(f, m) {
          h(this, f, m);
        }
      }, d = class extends s.Agent {
        static {
          n(this, "HttpsOverHttp2");
        }
        constructor(f) {
          super(f), l(this, f.proxyOptions);
        }
        createConnection(f, m) {
          h(this, f, m);
        }
      };
      t.exports = {
        HttpOverHttp2: p,
        HttpsOverHttp2: d
      };
    }
  }), Nv = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h2-over-hx.js"(e, t) {
      "use strict";
      var { Agent: r } = hi(), i = jv(), s = Iv(), o = Lv(), u = class extends r {
        static {
          n(this, "Http2OverHttpX");
        }
        constructor(a) {
          super(a), o(this, a.proxyOptions);
        }
        async createConnection(a, l) {
          let c = `${a.hostname}:${a.port || 443}`, [h, p, d] = await this._getProxyStream(c);
          if (p !== 200)
            throw new s(p, d);
          if (this.proxyOptions.raw)
            l.socket = h;
          else {
            let f = new i(h);
            return f.encrypted = !1, f._handle.getpeername = (m) => {
              m.family = void 0, m.address = void 0, m.port = void 0;
            }, f;
          }
          return super.createConnection(a, l);
        }
      };
      t.exports = u;
    }
  }), Lk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h2-over-h2.js"(e, t) {
      "use strict";
      var { globalAgent: r } = hi(), i = Nv(), s = Uc(), o = /* @__PURE__ */ n((a) => new Promise((l, c) => {
        a.once("error", c), a.once("response", (h) => {
          a.off("error", c), l(h[":status"]);
        });
      }), "getStatusCode"), u = class extends i {
        static {
          n(this, "Http2OverHttp2");
        }
        async _getProxyStream(a) {
          let { proxyOptions: l } = this, c = {
            ...s(this),
            ...l.headers,
            ":method": "CONNECT",
            ":authority": a
          }, h = await r.request(l.url, l, c), p = await o(h);
          return [h, p, ""];
        }
      };
      t.exports = u;
    }
  }), Nk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/proxies/h2-over-h1.js"(e, t) {
      "use strict";
      var r = require("http"), i = require("https"), s = Nv(), o = Uc(), u = /* @__PURE__ */ n((l) => new Promise((c, h) => {
        let p = /* @__PURE__ */ n((d, f, m) => {
          f.unshift(m), l.off("error", h), c([f, d.statusCode, d.statusMessage]);
        }, "onConnect");
        l.once("error", h), l.once("connect", p);
      }), "getStream2"), a = class extends s {
        static {
          n(this, "Http2OverHttp");
        }
        async _getProxyStream(l) {
          let { proxyOptions: c } = this, { url: h, headers: p } = this.proxyOptions, f = (h.protocol === "https:" ? i : r).request({
            ...c,
            hostname: h.hostname,
            port: h.port,
            path: l,
            headers: {
              ...o(this),
              ...p,
              host: l
            },
            method: "CONNECT"
          }).end();
          return u(f);
        }
      };
      t.exports = {
        Http2OverHttp: a,
        Http2OverHttps: a
      };
    }
  }), Uk = V({
    "node_modules/.pnpm/http2-wrapper@2.2.0/node_modules/http2-wrapper/source/index.js"(e, t) {
      "use strict";
      var r = require("http2"), {
        Agent: i,
        globalAgent: s
      } = hi(), o = Mv(), u = Ov(), a = Mk(), {
        HttpOverHttp2: l,
        HttpsOverHttp2: c
      } = Ik(), h = Lk(), {
        Http2OverHttp: p,
        Http2OverHttps: d
      } = Nk(), f = Pv(), m = qv(), v = /* @__PURE__ */ n((_, C, w) => new o(_, C, w), "request"), y = /* @__PURE__ */ n((_, C, w) => {
        let E = new o(_, C, w);
        return E.end(), E;
      }, "get");
      t.exports = {
        ...r,
        ClientRequest: o,
        IncomingMessage: u,
        Agent: i,
        globalAgent: s,
        request: v,
        get: y,
        auto: a,
        proxies: {
          HttpOverHttp2: l,
          HttpsOverHttp2: c,
          Http2OverHttp2: h,
          Http2OverHttp: p,
          Http2OverHttps: d
        },
        validateHeaderName: f,
        validateHeaderValue: m
      };
    }
  }), Uv = {};
  _k(Uv, {
    default: /* @__PURE__ */ n(() => WO, "default")
  });
  Qv.exports = Ek(Uv);
  var Wk = require("http"), $k = require("https"), Wv = [
    "Int8Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Int16Array",
    "Uint16Array",
    "Int32Array",
    "Uint32Array",
    "Float32Array",
    "Float64Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  function Hk(e) {
    return Wv.includes(e);
  }
  n(Hk, "isTypedArrayName");
  var zk = [
    "Function",
    "Generator",
    "AsyncGenerator",
    "GeneratorFunction",
    "AsyncGeneratorFunction",
    "AsyncFunction",
    "Observable",
    "Array",
    "Buffer",
    "Blob",
    "Object",
    "RegExp",
    "Date",
    "Error",
    "Map",
    "Set",
    "WeakMap",
    "WeakSet",
    "WeakRef",
    "ArrayBuffer",
    "SharedArrayBuffer",
    "DataView",
    "Promise",
    "URL",
    "FormData",
    "URLSearchParams",
    "HTMLElement",
    "NaN",
    ...Wv
  ];
  function Vk(e) {
    return zk.includes(e);
  }
  n(Vk, "isObjectTypeName");
  var Gk = [
    "null",
    "undefined",
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol"
  ];
  function Jk(e) {
    return Gk.includes(e);
  }
  n(Jk, "isPrimitiveTypeName");
  function di(e) {
    return (t) => typeof t === e;
  }
  n(di, "isOfType");
  var { toString: Yk } = Object.prototype, kn = /* @__PURE__ */ n((e) => {
    let t = Yk.call(e).slice(8, -1);
    if (/HTML\w+Element/.test(t) && D.domElement(e))
      return "HTMLElement";
    if (Vk(t))
      return t;
  }, "getObjectType"), X = /* @__PURE__ */ n((e) => (t) => kn(t) === e, "isObjectOfType");
  function D(e) {
    if (e === null)
      return "null";
    switch (typeof e) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(e) ? "NaN" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "Function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      default:
    }
    if (D.observable(e))
      return "Observable";
    if (D.array(e))
      return "Array";
    if (D.buffer(e))
      return "Buffer";
    let t = kn(e);
    if (t)
      return t;
    if (e instanceof String || e instanceof Boolean || e instanceof Number)
      throw new TypeError("Please don't use object wrappers for primitive types");
    return "Object";
  }
  n(D, "is");
  D.undefined = di("undefined");
  D.string = di("string");
  var Kk = di("number");
  D.number = (e) => Kk(e) && !D.nan(e);
  D.bigint = di("bigint");
  D.function_ = di("function");
  D.null_ = (e) => e === null;
  D.class_ = (e) => D.function_(e) && e.toString().startsWith("class ");
  D.boolean = (e) => e === !0 || e === !1;
  D.symbol = di("symbol");
  D.numericString = (e) => D.string(e) && !D.emptyStringOrWhitespace(e) && !Number.isNaN(Number(e));
  D.array = (e, t) => Array.isArray(e) ? D.function_(t) ? e.every((r) => t(r)) : !0 : !1;
  D.buffer = (e) => {
    var t, r;
    return ((r = (t = e?.constructor) == null ? void 0 : t.isBuffer) == null ? void 0 : r.call(t, e)) ?? !1;
  };
  D.blob = (e) => X("Blob")(e);
  D.nullOrUndefined = (e) => D.null_(e) || D.undefined(e);
  D.object = (e) => !D.null_(e) && (typeof e == "object" || D.function_(e));
  D.iterable = (e) => D.function_(e?.[Symbol.iterator]);
  D.asyncIterable = (e) => D.function_(e?.[Symbol.asyncIterator]);
  D.generator = (e) => D.iterable(e) && D.function_(e?.next) && D.function_(e?.throw);
  D.asyncGenerator = (e) => D.asyncIterable(e) && D.function_(e.next) && D.function_(e.throw);
  D.nativePromise = (e) => X("Promise")(e);
  var Qk = /* @__PURE__ */ n((e) => D.function_(e?.then) && D.function_(e?.catch), "hasPromiseApi");
  D.promise = (e) => D.nativePromise(e) || Qk(e);
  D.generatorFunction = X("GeneratorFunction");
  D.asyncGeneratorFunction = (e) => kn(e) === "AsyncGeneratorFunction";
  D.asyncFunction = (e) => kn(e) === "AsyncFunction";
  D.boundFunction = (e) => D.function_(e) && !e.hasOwnProperty("prototype");
  D.regExp = X("RegExp");
  D.date = X("Date");
  D.error = X("Error");
  D.map = (e) => X("Map")(e);
  D.set = (e) => X("Set")(e);
  D.weakMap = (e) => X("WeakMap")(e);
  D.weakSet = (e) => X("WeakSet")(e);
  D.weakRef = (e) => X("WeakRef")(e);
  D.int8Array = X("Int8Array");
  D.uint8Array = X("Uint8Array");
  D.uint8ClampedArray = X("Uint8ClampedArray");
  D.int16Array = X("Int16Array");
  D.uint16Array = X("Uint16Array");
  D.int32Array = X("Int32Array");
  D.uint32Array = X("Uint32Array");
  D.float32Array = X("Float32Array");
  D.float64Array = X("Float64Array");
  D.bigInt64Array = X("BigInt64Array");
  D.bigUint64Array = X("BigUint64Array");
  D.arrayBuffer = X("ArrayBuffer");
  D.sharedArrayBuffer = X("SharedArrayBuffer");
  D.dataView = X("DataView");
  D.enumCase = (e, t) => Object.values(t).includes(e);
  D.directInstanceOf = (e, t) => Object.getPrototypeOf(e) === t.prototype;
  D.urlInstance = (e) => X("URL")(e);
  D.urlString = (e) => {
    if (!D.string(e))
      return !1;
    try {
      return new URL(e), !0;
    } catch {
      return !1;
    }
  };
  D.truthy = (e) => !!e;
  D.falsy = (e) => !e;
  D.nan = (e) => Number.isNaN(e);
  D.primitive = (e) => D.null_(e) || Jk(typeof e);
  D.integer = (e) => Number.isInteger(e);
  D.safeInteger = (e) => Number.isSafeInteger(e);
  D.plainObject = (e) => {
    if (typeof e != "object" || e === null)
      return !1;
    let t = Object.getPrototypeOf(e);
    return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in
    e);
  };
  D.typedArray = (e) => Hk(kn(e));
  var Xk = /* @__PURE__ */ n((e) => D.safeInteger(e) && e >= 0, "isValidLength");
  D.arrayLike = (e) => !D.nullOrUndefined(e) && !D.function_(e) && Xk(e.length);
  D.inRange = (e, t) => {
    if (D.number(t))
      return e >= Math.min(0, t) && e <= Math.max(t, 0);
    if (D.array(t) && t.length === 2)
      return e >= Math.min(...t) && e <= Math.max(...t);
    throw new TypeError(`Invalid range: ${JSON.stringify(t)}`);
  };
  var Zk = 1, eB = [
    "innerHTML",
    "ownerDocument",
    "style",
    "attributes",
    "nodeValue"
  ];
  D.domElement = (e) => D.object(e) && e.nodeType === Zk && D.string(e.nodeName) && !D.plainObject(e) && eB.every((t) => t in e);
  D.observable = (e) => {
    var t, r;
    return e ? e === ((t = e[Symbol.observable]) == null ? void 0 : t.call(e)) || e === ((r = e["@@observable"]) == null ? void 0 : r.call(e)) :
    !1;
  };
  D.nodeStream = (e) => D.object(e) && D.function_(e.pipe) && !D.observable(e);
  D.infinite = (e) => e === Number.POSITIVE_INFINITY || e === Number.NEGATIVE_INFINITY;
  var $v = /* @__PURE__ */ n((e) => (t) => D.integer(t) && Math.abs(t % 2) === e, "isAbsoluteMod2");
  D.evenInteger = $v(0);
  D.oddInteger = $v(1);
  D.emptyArray = (e) => D.array(e) && e.length === 0;
  D.nonEmptyArray = (e) => D.array(e) && e.length > 0;
  D.emptyString = (e) => D.string(e) && e.length === 0;
  var tB = /* @__PURE__ */ n((e) => D.string(e) && !/\S/.test(e), "isWhiteSpaceString");
  D.emptyStringOrWhitespace = (e) => D.emptyString(e) || tB(e);
  D.nonEmptyString = (e) => D.string(e) && e.length > 0;
  D.nonEmptyStringAndNotWhitespace = (e) => D.string(e) && !D.emptyStringOrWhitespace(e);
  D.emptyObject = (e) => D.object(e) && !D.map(e) && !D.set(e) && Object.keys(e).length === 0;
  D.nonEmptyObject = (e) => D.object(e) && !D.map(e) && !D.set(e) && Object.keys(e).length > 0;
  D.emptySet = (e) => D.set(e) && e.size === 0;
  D.nonEmptySet = (e) => D.set(e) && e.size > 0;
  D.emptyMap = (e) => D.map(e) && e.size === 0;
  D.nonEmptyMap = (e) => D.map(e) && e.size > 0;
  D.propertyKey = (e) => D.any([D.string, D.number, D.symbol], e);
  D.formData = (e) => X("FormData")(e);
  D.urlSearchParams = (e) => X("URLSearchParams")(e);
  var Hv = /* @__PURE__ */ n((e, t, r) => {
    if (!D.function_(t))
      throw new TypeError(`Invalid predicate: ${JSON.stringify(t)}`);
    if (r.length === 0)
      throw new TypeError("Invalid number of values");
    return e.call(r, t);
  }, "predicateOnArray");
  D.any = (e, ...t) => (D.array(e) ? e : [e]).some((i) => Hv(Array.prototype.some, i, t));
  D.all = (e, ...t) => Hv(Array.prototype.every, e, t);
  var k = /* @__PURE__ */ n((e, t, r, i = {}) => {
    if (!e) {
      let { multipleValues: s } = i, o = s ? `received values of types ${[
        ...new Set(r.map((u) => `\`${D(u)}\``))
      ].join(", ")}` : `received value of type \`${D(r)}\``;
      throw new TypeError(`Expected value which is \`${t}\`, ${o}.`);
    }
  }, "assertType"), S = {
    // Unknowns.
    undefined: /* @__PURE__ */ n((e) => k(D.undefined(e), "undefined", e), "undefined"),
    string: /* @__PURE__ */ n((e) => k(D.string(e), "string", e), "string"),
    number: /* @__PURE__ */ n((e) => k(D.number(e), "number", e), "number"),
    bigint: /* @__PURE__ */ n((e) => k(D.bigint(e), "bigint", e), "bigint"),
    // eslint-disable-next-line @typescript-eslint/ban-types
    function_: /* @__PURE__ */ n((e) => k(D.function_(e), "Function", e), "function_"),
    null_: /* @__PURE__ */ n((e) => k(D.null_(e), "null", e), "null_"),
    class_: /* @__PURE__ */ n((e) => k(D.class_(e), "Class", e), "class_"),
    boolean: /* @__PURE__ */ n((e) => k(D.boolean(e), "boolean", e), "boolean"),
    symbol: /* @__PURE__ */ n((e) => k(D.symbol(e), "symbol", e), "symbol"),
    numericString: /* @__PURE__ */ n((e) => k(D.numericString(e), "string with a number", e), "numericString"),
    array: /* @__PURE__ */ n((e, t) => {
      k(D.array(e), "Array", e), t && e.forEach(t);
    }, "array"),
    buffer: /* @__PURE__ */ n((e) => k(D.buffer(e), "Buffer", e), "buffer"),
    blob: /* @__PURE__ */ n((e) => k(D.blob(e), "Blob", e), "blob"),
    nullOrUndefined: /* @__PURE__ */ n((e) => k(D.nullOrUndefined(e), "null or undefined", e), "nullOrUndefined"),
    object: /* @__PURE__ */ n((e) => k(D.object(e), "Object", e), "object"),
    iterable: /* @__PURE__ */ n((e) => k(D.iterable(e), "Iterable", e), "iterable"),
    asyncIterable: /* @__PURE__ */ n((e) => k(D.asyncIterable(e), "AsyncIterable", e), "asyncIterable"),
    generator: /* @__PURE__ */ n((e) => k(D.generator(e), "Generator", e), "generator"),
    asyncGenerator: /* @__PURE__ */ n((e) => k(D.asyncGenerator(e), "AsyncGenerator", e), "asyncGenerator"),
    nativePromise: /* @__PURE__ */ n((e) => k(D.nativePromise(e), "native Promise", e), "nativePromise"),
    promise: /* @__PURE__ */ n((e) => k(D.promise(e), "Promise", e), "promise"),
    generatorFunction: /* @__PURE__ */ n((e) => k(D.generatorFunction(e), "GeneratorFunction", e), "generatorFunction"),
    asyncGeneratorFunction: /* @__PURE__ */ n((e) => k(D.asyncGeneratorFunction(e), "AsyncGeneratorFunction", e), "asyncGeneratorFunction"),
    // eslint-disable-next-line @typescript-eslint/ban-types
    asyncFunction: /* @__PURE__ */ n((e) => k(D.asyncFunction(e), "AsyncFunction", e), "asyncFunction"),
    // eslint-disable-next-line @typescript-eslint/ban-types
    boundFunction: /* @__PURE__ */ n((e) => k(D.boundFunction(e), "Function", e), "boundFunction"),
    regExp: /* @__PURE__ */ n((e) => k(D.regExp(e), "RegExp", e), "regExp"),
    date: /* @__PURE__ */ n((e) => k(D.date(e), "Date", e), "date"),
    error: /* @__PURE__ */ n((e) => k(D.error(e), "Error", e), "error"),
    map: /* @__PURE__ */ n((e) => k(D.map(e), "Map", e), "map"),
    set: /* @__PURE__ */ n((e) => k(D.set(e), "Set", e), "set"),
    weakMap: /* @__PURE__ */ n((e) => k(D.weakMap(e), "WeakMap", e), "weakMap"),
    weakSet: /* @__PURE__ */ n((e) => k(D.weakSet(e), "WeakSet", e), "weakSet"),
    weakRef: /* @__PURE__ */ n((e) => k(D.weakRef(e), "WeakRef", e), "weakRef"),
    int8Array: /* @__PURE__ */ n((e) => k(D.int8Array(e), "Int8Array", e), "int8Array"),
    uint8Array: /* @__PURE__ */ n((e) => k(D.uint8Array(e), "Uint8Array", e), "uint8Array"),
    uint8ClampedArray: /* @__PURE__ */ n((e) => k(D.uint8ClampedArray(e), "Uint8ClampedArray", e), "uint8ClampedArray"),
    int16Array: /* @__PURE__ */ n((e) => k(D.int16Array(e), "Int16Array", e), "int16Array"),
    uint16Array: /* @__PURE__ */ n((e) => k(D.uint16Array(e), "Uint16Array", e), "uint16Array"),
    int32Array: /* @__PURE__ */ n((e) => k(D.int32Array(e), "Int32Array", e), "int32Array"),
    uint32Array: /* @__PURE__ */ n((e) => k(D.uint32Array(e), "Uint32Array", e), "uint32Array"),
    float32Array: /* @__PURE__ */ n((e) => k(D.float32Array(e), "Float32Array", e), "float32Array"),
    float64Array: /* @__PURE__ */ n((e) => k(D.float64Array(e), "Float64Array", e), "float64Array"),
    bigInt64Array: /* @__PURE__ */ n((e) => k(D.bigInt64Array(e), "BigInt64Array", e), "bigInt64Array"),
    bigUint64Array: /* @__PURE__ */ n((e) => k(D.bigUint64Array(e), "BigUint64Array", e), "bigUint64Array"),
    arrayBuffer: /* @__PURE__ */ n((e) => k(D.arrayBuffer(e), "ArrayBuffer", e), "arrayBuffer"),
    sharedArrayBuffer: /* @__PURE__ */ n((e) => k(D.sharedArrayBuffer(e), "SharedArrayBuffer", e), "sharedArrayBuffer"),
    dataView: /* @__PURE__ */ n((e) => k(D.dataView(e), "DataView", e), "dataView"),
    enumCase: /* @__PURE__ */ n((e, t) => k(D.enumCase(e, t), "EnumCase", e), "enumCase"),
    urlInstance: /* @__PURE__ */ n((e) => k(D.urlInstance(e), "URL", e), "urlInstance"),
    urlString: /* @__PURE__ */ n((e) => k(D.urlString(e), "string with a URL", e), "urlString"),
    truthy: /* @__PURE__ */ n((e) => k(D.truthy(e), "truthy", e), "truthy"),
    falsy: /* @__PURE__ */ n((e) => k(D.falsy(e), "falsy", e), "falsy"),
    nan: /* @__PURE__ */ n((e) => k(D.nan(e), "NaN", e), "nan"),
    primitive: /* @__PURE__ */ n((e) => k(D.primitive(e), "primitive", e), "primitive"),
    integer: /* @__PURE__ */ n((e) => k(D.integer(e), "integer", e), "integer"),
    safeInteger: /* @__PURE__ */ n((e) => k(D.safeInteger(e), "integer", e), "safeInteger"),
    plainObject: /* @__PURE__ */ n((e) => k(D.plainObject(e), "plain object", e), "plainObject"),
    typedArray: /* @__PURE__ */ n((e) => k(D.typedArray(e), "TypedArray", e), "typedArray"),
    arrayLike: /* @__PURE__ */ n((e) => k(D.arrayLike(e), "array-like", e), "arrayLike"),
    domElement: /* @__PURE__ */ n((e) => k(D.domElement(e), "HTMLElement", e), "domElement"),
    observable: /* @__PURE__ */ n((e) => k(D.observable(e), "Observable", e), "observable"),
    nodeStream: /* @__PURE__ */ n((e) => k(D.nodeStream(e), "Node.js Stream", e), "nodeStream"),
    infinite: /* @__PURE__ */ n((e) => k(D.infinite(e), "infinite number", e), "infinite"),
    emptyArray: /* @__PURE__ */ n((e) => k(D.emptyArray(e), "empty array", e), "emptyArray"),
    nonEmptyArray: /* @__PURE__ */ n((e) => k(D.nonEmptyArray(e), "non-empty array", e), "nonEmptyArray"),
    emptyString: /* @__PURE__ */ n((e) => k(D.emptyString(e), "empty string", e), "emptyString"),
    emptyStringOrWhitespace: /* @__PURE__ */ n((e) => k(D.emptyStringOrWhitespace(e), "empty string or whitespace", e), "emptyStringOrWhites\
pace"),
    nonEmptyString: /* @__PURE__ */ n((e) => k(D.nonEmptyString(e), "non-empty string", e), "nonEmptyString"),
    nonEmptyStringAndNotWhitespace: /* @__PURE__ */ n((e) => k(D.nonEmptyStringAndNotWhitespace(e), "non-empty string and not whitespace", e),
    "nonEmptyStringAndNotWhitespace"),
    emptyObject: /* @__PURE__ */ n((e) => k(D.emptyObject(e), "empty object", e), "emptyObject"),
    nonEmptyObject: /* @__PURE__ */ n((e) => k(D.nonEmptyObject(e), "non-empty object", e), "nonEmptyObject"),
    emptySet: /* @__PURE__ */ n((e) => k(D.emptySet(e), "empty set", e), "emptySet"),
    nonEmptySet: /* @__PURE__ */ n((e) => k(D.nonEmptySet(e), "non-empty set", e), "nonEmptySet"),
    emptyMap: /* @__PURE__ */ n((e) => k(D.emptyMap(e), "empty map", e), "emptyMap"),
    nonEmptyMap: /* @__PURE__ */ n((e) => k(D.nonEmptyMap(e), "non-empty map", e), "nonEmptyMap"),
    propertyKey: /* @__PURE__ */ n((e) => k(D.propertyKey(e), "PropertyKey", e), "propertyKey"),
    formData: /* @__PURE__ */ n((e) => k(D.formData(e), "FormData", e), "formData"),
    urlSearchParams: /* @__PURE__ */ n((e) => k(D.urlSearchParams(e), "URLSearchParams", e), "urlSearchParams"),
    // Numbers.
    evenInteger: /* @__PURE__ */ n((e) => k(D.evenInteger(e), "even integer", e), "evenInteger"),
    oddInteger: /* @__PURE__ */ n((e) => k(D.oddInteger(e), "odd integer", e), "oddInteger"),
    // Two arguments.
    directInstanceOf: /* @__PURE__ */ n((e, t) => k(D.directInstanceOf(e, t), "T", e), "directInstanceOf"),
    inRange: /* @__PURE__ */ n((e, t) => k(D.inRange(e, t), "in range", e), "inRange"),
    // Variadic functions.
    any: /* @__PURE__ */ n((e, ...t) => k(D.any(e, ...t), "predicate returns truthy for any value", t, { multipleValues: !0 }), "any"),
    all: /* @__PURE__ */ n((e, ...t) => k(D.all(e, ...t), "predicate returns truthy for all values", t, { multipleValues: !0 }), "all")
  };
  Object.defineProperties(D, {
    class: {
      value: D.class_
    },
    function: {
      value: D.function_
    },
    null: {
      value: D.null_
    }
  });
  Object.defineProperties(S, {
    class: {
      value: S.class_
    },
    function: {
      value: S.function_
    },
    null: {
      value: S.null_
    }
  });
  var b = D, rB = require("events"), iB = class extends Error {
    static {
      n(this, "CancelError");
    }
    constructor(e) {
      super(e || "Promise was canceled"), this.name = "CancelError";
    }
    get isCanceled() {
      return !0;
    }
  }, Wc = class {
    static {
      n(this, "PCancelable");
    }
    static fn(e) {
      return (...t) => new Wc((r, i, s) => {
        t.push(s), e(...t).then(r, i);
      });
    }
    constructor(e) {
      this._cancelHandlers = [], this._isPending = !0, this._isCanceled = !1, this._rejectOnCancel = !0, this._promise = new Promise((t, r) => {
        this._reject = r;
        let i = /* @__PURE__ */ n((u) => {
          (!this._isCanceled || !o.shouldReject) && (this._isPending = !1, t(u));
        }, "onResolve"), s = /* @__PURE__ */ n((u) => {
          this._isPending = !1, r(u);
        }, "onReject"), o = /* @__PURE__ */ n((u) => {
          if (!this._isPending)
            throw new Error("The `onCancel` handler was attached after the promise settled.");
          this._cancelHandlers.push(u);
        }, "onCancel");
        Object.defineProperties(o, {
          shouldReject: {
            get: /* @__PURE__ */ n(() => this._rejectOnCancel, "get"),
            set: /* @__PURE__ */ n((u) => {
              this._rejectOnCancel = u;
            }, "set")
          }
        }), e(i, s, o);
      });
    }
    then(e, t) {
      return this._promise.then(e, t);
    }
    catch(e) {
      return this._promise.catch(e);
    }
    finally(e) {
      return this._promise.finally(e);
    }
    cancel(e) {
      if (!(!this._isPending || this._isCanceled)) {
        if (this._isCanceled = !0, this._cancelHandlers.length > 0)
          try {
            for (let t of this._cancelHandlers)
              t();
          } catch (t) {
            this._reject(t);
            return;
          }
        this._rejectOnCancel && this._reject(new iB(e));
      }
    }
    get isCanceled() {
      return this._isCanceled;
    }
  };
  Object.setPrototypeOf(Wc.prototype, Promise.prototype);
  function nB(e) {
    return b.object(e) && "_onResponse" in e;
  }
  n(nB, "isRequest");
  var ve = class extends Error {
    static {
      n(this, "RequestError");
    }
    constructor(e, t, r) {
      var i;
      if (super(e), Object.defineProperty(this, "input", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "stack", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "response", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "request", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "timings", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Error.captureStackTrace(this, this.constructor), this.name = "RequestError", this.code = t.code ?? "ERR_GOT_REQUEST_ERROR", this.input =
      t.input, nB(r) ? (Object.defineProperty(this, "request", {
        enumerable: !1,
        value: r
      }), Object.defineProperty(this, "response", {
        enumerable: !1,
        value: r.response
      }), this.options = r.options) : this.options = r, this.timings = (i = this.request) == null ? void 0 : i.timings, b.string(t.stack) &&
      b.string(this.stack)) {
        let s = this.stack.indexOf(this.message) + this.message.length, o = this.stack.slice(s).split(`
`).reverse(), u = t.stack.slice(t.stack.indexOf(t.message) + t.message.length).split(`
`).reverse();
        for (; u.length > 0 && u[0] === o[0]; )
          o.shift();
        this.stack = `${this.stack.slice(0, s)}${o.reverse().join(`
`)}${u.reverse().join(`
`)}`;
      }
    }
  }, sB = class extends ve {
    static {
      n(this, "MaxRedirectsError");
    }
    constructor(e) {
      super(`Redirected ${e.options.maxRedirects} times. Aborting.`, {}, e), this.name = "MaxRedirectsError", this.code = "ERR_TOO_MANY_REDI\
RECTS";
    }
  }, No = class extends ve {
    static {
      n(this, "HTTPError");
    }
    constructor(e) {
      super(`Response code ${e.statusCode} (${e.statusMessage})`, {}, e.request), this.name = "HTTPError", this.code = "ERR_NON_2XX_3XX_RESP\
ONSE";
    }
  }, oB = class extends ve {
    static {
      n(this, "CacheError");
    }
    constructor(e, t) {
      super(e.message, e, t), this.name = "CacheError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_CACHE_ACCESS" : this.code;
    }
  }, nv = class extends ve {
    static {
      n(this, "UploadError");
    }
    constructor(e, t) {
      super(e.message, e, t), this.name = "UploadError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_UPLOAD" : this.code;
    }
  }, uB = class extends ve {
    static {
      n(this, "TimeoutError");
    }
    constructor(e, t, r) {
      super(e.message, e, r), Object.defineProperty(this, "timings", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "event", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.name = "TimeoutError", this.event = e.event, this.timings = t;
    }
  }, sv = class extends ve {
    static {
      n(this, "ReadError");
    }
    constructor(e, t) {
      super(e.message, e, t), this.name = "ReadError", this.code = this.code === "ERR_GOT_REQUEST_ERROR" ? "ERR_READING_RESPONSE_STREAM" : this.
      code;
    }
  }, aB = class extends ve {
    static {
      n(this, "RetryError");
    }
    constructor(e) {
      super("Retrying", {}, e), this.name = "RetryError", this.code = "ERR_RETRYING";
    }
  }, lB = class extends ve {
    static {
      n(this, "AbortError");
    }
    constructor(e) {
      super("This operation was aborted.", {}, e), this.code = "ERR_ABORTED", this.name = "AbortError";
    }
  }, zv = we(require("process"), 1), Rc = require("buffer"), cB = require("stream"), ov = require("url"), kc = we(require("http"), 1), fB = require("events"),
  hB = require("util"), dB = we(Ck(), 1), pB = /* @__PURE__ */ n((e) => {
    if (e.timings)
      return e.timings;
    let t = {
      start: Date.now(),
      socket: void 0,
      lookup: void 0,
      connect: void 0,
      secureConnect: void 0,
      upload: void 0,
      response: void 0,
      end: void 0,
      error: void 0,
      abort: void 0,
      phases: {
        wait: void 0,
        dns: void 0,
        tcp: void 0,
        tls: void 0,
        request: void 0,
        firstByte: void 0,
        download: void 0,
        total: void 0
      }
    };
    e.timings = t;
    let r = /* @__PURE__ */ n((u) => {
      u.once(fB.errorMonitor, () => {
        t.error = Date.now(), t.phases.total = t.error - t.start;
      });
    }, "handleError");
    r(e);
    let i = /* @__PURE__ */ n(() => {
      t.abort = Date.now(), t.phases.total = t.abort - t.start;
    }, "onAbort");
    e.prependOnceListener("abort", i);
    let s = /* @__PURE__ */ n((u) => {
      if (t.socket = Date.now(), t.phases.wait = t.socket - t.start, hB.types.isProxy(u))
        return;
      let a = /* @__PURE__ */ n(() => {
        t.lookup = Date.now(), t.phases.dns = t.lookup - t.socket;
      }, "lookupListener");
      u.prependOnceListener("lookup", a), (0, dB.default)(u, {
        connect: /* @__PURE__ */ n(() => {
          t.connect = Date.now(), t.lookup === void 0 && (u.removeListener("lookup", a), t.lookup = t.connect, t.phases.dns = t.lookup - t.socket),
          t.phases.tcp = t.connect - t.lookup;
        }, "connect"),
        secureConnect: /* @__PURE__ */ n(() => {
          t.secureConnect = Date.now(), t.phases.tls = t.secureConnect - t.connect;
        }, "secureConnect")
      });
    }, "onSocket");
    e.socket ? s(e.socket) : e.prependOnceListener("socket", s);
    let o = /* @__PURE__ */ n(() => {
      t.upload = Date.now(), t.phases.request = t.upload - (t.secureConnect ?? t.connect);
    }, "onUpload");
    return e.writableFinished ? o() : e.prependOnceListener("finish", o), e.prependOnceListener("response", (u) => {
      t.response = Date.now(), t.phases.firstByte = t.response - t.upload, u.timings = t, r(u), u.prependOnceListener("end", () => {
        e.off("abort", i), u.off("aborted", i), !t.phases.total && (t.end = Date.now(), t.phases.download = t.end - t.response, t.phases.total =
        t.end - t.start);
      }), u.prependOnceListener("aborted", i);
    }), t;
  }, "timer"), DB = pB, mB = we(require("events"), 1), Bo = we(require("url"), 1), yB = we(require("crypto"), 1), Vv = we(require("stream"),
  1), gB = "text/plain", bB = "us-ascii", Bc = /* @__PURE__ */ n((e, t) => t.some((r) => r instanceof RegExp ? r.test(e) : r === e), "testPa\
rameter"), wB = /* @__PURE__ */ new Set([
    "https:",
    "http:",
    "file:"
  ]), vB = /* @__PURE__ */ n((e) => {
    try {
      let { protocol: t } = new URL(e);
      return t.endsWith(":") && !wB.has(t);
    } catch {
      return !1;
    }
  }, "hasCustomProtocol"), _B = /* @__PURE__ */ n((e, { stripHash: t }) => {
    var r;
    let i = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(e);
    if (!i)
      throw new Error(`Invalid URL: ${e}`);
    let { type: s, data: o, hash: u } = i.groups, a = s.split(";");
    u = t ? "" : u;
    let l = !1;
    a[a.length - 1] === "base64" && (a.pop(), l = !0);
    let c = ((r = a.shift()) == null ? void 0 : r.toLowerCase()) ?? "", p = [
      ...a.map((d) => {
        let [f, m = ""] = d.split("=").map((v) => v.trim());
        return f === "charset" && (m = m.toLowerCase(), m === bB) ? "" : `${f}${m ? `=${m}` : ""}`;
      }).filter(Boolean)
    ];
    return l && p.push("base64"), (p.length > 0 || c && c !== gB) && p.unshift(c), `data:${p.join(";")},${l ? o.trim() : o}${u ? `#${u}` : ""}`;
  }, "normalizeDataURL");
  function EB(e, t) {
    if (t = {
      defaultProtocol: "http",
      normalizeProtocol: !0,
      forceHttp: !1,
      forceHttps: !1,
      stripAuthentication: !0,
      stripHash: !1,
      stripTextFragment: !0,
      stripWWW: !0,
      removeQueryParameters: [/^utm_\w+/i],
      removeTrailingSlash: !0,
      removeSingleSlash: !0,
      removeDirectoryIndex: !1,
      removeExplicitPort: !1,
      sortQueryParameters: !0,
      ...t
    }, typeof t.defaultProtocol == "string" && !t.defaultProtocol.endsWith(":") && (t.defaultProtocol = `${t.defaultProtocol}:`), e = e.trim(),
    /^data:/i.test(e))
      return _B(e, t);
    if (vB(e))
      return e;
    let r = e.startsWith("//");
    !r && /^\.*\//.test(e) || (e = e.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol));
    let s = new URL(e);
    if (t.forceHttp && t.forceHttps)
      throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
    if (t.forceHttp && s.protocol === "https:" && (s.protocol = "http:"), t.forceHttps && s.protocol === "http:" && (s.protocol = "https:"),
    t.stripAuthentication && (s.username = "", s.password = ""), t.stripHash ? s.hash = "" : t.stripTextFragment && (s.hash = s.hash.replace(
    /#?:~:text.*?$/i, "")), s.pathname) {
      let u = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g, a = 0, l = "";
      for (; ; ) {
        let h = u.exec(s.pathname);
        if (!h)
          break;
        let p = h[0], d = h.index, f = s.pathname.slice(a, d);
        l += f.replace(/\/{2,}/g, "/"), l += p, a = d + p.length;
      }
      let c = s.pathname.slice(a, s.pathname.length);
      l += c.replace(/\/{2,}/g, "/"), s.pathname = l;
    }
    if (s.pathname)
      try {
        s.pathname = decodeURI(s.pathname);
      } catch {
      }
    if (t.removeDirectoryIndex === !0 && (t.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.
    length > 0) {
      let u = s.pathname.split("/"), a = u[u.length - 1];
      Bc(a, t.removeDirectoryIndex) && (u = u.slice(0, -1), s.pathname = u.slice(1).join("/") + "/");
    }
    if (s.hostname && (s.hostname = s.hostname.replace(/\.$/, ""), t.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.
    hostname) && (s.hostname = s.hostname.replace(/^www\./, ""))), Array.isArray(t.removeQueryParameters))
      for (let u of [...s.searchParams.keys()])
        Bc(u, t.removeQueryParameters) && s.searchParams.delete(u);
    if (!Array.isArray(t.keepQueryParameters) && t.removeQueryParameters === !0 && (s.search = ""), Array.isArray(t.keepQueryParameters) && t.
    keepQueryParameters.length > 0)
      for (let u of [...s.searchParams.keys()])
        Bc(u, t.keepQueryParameters) || s.searchParams.delete(u);
    if (t.sortQueryParameters) {
      s.searchParams.sort();
      try {
        s.search = decodeURIComponent(s.search);
      } catch {
      }
    }
    t.removeTrailingSlash && (s.pathname = s.pathname.replace(/\/$/, "")), t.removeExplicitPort && s.port && (s.port = "");
    let o = e;
    return e = s.toString(), !t.removeSingleSlash && s.pathname === "/" && !o.endsWith("/") && s.hash === "" && (e = e.replace(/\/$/, "")), (t.
    removeTrailingSlash || s.pathname === "/") && s.hash === "" && t.removeSingleSlash && (e = e.replace(/\/$/, "")), r && !t.normalizeProtocol &&
    (e = e.replace(/^http:\/\//, "//")), t.stripProtocol && (e = e.replace(/^(?:https?:)?\/\//, "")), e;
  }
  n(EB, "normalizeUrl");
  var CB = we(Rv(), 1), Oc = we(xk(), 1), FB = require("stream");
  function Nc(e) {
    return Object.fromEntries(Object.entries(e).map(([t, r]) => [t.toLowerCase(), r]));
  }
  n(Nc, "lowercaseKeys");
  var uv = class extends FB.Readable {
    static {
      n(this, "Response");
    }
    statusCode;
    headers;
    body;
    url;
    constructor({ statusCode: e, headers: t, body: r, url: i }) {
      if (typeof e != "number")
        throw new TypeError("Argument `statusCode` should be a number");
      if (typeof t != "object")
        throw new TypeError("Argument `headers` should be an object");
      if (!(r instanceof Uint8Array))
        throw new TypeError("Argument `body` should be a buffer");
      if (typeof i != "string")
        throw new TypeError("Argument `url` should be a string");
      super({
        read() {
          this.push(r), this.push(null);
        }
      }), this.statusCode = e, this.headers = Nc(t), this.body = r, this.url = i;
    }
  }, Oo = we(Ak(), 1), xB = [
    "aborted",
    "complete",
    "headers",
    "httpVersion",
    "httpVersionMinor",
    "httpVersionMajor",
    "method",
    "rawHeaders",
    "rawTrailers",
    "setTimeout",
    "socket",
    "statusCode",
    "statusMessage",
    "trailers",
    "url"
  ];
  function SB(e, t) {
    if (t._readableState.autoDestroy)
      throw new Error("The second stream must have the `autoDestroy` option set to `false`");
    let r = /* @__PURE__ */ new Set([...Object.keys(e), ...xB]), i = {};
    for (let s of r)
      s in t || (i[s] = {
        get() {
          let o = e[s];
          return typeof o == "function" ? o.bind(e) : o;
        },
        set(o) {
          e[s] = o;
        },
        enumerable: !0,
        configurable: !1
      });
    return Object.defineProperties(t, i), e.once("aborted", () => {
      t.destroy(), t.emit("aborted");
    }), e.once("close", () => {
      e.complete && t.readable ? t.once("end", () => {
        t.emit("close");
      }) : t.emit("close");
    }), t;
  }
  n(SB, "mimicResponse");
  var AB = class extends Error {
    static {
      n(this, "RequestError2");
    }
    constructor(e) {
      super(e.message), Object.assign(this, e);
    }
  }, Rn = class extends Error {
    static {
      n(this, "CacheError2");
    }
    constructor(e) {
      super(e.message), Object.assign(this, e);
    }
  }, TB = class {
    static {
      n(this, "CacheableRequest");
    }
    constructor(e, t) {
      this.hooks = /* @__PURE__ */ new Map(), this.request = () => (r, i) => {
        let s;
        if (typeof r == "string")
          s = Pc(Bo.default.parse(r)), r = {};
        else if (r instanceof Bo.default.URL)
          s = Pc(Bo.default.parse(r.toString())), r = {};
        else {
          let [p, ...d] = (r.path ?? "").split("?"), f = d.length > 0 ? `?${d.join("?")}` : "";
          s = Pc({ ...r, pathname: p, search: f });
        }
        r = {
          headers: {},
          method: "GET",
          cache: !0,
          strictTtl: !1,
          automaticFailover: !1,
          ...r,
          ...BB(s)
        }, r.headers = Object.fromEntries(RB(r.headers).map(([p, d]) => [p.toLowerCase(), d]));
        let o = new mB.default(), u = EB(Bo.default.format(s), {
          stripWWW: !1,
          removeTrailingSlash: !1,
          stripAuthentication: !1
        }), a = `${r.method}:${u}`;
        r.body && r.method !== void 0 && ["POST", "PATCH", "PUT"].includes(r.method) && (r.body instanceof Vv.default.Readable ? r.cache = !1 :
        a += `:${yB.default.createHash("md5").update(r.body).digest("hex")}`);
        let l = !1, c = !1, h = /* @__PURE__ */ n((p) => {
          c = !0;
          let d = !1, f = /* @__PURE__ */ n(() => {
          }, "requestErrorCallback"), m = new Promise((y) => {
            f = /* @__PURE__ */ n(() => {
              d || (d = !0, y());
            }, "requestErrorCallback");
          }), v = /* @__PURE__ */ n(async (y) => {
            if (l) {
              y.status = y.statusCode;
              let C = Oc.default.fromObject(l.cachePolicy).revalidatedPolicy(p, y);
              if (!C.modified) {
                y.resume(), await new Promise((E) => {
                  y.once("end", E);
                });
                let w = av(C.policy.responseHeaders());
                y = new uv({ statusCode: l.statusCode, headers: w, body: l.body, url: l.url }), y.cachePolicy = C.policy, y.fromCache = !0;
              }
            }
            y.fromCache || (y.cachePolicy = new Oc.default(p, y, p), y.fromCache = !1);
            let _;
            p.cache && y.cachePolicy.storable() ? (_ = kB(y), (async () => {
              try {
                let C = CB.default.buffer(y);
                await Promise.race([
                  m,
                  new Promise((A) => y.once("end", A)),
                  new Promise((A) => y.once("close", A))
                  // eslint-disable-line no-promise-executor-return
                ]);
                let w = await C, E = {
                  url: y.url,
                  statusCode: y.fromCache ? l.statusCode : y.statusCode,
                  body: w,
                  cachePolicy: y.cachePolicy.toObject()
                }, x = p.strictTtl ? y.cachePolicy.timeToLive() : void 0;
                if (p.maxTtl && (x = x ? Math.min(x, p.maxTtl) : p.maxTtl), this.hooks.size > 0)
                  for (let A of this.hooks.keys())
                    E = await this.runHook(A, E, y);
                await this.cache.set(a, E, x);
              } catch (C) {
                o.emit("error", new Rn(C));
              }
            })()) : p.cache && l && (async () => {
              try {
                await this.cache.delete(a);
              } catch (C) {
                o.emit("error", new Rn(C));
              }
            })(), o.emit("response", _ ?? y), typeof i == "function" && i(_ ?? y);
          }, "handler");
          try {
            let y = this.cacheRequest(p, v);
            y.once("error", f), y.once("abort", f), y.once("destroy", f), o.emit("request", y);
          } catch (y) {
            o.emit("error", new AB(y));
          }
        }, "makeRequest");
        return (async () => {
          let p = /* @__PURE__ */ n(async (f) => {
            await Promise.resolve();
            let m = f.cache ? await this.cache.get(a) : void 0;
            if (typeof m > "u" && !f.forceRefresh) {
              h(f);
              return;
            }
            let v = Oc.default.fromObject(m.cachePolicy);
            if (v.satisfiesWithoutRevalidation(f) && !f.forceRefresh) {
              let y = av(v.responseHeaders()), _ = new uv({ statusCode: m.statusCode, headers: y, body: m.body, url: m.url });
              _.cachePolicy = v, _.fromCache = !0, o.emit("response", _), typeof i == "function" && i(_);
            } else v.satisfiesWithoutRevalidation(f) && Date.now() >= v.timeToLive() && f.forceRefresh ? (await this.cache.delete(a), f.headers =
            v.revalidationHeaders(f), h(f)) : (l = m, f.headers = v.revalidationHeaders(f), h(f));
          }, "get"), d = /* @__PURE__ */ n((f) => o.emit("error", new Rn(f)), "errorHandler");
          if (this.cache instanceof Oo.default) {
            let f = this.cache;
            f.once("error", d), o.on("error", () => f.removeListener("error", d)), o.on("response", () => f.removeListener("error", d));
          }
          try {
            await p(r);
          } catch (f) {
            r.automaticFailover && !c && h(r), o.emit("error", new Rn(f));
          }
        })(), o;
      }, this.addHook = (r, i) => {
        this.hooks.has(r) || this.hooks.set(r, i);
      }, this.removeHook = (r) => this.hooks.delete(r), this.getHook = (r) => this.hooks.get(r), this.runHook = async (r, ...i) => {
        var s;
        return (s = this.hooks.get(r)) == null ? void 0 : s(...i);
      }, t instanceof Oo.default ? this.cache = t : typeof t == "string" ? this.cache = new Oo.default({
        uri: t,
        namespace: "cacheable-request"
      }) : this.cache = new Oo.default({
        store: t,
        namespace: "cacheable-request"
      }), this.request = this.request.bind(this), this.cacheRequest = e;
    }
  }, RB = Object.entries, kB = /* @__PURE__ */ n((e) => {
    let t = new Vv.PassThrough({ autoDestroy: !1 });
    return SB(e, t), e.pipe(t);
  }, "cloneResponse"), BB = /* @__PURE__ */ n((e) => {
    let t = { ...e };
    return t.path = `${e.pathname || "/"}${e.search || ""}`, delete t.pathname, delete t.search, t;
  }, "urlObjectToRequestOptions"), Pc = /* @__PURE__ */ n((e) => (
    // If url was parsed by url.parse or new URL:
    // - hostname will be set
    // - host will be hostname[:port]
    // - port will be set if it was explicit in the parsed string
    // Otherwise, url was from request options:
    // - hostname or host may be set
    // - host shall not have port encoded
    {
      protocol: e.protocol,
      auth: e.auth,
      hostname: e.hostname || e.host || "localhost",
      port: e.port,
      pathname: e.pathname,
      search: e.search
    }
  ), "normalizeUrlObject"), av = /* @__PURE__ */ n((e) => {
    let t = [];
    for (let r of Object.keys(e))
      t[r.toLowerCase()] = e[r];
    return t;
  }, "convertHeaders"), OB = TB, PB = we(Rk(), 1), qB = we(Rv(), 1), Mt = /* @__PURE__ */ n((e) => typeof e == "function", "isFunction"), MB = /* @__PURE__ */ n(
  (e) => Mt(e[Symbol.asyncIterator]), "isAsyncIterable");
  async function* jB(e) {
    let t = e.getReader();
    for (; ; ) {
      let { done: r, value: i } = await t.read();
      if (r)
        break;
      yield i;
    }
  }
  n(jB, "readStream");
  var IB = /* @__PURE__ */ n((e) => {
    if (MB(e))
      return e;
    if (Mt(e.getReader))
      return jB(e);
    throw new TypeError("Unsupported data source: Expected either ReadableStream or async iterable.");
  }, "getStreamIterator"), lv = "abcdefghijklmnopqrstuvwxyz0123456789";
  function LB() {
    let e = 16, t = "";
    for (; e--; )
      t += lv[Math.random() * lv.length << 0];
    return t;
  }
  n(LB, "createBoundary");
  var cv = /* @__PURE__ */ n((e) => String(e).replace(/\r|\n/g, (t, r, i) => t === "\r" && i[r + 1] !== `
` || t === `
` && i[r - 1] !== "\r" ? `\r
` : t), "normalizeValue"), NB = /* @__PURE__ */ n((e) => Object.prototype.toString.call(e).slice(8, -1).toLowerCase(), "getType");
  function fv(e) {
    if (NB(e) !== "object")
      return !1;
    let t = Object.getPrototypeOf(e);
    return t == null ? !0 : (t.constructor && t.constructor.toString()) === Object.toString();
  }
  n(fv, "isPlainObject");
  function hv(e, t) {
    if (typeof t == "string") {
      for (let [r, i] of Object.entries(e))
        if (t.toLowerCase() === r.toLowerCase())
          return i;
    }
  }
  n(hv, "getProperty");
  var UB = /* @__PURE__ */ n((e) => new Proxy(e, {
    get: /* @__PURE__ */ n((t, r) => hv(t, r), "get"),
    has: /* @__PURE__ */ n((t, r) => hv(t, r) !== void 0, "has")
  }), "proxyHeaders"), $c = /* @__PURE__ */ n((e) => !!(e && Mt(e.constructor) && e[Symbol.toStringTag] === "FormData" && Mt(e.append) && Mt(
  e.getAll) && Mt(e.entries) && Mt(e[Symbol.iterator])), "isFormData"), dv = /* @__PURE__ */ n((e) => String(e).replace(/\r/g, "%0D").replace(
  /\n/g, "%0A").replace(/"/g, "%22"), "escapeName"), wr = /* @__PURE__ */ n((e) => !!(e && typeof e == "object" && Mt(e.constructor) && e[Symbol.
  toStringTag] === "File" && Mt(e.stream) && e.name != null), "isFile"), Cn = /* @__PURE__ */ n(function(e, t, r, i, s) {
    if (i === "m")
      throw new TypeError("Private method is not writable");
    if (i === "a" && !s)
      throw new TypeError("Private accessor was defined without a setter");
    if (typeof t == "function" ? e !== t || !s : !t.has(e))
      throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return i === "a" ? s.call(e, r) : s ? s.value = r : t.set(e, r), r;
  }, "__classPrivateFieldSet"), oe = /* @__PURE__ */ n(function(e, t, r, i) {
    if (r === "a" && !i)
      throw new TypeError("Private accessor was defined without a getter");
    if (typeof t == "function" ? e !== t || !i : !t.has(e))
      throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return r === "m" ? i : r === "a" ? i.call(e) : i ? i.value : t.get(e);
  }, "__classPrivateFieldGet"), Fn, er, xn, Po, Sn, vr, An, Tn, qo, qc, pv, WB = {
    enableAdditionalHeaders: !1
  }, Mo = { writable: !1, configurable: !1 }, $B = class {
    static {
      n(this, "FormDataEncoder");
    }
    constructor(e, t, r) {
      if (Fn.add(this), er.set(this, `\r
`), xn.set(this, void 0), Po.set(this, void 0), Sn.set(this, "-".repeat(2)), vr.set(this, new TextEncoder()), An.set(this, void 0), Tn.set(this,
      void 0), qo.set(this, void 0), !$c(e))
        throw new TypeError("Expected first argument to be a FormData instance.");
      let i;
      if (fv(t) ? r = t : i = t, i || (i = LB()), typeof i != "string")
        throw new TypeError("Expected boundary argument to be a string.");
      if (r && !fv(r))
        throw new TypeError("Expected options argument to be an object.");
      Cn(this, Tn, Array.from(e.entries()), "f"), Cn(this, qo, { ...WB, ...r }, "f"), Cn(this, xn, oe(this, vr, "f").encode(oe(this, er, "f")),
      "f"), Cn(this, Po, oe(this, xn, "f").byteLength, "f"), this.boundary = `form-data-boundary-${i}`, this.contentType = `multipart/form-d\
ata; boundary=${this.boundary}`, Cn(this, An, oe(this, vr, "f").encode(`${oe(this, Sn, "f")}${this.boundary}${oe(this, Sn, "f")}${oe(this, er,
      "f").repeat(2)}`), "f");
      let s = {
        "Content-Type": this.contentType
      }, o = oe(this, Fn, "m", pv).call(this);
      o && (this.contentLength = o, s["Content-Length"] = o), this.headers = UB(Object.freeze(s)), Object.defineProperties(this, {
        boundary: Mo,
        contentType: Mo,
        contentLength: Mo,
        headers: Mo
      });
    }
    getContentLength() {
      return this.contentLength == null ? void 0 : Number(this.contentLength);
    }
    *values() {
      for (let [e, t] of oe(this, Tn, "f")) {
        let r = wr(t) ? t : oe(this, vr, "f").encode(cv(t));
        yield oe(this, Fn, "m", qc).call(this, e, r), yield r, yield oe(this, xn, "f");
      }
      yield oe(this, An, "f");
    }
    async *encode() {
      for (let e of this.values())
        wr(e) ? yield* IB(e.stream()) : yield e;
    }
    [(er = /* @__PURE__ */ new WeakMap(), xn = /* @__PURE__ */ new WeakMap(), Po = /* @__PURE__ */ new WeakMap(), Sn = /* @__PURE__ */ new WeakMap(),
    vr = /* @__PURE__ */ new WeakMap(), An = /* @__PURE__ */ new WeakMap(), Tn = /* @__PURE__ */ new WeakMap(), qo = /* @__PURE__ */ new WeakMap(),
    Fn = /* @__PURE__ */ new WeakSet(), qc = /* @__PURE__ */ n(function(t, r) {
      let i = "";
      i += `${oe(this, Sn, "f")}${this.boundary}${oe(this, er, "f")}`, i += `Content-Disposition: form-data; name="${dv(t)}"`, wr(r) && (i +=
      `; filename="${dv(r.name)}"${oe(this, er, "f")}`, i += `Content-Type: ${r.type || "application/octet-stream"}`);
      let s = wr(r) ? r.size : r.byteLength;
      return oe(this, qo, "f").enableAdditionalHeaders === !0 && s != null && !isNaN(s) && (i += `${oe(this, er, "f")}Content-Length: ${wr(r) ?
      r.size : r.byteLength}`), oe(this, vr, "f").encode(`${i}${oe(this, er, "f").repeat(2)}`);
    }, "_FormDataEncoder_getFieldHeader2"), pv = /* @__PURE__ */ n(function() {
      let t = 0;
      for (let [r, i] of oe(this, Tn, "f")) {
        let s = wr(i) ? i : oe(this, vr, "f").encode(cv(i)), o = wr(s) ? s.size : s.byteLength;
        if (o == null || isNaN(o))
          return;
        t += oe(this, Fn, "m", qc).call(this, r, s).byteLength, t += o, t += oe(this, Po, "f");
      }
      return String(t + oe(this, An, "f").byteLength);
    }, "_FormDataEncoder_getContentLength2"), Symbol.iterator)]() {
      return this.values();
    }
    [Symbol.asyncIterator]() {
      return this.encode();
    }
  }, HB = require("buffer"), zB = require("util");
  function Gv(e) {
    return b.nodeStream(e) && b.function_(e.getBoundary);
  }
  n(Gv, "isFormData2");
  async function VB(e, t) {
    if (t && "content-length" in t)
      return Number(t["content-length"]);
    if (!e)
      return 0;
    if (b.string(e))
      return HB.Buffer.byteLength(e);
    if (b.buffer(e))
      return e.length;
    if (Gv(e))
      return (0, zB.promisify)(e.getLength.bind(e))();
  }
  n(VB, "getBodySize");
  function Jv(e, t, r) {
    let i = {};
    for (let s of r) {
      let o = /* @__PURE__ */ n((...u) => {
        t.emit(s, ...u);
      }, "eventFunction");
      i[s] = o, e.on(s, o);
    }
    return () => {
      for (let [s, o] of Object.entries(i))
        e.off(s, o);
    };
  }
  n(Jv, "proxyEvents");
  var GB = we(require("net"), 1);
  function JB() {
    let e = [];
    return {
      once(t, r, i) {
        t.once(r, i), e.push({ origin: t, event: r, fn: i });
      },
      unhandleAll() {
        for (let t of e) {
          let { origin: r, event: i, fn: s } = t;
          r.removeListener(i, s);
        }
        e.length = 0;
      }
    };
  }
  n(JB, "unhandle");
  var Dv = Symbol("reentry"), YB = /* @__PURE__ */ n(() => {
  }, "noop"), Yv = class extends Error {
    static {
      n(this, "TimeoutError2");
    }
    constructor(e, t) {
      super(`Timeout awaiting '${t}' for ${e}ms`), Object.defineProperty(this, "event", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
      }), Object.defineProperty(this, "code", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.name = "TimeoutError", this.code = "ETIMEDOUT";
    }
  };
  function KB(e, t, r) {
    if (Dv in e)
      return YB;
    e[Dv] = !0;
    let i = [], { once: s, unhandleAll: o } = JB(), u = /* @__PURE__ */ n((v, y, _) => {
      var C;
      let w = setTimeout(y, v, v, _);
      (C = w.unref) == null || C.call(w);
      let E = /* @__PURE__ */ n(() => {
        clearTimeout(w);
      }, "cancel");
      return i.push(E), E;
    }, "addTimeout"), { host: a, hostname: l } = r, c = /* @__PURE__ */ n((v, y) => {
      e.destroy(new Yv(v, y));
    }, "timeoutHandler"), h = /* @__PURE__ */ n(() => {
      for (let v of i)
        v();
      o();
    }, "cancelTimeouts");
    if (e.once("error", (v) => {
      if (h(), e.listenerCount("error") === 0)
        throw v;
    }), typeof t.request < "u") {
      let v = u(t.request, c, "request");
      s(e, "response", (y) => {
        s(y, "end", v);
      });
    }
    if (typeof t.socket < "u") {
      let { socket: v } = t, y = /* @__PURE__ */ n(() => {
        c(v, "socket");
      }, "socketTimeoutHandler");
      e.setTimeout(v, y), i.push(() => {
        e.removeListener("timeout", y);
      });
    }
    let p = typeof t.lookup < "u", d = typeof t.connect < "u", f = typeof t.secureConnect < "u", m = typeof t.send < "u";
    return (p || d || f || m) && s(e, "socket", (v) => {
      let { socketPath: y } = e;
      if (v.connecting) {
        let _ = !!(y ?? GB.default.isIP(l ?? a ?? "") !== 0);
        if (p && !_ && typeof v.address().address > "u") {
          let C = u(t.lookup, c, "lookup");
          s(v, "lookup", C);
        }
        if (d) {
          let C = /* @__PURE__ */ n(() => u(t.connect, c, "connect"), "timeConnect");
          _ ? s(v, "connect", C()) : s(v, "lookup", (w) => {
            w === null && s(v, "connect", C());
          });
        }
        f && r.protocol === "https:" && s(v, "connect", () => {
          let C = u(t.secureConnect, c, "secureConnect");
          s(v, "secureConnect", C);
        });
      }
      if (m) {
        let _ = /* @__PURE__ */ n(() => u(t.send, c, "send"), "timeRequest");
        v.connecting ? s(v, "connect", () => {
          s(e, "upload-complete", _());
        }) : s(e, "upload-complete", _());
      }
    }), typeof t.response < "u" && s(e, "upload-complete", () => {
      let v = u(t.response, c, "response");
      s(e, "response", v);
    }), typeof t.read < "u" && s(e, "response", (v) => {
      let y = u(t.read, c, "read");
      s(v, "end", y);
    }), h;
  }
  n(KB, "timedOut");
  function QB(e) {
    e = e;
    let t = {
      protocol: e.protocol,
      hostname: b.string(e.hostname) && e.hostname.startsWith("[") ? e.hostname.slice(1, -1) : e.hostname,
      host: e.host,
      hash: e.hash,
      search: e.search,
      pathname: e.pathname,
      href: e.href,
      path: `${e.pathname || ""}${e.search || ""}`
    };
    return b.string(e.port) && e.port.length > 0 && (t.port = Number(e.port)), (e.username || e.password) && (t.auth = `${e.username || ""}:${e.
    password || ""}`), t;
  }
  n(QB, "urlToOptions");
  var XB = class {
    static {
      n(this, "WeakableMap");
    }
    constructor() {
      Object.defineProperty(this, "weakMap", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "map", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this.weakMap = /* @__PURE__ */ new WeakMap(), this.map = /* @__PURE__ */ new Map();
    }
    set(e, t) {
      typeof e == "object" ? this.weakMap.set(e, t) : this.map.set(e, t);
    }
    get(e) {
      return typeof e == "object" ? this.weakMap.get(e) : this.map.get(e);
    }
    has(e) {
      return typeof e == "object" ? this.weakMap.has(e) : this.map.has(e);
    }
  }, ZB = /* @__PURE__ */ n(({ attemptCount: e, retryOptions: t, error: r, retryAfter: i, computedValue: s }) => {
    if (r.name === "RetryError")
      return 1;
    if (e > t.limit)
      return 0;
    let o = t.methods.includes(r.options.method), u = t.errorCodes.includes(r.code), a = r.response && t.statusCodes.includes(r.response.statusCode);
    if (!o || !u && !a)
      return 0;
    if (r.response) {
      if (i)
        return i > s ? 0 : i;
      if (r.response.statusCode === 413)
        return 0;
    }
    let l = Math.random() * t.noise;
    return Math.min(2 ** (e - 1) * 1e3, t.backoffLimit) + l;
  }, "calculateRetryDelay"), eO = ZB, tO = we(require("process"), 1), Mc = require("util"), _r = require("url"), rO = require("tls"), iO = we(
  require("http"), 1), nO = we(require("https"), 1), fi = require("dns"), jc = require("util"), sO = we(require("os"), 1), { Resolver: mv } = fi.
  promises, ci = Symbol("cacheableLookupCreateConnection"), Ic = Symbol("cacheableLookupInstance"), yv = Symbol("expires"), oO = typeof fi.ALL ==
  "number", gv = /* @__PURE__ */ n((e) => {
    if (!(e && typeof e.createConnection == "function"))
      throw new Error("Expected an Agent instance as the first argument");
  }, "verifyAgent"), uO = /* @__PURE__ */ n((e) => {
    for (let t of e)
      t.family !== 6 && (t.address = `::ffff:${t.address}`, t.family = 6);
  }, "map4to6"), bv = /* @__PURE__ */ n(() => {
    let e = !1, t = !1;
    for (let r of Object.values(sO.default.networkInterfaces()))
      for (let i of r)
        if (!i.internal && (i.family === "IPv6" ? t = !0 : e = !0, e && t))
          return { has4: e, has6: t };
    return { has4: e, has6: t };
  }, "getIfaceInfo"), aO = /* @__PURE__ */ n((e) => Symbol.iterator in e, "isIterable"), jo = /* @__PURE__ */ n((e) => e.catch((t) => {
    if (t.code === "ENODATA" || t.code === "ENOTFOUND" || t.code === "ENOENT")
      return [];
    throw t;
  }), "ignoreNoResultErrors"), wv = { ttl: !0 }, lO = { all: !0 }, cO = { all: !0, family: 4 }, fO = { all: !0, family: 6 }, hO = class {
    static {
      n(this, "CacheableLookup");
    }
    constructor({
      cache: e = /* @__PURE__ */ new Map(),
      maxTtl: t = 1 / 0,
      fallbackDuration: r = 3600,
      errorTtl: i = 0.15,
      resolver: s = new mv(),
      lookup: o = fi.lookup
    } = {}) {
      if (this.maxTtl = t, this.errorTtl = i, this._cache = e, this._resolver = s, this._dnsLookup = o && (0, jc.promisify)(o), this.stats =
      {
        cache: 0,
        query: 0
      }, this._resolver instanceof mv ? (this._resolve4 = this._resolver.resolve4.bind(this._resolver), this._resolve6 = this._resolver.resolve6.
      bind(this._resolver)) : (this._resolve4 = (0, jc.promisify)(this._resolver.resolve4.bind(this._resolver)), this._resolve6 = (0, jc.promisify)(
      this._resolver.resolve6.bind(this._resolver))), this._iface = bv(), this._pending = {}, this._nextRemovalTime = !1, this._hostnamesToFallback =
      /* @__PURE__ */ new Set(), this.fallbackDuration = r, r > 0) {
        let u = setInterval(() => {
          this._hostnamesToFallback.clear();
        }, r * 1e3);
        u.unref && u.unref(), this._fallbackInterval = u;
      }
      this.lookup = this.lookup.bind(this), this.lookupAsync = this.lookupAsync.bind(this);
    }
    set servers(e) {
      this.clear(), this._resolver.setServers(e);
    }
    get servers() {
      return this._resolver.getServers();
    }
    lookup(e, t, r) {
      if (typeof t == "function" ? (r = t, t = {}) : typeof t == "number" && (t = {
        family: t
      }), !r)
        throw new Error("Callback must be a function.");
      this.lookupAsync(e, t).then((i) => {
        t.all ? r(null, i) : r(null, i.address, i.family, i.expires, i.ttl, i.source);
      }, r);
    }
    async lookupAsync(e, t = {}) {
      typeof t == "number" && (t = {
        family: t
      });
      let r = await this.query(e);
      if (t.family === 6) {
        let i = r.filter((s) => s.family === 6);
        t.hints & fi.V4MAPPED && (oO && t.hints & fi.ALL || i.length === 0) ? uO(r) : r = i;
      } else t.family === 4 && (r = r.filter((i) => i.family === 4));
      if (t.hints & fi.ADDRCONFIG) {
        let { _iface: i } = this;
        r = r.filter((s) => s.family === 6 ? i.has6 : i.has4);
      }
      if (r.length === 0) {
        let i = new Error(`cacheableLookup ENOTFOUND ${e}`);
        throw i.code = "ENOTFOUND", i.hostname = e, i;
      }
      return t.all ? r : r[0];
    }
    async query(e) {
      let t = "cache", r = await this._cache.get(e);
      if (r && this.stats.cache++, !r) {
        let i = this._pending[e];
        if (i)
          this.stats.cache++, r = await i;
        else {
          t = "query";
          let s = this.queryAndCache(e);
          this._pending[e] = s, this.stats.query++;
          try {
            r = await s;
          } finally {
            delete this._pending[e];
          }
        }
      }
      return r = r.map((i) => ({ ...i, source: t })), r;
    }
    async _resolve(e) {
      let [t, r] = await Promise.all([
        jo(this._resolve4(e, wv)),
        jo(this._resolve6(e, wv))
      ]), i = 0, s = 0, o = 0, u = Date.now();
      for (let a of t)
        a.family = 4, a.expires = u + a.ttl * 1e3, i = Math.max(i, a.ttl);
      for (let a of r)
        a.family = 6, a.expires = u + a.ttl * 1e3, s = Math.max(s, a.ttl);
      return t.length > 0 ? r.length > 0 ? o = Math.min(i, s) : o = i : o = s, {
        entries: [
          ...t,
          ...r
        ],
        cacheTtl: o
      };
    }
    async _lookup(e) {
      try {
        let [t, r] = await Promise.all([
          // Passing {all: true} doesn't return all IPv4 and IPv6 entries.
          // See https://github.com/szmarczak/cacheable-lookup/issues/42
          jo(this._dnsLookup(e, cO)),
          jo(this._dnsLookup(e, fO))
        ]);
        return {
          entries: [
            ...t,
            ...r
          ],
          cacheTtl: 0
        };
      } catch {
        return {
          entries: [],
          cacheTtl: 0
        };
      }
    }
    async _set(e, t, r) {
      if (this.maxTtl > 0 && r > 0) {
        r = Math.min(r, this.maxTtl) * 1e3, t[yv] = Date.now() + r;
        try {
          await this._cache.set(e, t, r);
        } catch (i) {
          this.lookupAsync = async () => {
            let s = new Error("Cache Error. Please recreate the CacheableLookup instance.");
            throw s.cause = i, s;
          };
        }
        aO(this._cache) && this._tick(r);
      }
    }
    async queryAndCache(e) {
      if (this._hostnamesToFallback.has(e))
        return this._dnsLookup(e, lO);
      let t = await this._resolve(e);
      t.entries.length === 0 && this._dnsLookup && (t = await this._lookup(e), t.entries.length !== 0 && this.fallbackDuration > 0 && this._hostnamesToFallback.
      add(e));
      let r = t.entries.length === 0 ? this.errorTtl : t.cacheTtl;
      return await this._set(e, t.entries, r), t.entries;
    }
    _tick(e) {
      let t = this._nextRemovalTime;
      (!t || e < t) && (clearTimeout(this._removalTimeout), this._nextRemovalTime = e, this._removalTimeout = setTimeout(() => {
        this._nextRemovalTime = !1;
        let r = 1 / 0, i = Date.now();
        for (let [s, o] of this._cache) {
          let u = o[yv];
          i >= u ? this._cache.delete(s) : u < r && (r = u);
        }
        r !== 1 / 0 && this._tick(r - i);
      }, e), this._removalTimeout.unref && this._removalTimeout.unref());
    }
    install(e) {
      if (gv(e), ci in e)
        throw new Error("CacheableLookup has been already installed");
      e[ci] = e.createConnection, e[Ic] = this, e.createConnection = (t, r) => ("lookup" in t || (t.lookup = this.lookup), e[ci](t, r));
    }
    uninstall(e) {
      if (gv(e), e[ci]) {
        if (e[Ic] !== this)
          throw new Error("The agent is not owned by this CacheableLookup instance");
        e.createConnection = e[ci], delete e[ci], delete e[Ic];
      }
    }
    updateInterfaceInfo() {
      let { _iface: e } = this;
      this._iface = bv(), (e.has4 && !this._iface.has4 || e.has6 && !this._iface.has6) && this._cache.clear();
    }
    clear(e) {
      if (e) {
        this._cache.delete(e);
        return;
      }
      this._cache.clear();
    }
  }, dO = we(Uk(), 1);
  function pO(e) {
    let t = [], r = e.split(",");
    for (let i of r) {
      let [s, ...o] = i.split(";"), u = s.trim();
      if (u[0] !== "<" || u[u.length - 1] !== ">")
        throw new Error(`Invalid format of the Link header reference: ${u}`);
      let a = u.slice(1, -1), l = {};
      if (o.length === 0)
        throw new Error(`Unexpected end of Link header parameters: ${o.join(";")}`);
      for (let c of o) {
        let h = c.trim(), p = h.indexOf("=");
        if (p === -1)
          throw new Error(`Failed to parse Link header: ${e}`);
        let d = h.slice(0, p).trim(), f = h.slice(p + 1).trim();
        l[d] = f;
      }
      t.push({
        reference: a,
        parameters: l
      });
    }
    return t;
  }
  n(pO, "parseLinkHeader");
  var [vv, DO] = tO.default.versions.node.split(".").map(Number);
  function mO(e) {
    for (let t in e) {
      let r = e[t];
      S.any([b.string, b.number, b.boolean, b.null_, b.undefined], r);
    }
  }
  n(mO, "validateSearchParameters");
  var yO = /* @__PURE__ */ new Map(), Io, gO = /* @__PURE__ */ n(() => Io || (Io = new hO(), Io), "getGlobalDnsCache"), bO = {
    request: void 0,
    agent: {
      http: void 0,
      https: void 0,
      http2: void 0
    },
    h2session: void 0,
    decompress: !0,
    timeout: {
      connect: void 0,
      lookup: void 0,
      read: void 0,
      request: void 0,
      response: void 0,
      secureConnect: void 0,
      send: void 0,
      socket: void 0
    },
    prefixUrl: "",
    body: void 0,
    form: void 0,
    json: void 0,
    cookieJar: void 0,
    ignoreInvalidCookies: !1,
    searchParams: void 0,
    dnsLookup: void 0,
    dnsCache: void 0,
    context: {},
    hooks: {
      init: [],
      beforeRequest: [],
      beforeError: [],
      beforeRedirect: [],
      beforeRetry: [],
      afterResponse: []
    },
    followRedirect: !0,
    maxRedirects: 10,
    cache: void 0,
    throwHttpErrors: !0,
    username: "",
    password: "",
    http2: !1,
    allowGetBody: !1,
    headers: {
      "user-agent": "got (https://github.com/sindresorhus/got)"
    },
    methodRewriting: !1,
    dnsLookupIpVersion: void 0,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
      limit: 2,
      methods: [
        "GET",
        "PUT",
        "HEAD",
        "DELETE",
        "OPTIONS",
        "TRACE"
      ],
      statusCodes: [
        408,
        413,
        429,
        500,
        502,
        503,
        504,
        521,
        522,
        524
      ],
      errorCodes: [
        "ETIMEDOUT",
        "ECONNRESET",
        "EADDRINUSE",
        "ECONNREFUSED",
        "EPIPE",
        "ENOTFOUND",
        "ENETUNREACH",
        "EAI_AGAIN"
      ],
      maxRetryAfter: void 0,
      calculateDelay: /* @__PURE__ */ n(({ computedValue: e }) => e, "calculateDelay"),
      backoffLimit: Number.POSITIVE_INFINITY,
      noise: 100
    },
    localAddress: void 0,
    method: "GET",
    createConnection: void 0,
    cacheOptions: {
      shared: void 0,
      cacheHeuristic: void 0,
      immutableMinTimeToLive: void 0,
      ignoreCargoCult: void 0
    },
    https: {
      alpnProtocols: void 0,
      rejectUnauthorized: void 0,
      checkServerIdentity: void 0,
      certificateAuthority: void 0,
      key: void 0,
      certificate: void 0,
      passphrase: void 0,
      pfx: void 0,
      ciphers: void 0,
      honorCipherOrder: void 0,
      minVersion: void 0,
      maxVersion: void 0,
      signatureAlgorithms: void 0,
      tlsSessionLifetime: void 0,
      dhparam: void 0,
      ecdhCurve: void 0,
      certificateRevocationLists: void 0
    },
    encoding: void 0,
    resolveBodyOnly: !1,
    isStream: !1,
    responseType: "text",
    url: void 0,
    pagination: {
      transform(e) {
        return e.request.options.responseType === "json" ? e.body : JSON.parse(e.body);
      },
      paginate({ response: e }) {
        let t = e.headers.link;
        if (typeof t != "string" || t.trim() === "")
          return !1;
        let i = pO(t).find((s) => s.parameters.rel === "next" || s.parameters.rel === '"next"');
        return i ? {
          url: new _r.URL(i.reference, e.url)
        } : !1;
      },
      filter: /* @__PURE__ */ n(() => !0, "filter"),
      shouldContinue: /* @__PURE__ */ n(() => !0, "shouldContinue"),
      countLimit: Number.POSITIVE_INFINITY,
      backoff: 0,
      requestLimit: 1e4,
      stackAllItems: !1
    },
    setHost: !0,
    maxHeaderSize: void 0,
    signal: void 0,
    enableUnixSockets: !0
  }, wO = /* @__PURE__ */ n((e) => {
    let { hooks: t, retry: r } = e, i = {
      ...e,
      context: { ...e.context },
      cacheOptions: { ...e.cacheOptions },
      https: { ...e.https },
      agent: { ...e.agent },
      headers: { ...e.headers },
      retry: {
        ...r,
        errorCodes: [...r.errorCodes],
        methods: [...r.methods],
        statusCodes: [...r.statusCodes]
      },
      timeout: { ...e.timeout },
      hooks: {
        init: [...t.init],
        beforeRequest: [...t.beforeRequest],
        beforeError: [...t.beforeError],
        beforeRedirect: [...t.beforeRedirect],
        beforeRetry: [...t.beforeRetry],
        afterResponse: [...t.afterResponse]
      },
      searchParams: e.searchParams ? new _r.URLSearchParams(e.searchParams) : void 0,
      pagination: { ...e.pagination }
    };
    return i.url !== void 0 && (i.prefixUrl = ""), i;
  }, "cloneInternals"), vO = /* @__PURE__ */ n((e) => {
    let { hooks: t, retry: r } = e, i = { ...e };
    return b.object(e.context) && (i.context = { ...e.context }), b.object(e.cacheOptions) && (i.cacheOptions = { ...e.cacheOptions }), b.object(
    e.https) && (i.https = { ...e.https }), b.object(e.cacheOptions) && (i.cacheOptions = { ...i.cacheOptions }), b.object(e.agent) && (i.agent =
    { ...e.agent }), b.object(e.headers) && (i.headers = { ...e.headers }), b.object(r) && (i.retry = { ...r }, b.array(r.errorCodes) && (i.
    retry.errorCodes = [...r.errorCodes]), b.array(r.methods) && (i.retry.methods = [...r.methods]), b.array(r.statusCodes) && (i.retry.statusCodes =
    [...r.statusCodes])), b.object(e.timeout) && (i.timeout = { ...e.timeout }), b.object(t) && (i.hooks = {
      ...t
    }, b.array(t.init) && (i.hooks.init = [...t.init]), b.array(t.beforeRequest) && (i.hooks.beforeRequest = [...t.beforeRequest]), b.array(
    t.beforeError) && (i.hooks.beforeError = [...t.beforeError]), b.array(t.beforeRedirect) && (i.hooks.beforeRedirect = [...t.beforeRedirect]),
    b.array(t.beforeRetry) && (i.hooks.beforeRetry = [...t.beforeRetry]), b.array(t.afterResponse) && (i.hooks.afterResponse = [...t.afterResponse])),
    b.object(e.pagination) && (i.pagination = { ...e.pagination }), i;
  }, "cloneRaw"), _O = /* @__PURE__ */ n((e) => {
    let t = [e.timeout.socket, e.timeout.connect, e.timeout.lookup, e.timeout.request, e.timeout.secureConnect].filter((r) => typeof r == "n\
umber");
    if (t.length > 0)
      return Math.min(...t);
  }, "getHttp2TimeoutOption"), _v = /* @__PURE__ */ n((e, t, r) => {
    var i;
    let s = (i = e.hooks) == null ? void 0 : i.init;
    if (s)
      for (let o of s)
        o(t, r);
  }, "init"), jt = class {
    static {
      n(this, "Options");
    }
    constructor(e, t, r) {
      if (Object.defineProperty(this, "_unixOptions", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_internals", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_merging", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_init", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), S.any([b.string, b.urlInstance, b.object, b.undefined], e), S.any([b.object, b.undefined], t), S.any([b.object, b.undefined], r), e instanceof
      jt || t instanceof jt)
        throw new TypeError("The defaults must be passed as the third argument");
      this._internals = wO(r?._internals ?? r ?? bO), this._init = [...r?._init ?? []], this._merging = !1, this._unixOptions = void 0;
      try {
        if (b.plainObject(e))
          try {
            this.merge(e), this.merge(t);
          } finally {
            this.url = e.url;
          }
        else
          try {
            this.merge(t);
          } finally {
            if (t?.url !== void 0)
              if (e === void 0)
                this.url = t.url;
              else
                throw new TypeError("The `url` option is mutually exclusive with the `input` argument");
            else e !== void 0 && (this.url = e);
          }
      } catch (i) {
        throw i.options = this, i;
      }
    }
    merge(e) {
      if (e) {
        if (e instanceof jt) {
          for (let t of e._init)
            this.merge(t);
          return;
        }
        e = vO(e), _v(this, e, this), _v(e, e, this), this._merging = !0, "isStream" in e && (this.isStream = e.isStream);
        try {
          let t = !1;
          for (let r in e)
            if (!(r === "mutableDefaults" || r === "handlers") && r !== "url") {
              if (!(r in this))
                throw new Error(`Unexpected option: ${r}`);
              this[r] = e[r], t = !0;
            }
          t && this._init.push(e);
        } finally {
          this._merging = !1;
        }
      }
    }
    /**
        Custom request function.
        The main purpose of this is to [support HTTP2 using a wrapper](https://github.com/szmarczak/http2-wrapper).
    
        @default http.request | https.request
        */
    get request() {
      return this._internals.request;
    }
    set request(e) {
      S.any([b.function_, b.undefined], e), this._internals.request = e;
    }
    /**
        An object representing `http`, `https` and `http2` keys for [`http.Agent`](https://nodejs.org/api/http.html#http_class_http_agent), [`https.Agent`](https://nodejs.org/api/https.html#https_class_https_agent) and [`http2wrapper.Agent`](https://github.com/szmarczak/http2-wrapper#new-http2agentoptions) instance.
        This is necessary because a request to one protocol might redirect to another.
        In such a scenario, Got will switch over to the right protocol agent for you.
    
        If a key is not present, it will default to a global agent.
    
        @example
        ```
        import got from 'got';
        import HttpAgent from 'agentkeepalive';
    
        const {HttpsAgent} = HttpAgent;
    
        await got('https://sindresorhus.com', {
            agent: {
                http: new HttpAgent(),
                https: new HttpsAgent()
            }
        });
        ```
        */
    get agent() {
      return this._internals.agent;
    }
    set agent(e) {
      S.plainObject(e);
      for (let t in e) {
        if (!(t in this._internals.agent))
          throw new TypeError(`Unexpected agent option: ${t}`);
        S.any([b.object, b.undefined], e[t]);
      }
      this._merging ? Object.assign(this._internals.agent, e) : this._internals.agent = { ...e };
    }
    get h2session() {
      return this._internals.h2session;
    }
    set h2session(e) {
      this._internals.h2session = e;
    }
    /**
        Decompress the response automatically.
    
        This will set the `accept-encoding` header to `gzip, deflate, br` unless you set it yourself.
    
        If this is disabled, a compressed response is returned as a `Buffer`.
        This may be useful if you want to handle decompression yourself or stream the raw compressed data.
    
        @default true
        */
    get decompress() {
      return this._internals.decompress;
    }
    set decompress(e) {
      S.boolean(e), this._internals.decompress = e;
    }
    /**
        Milliseconds to wait for the server to end the response before aborting the request with `got.TimeoutError` error (a.k.a. `request` property).
        By default, there's no timeout.
    
        This also accepts an `object` with the following fields to constrain the duration of each phase of the request lifecycle:
    
        - `lookup` starts when a socket is assigned and ends when the hostname has been resolved.
            Does not apply when using a Unix domain socket.
        - `connect` starts when `lookup` completes (or when the socket is assigned if lookup does not apply to the request) and ends when the socket is connected.
        - `secureConnect` starts when `connect` completes and ends when the handshaking process completes (HTTPS only).
        - `socket` starts when the socket is connected. See [request.setTimeout](https://nodejs.org/api/http.html#http_request_settimeout_timeout_callback).
        - `response` starts when the request has been written to the socket and ends when the response headers are received.
        - `send` starts when the socket is connected and ends with the request has been written to the socket.
        - `request` starts when the request is initiated and ends when the response's end event fires.
        */
    get timeout() {
      return this._internals.timeout;
    }
    set timeout(e) {
      S.plainObject(e);
      for (let t in e) {
        if (!(t in this._internals.timeout))
          throw new Error(`Unexpected timeout option: ${t}`);
        S.any([b.number, b.undefined], e[t]);
      }
      this._merging ? Object.assign(this._internals.timeout, e) : this._internals.timeout = { ...e };
    }
    /**
        When specified, `prefixUrl` will be prepended to `url`.
        The prefix can be any valid URL, either relative or absolute.
        A trailing slash `/` is optional - one will be added automatically.
    
        __Note__: `prefixUrl` will be ignored if the `url` argument is a URL instance.
    
        __Note__: Leading slashes in `input` are disallowed when using this option to enforce consistency and avoid confusion.
        For example, when the prefix URL is `https://example.com/foo` and the input is `/bar`, there's ambiguity whether the resulting URL would become `https://example.com/foo/bar` or `https://example.com/bar`.
        The latter is used by browsers.
    
        __Tip__: Useful when used with `got.extend()` to create niche-specific Got instances.
    
        __Tip__: You can change `prefixUrl` using hooks as long as the URL still includes the `prefixUrl`.
        If the URL doesn't include it anymore, it will throw.
    
        @example
        ```
        import got from 'got';
    
        await got('unicorn', {prefixUrl: 'https://cats.com'});
        //=> 'https://cats.com/unicorn'
    
        const instance = got.extend({
            prefixUrl: 'https://google.com'
        });
    
        await instance('unicorn', {
            hooks: {
                beforeRequest: [
                    options => {
                        options.prefixUrl = 'https://cats.com';
                    }
                ]
            }
        });
        //=> 'https://cats.com/unicorn'
        ```
        */
    get prefixUrl() {
      return this._internals.prefixUrl;
    }
    set prefixUrl(e) {
      if (S.any([b.string, b.urlInstance], e), e === "") {
        this._internals.prefixUrl = "";
        return;
      }
      if (e = e.toString(), e.endsWith("/") || (e += "/"), this._internals.prefixUrl && this._internals.url) {
        let { href: t } = this._internals.url;
        this._internals.url.href = e + t.slice(this._internals.prefixUrl.length);
      }
      this._internals.prefixUrl = e;
    }
    /**
        __Note #1__: The `body` option cannot be used with the `json` or `form` option.
    
        __Note #2__: If you provide this option, `got.stream()` will be read-only.
    
        __Note #3__: If you provide a payload with the `GET` or `HEAD` method, it will throw a `TypeError` unless the method is `GET` and the `allowGetBody` option is set to `true`.
    
        __Note #4__: This option is not enumerable and will not be merged with the instance defaults.
    
        The `content-length` header will be automatically set if `body` is a `string` / `Buffer` / [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) / [`form-data` instance](https://github.com/form-data/form-data), and `content-length` and `transfer-encoding` are not manually set in `options.headers`.
    
        Since Got 12, the `content-length` is not automatically set when `body` is a `fs.createReadStream`.
        */
    get body() {
      return this._internals.body;
    }
    set body(e) {
      S.any([b.string, b.buffer, b.nodeStream, b.generator, b.asyncGenerator, $c, b.undefined], e), b.nodeStream(e) && S.truthy(e.readable),
      e !== void 0 && (S.undefined(this._internals.form), S.undefined(this._internals.json)), this._internals.body = e;
    }
    /**
        The form body is converted to a query string using [`(new URLSearchParams(object)).toString()`](https://nodejs.org/api/url.html#url_constructor_new_urlsearchparams_obj).
    
        If the `Content-Type` header is not present, it will be set to `application/x-www-form-urlencoded`.
    
        __Note #1__: If you provide this option, `got.stream()` will be read-only.
    
        __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
        */
    get form() {
      return this._internals.form;
    }
    set form(e) {
      S.any([b.plainObject, b.undefined], e), e !== void 0 && (S.undefined(this._internals.body), S.undefined(this._internals.json)), this._internals.
      form = e;
    }
    /**
        JSON body. If the `Content-Type` header is not set, it will be set to `application/json`.
    
        __Note #1__: If you provide this option, `got.stream()` will be read-only.
    
        __Note #2__: This option is not enumerable and will not be merged with the instance defaults.
        */
    get json() {
      return this._internals.json;
    }
    set json(e) {
      e !== void 0 && (S.undefined(this._internals.body), S.undefined(this._internals.form)), this._internals.json = e;
    }
    /**
        The URL to request, as a string, a [`https.request` options object](https://nodejs.org/api/https.html#https_https_request_options_callback), or a [WHATWG `URL`](https://nodejs.org/api/url.html#url_class_url).
    
        Properties from `options` will override properties in the parsed `url`.
    
        If no protocol is specified, it will throw a `TypeError`.
    
        __Note__: The query string is **not** parsed as search params.
    
        @example
        ```
        await got('https://example.com/?query=a b'); //=> https://example.com/?query=a%20b
        await got('https://example.com/', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
    
        // The query string is overridden by `searchParams`
        await got('https://example.com/?query=a b', {searchParams: {query: 'a b'}}); //=> https://example.com/?query=a+b
        ```
        */
    get url() {
      return this._internals.url;
    }
    set url(e) {
      if (S.any([b.string, b.urlInstance, b.undefined], e), e === void 0) {
        this._internals.url = void 0;
        return;
      }
      if (b.string(e) && e.startsWith("/"))
        throw new Error("`url` must not start with a slash");
      let t = `${this.prefixUrl}${e.toString()}`, r = new _r.URL(t);
      if (this._internals.url = r, decodeURI(t), r.protocol === "unix:" && (r.href = `http://unix${r.pathname}${r.search}`), r.protocol !== "\
http:" && r.protocol !== "https:") {
        let i = new Error(`Unsupported protocol: ${r.protocol}`);
        throw i.code = "ERR_UNSUPPORTED_PROTOCOL", i;
      }
      if (this._internals.username && (r.username = this._internals.username, this._internals.username = ""), this._internals.password && (r.
      password = this._internals.password, this._internals.password = ""), this._internals.searchParams && (r.search = this._internals.searchParams.
      toString(), this._internals.searchParams = void 0), r.hostname === "unix") {
        if (!this._internals.enableUnixSockets)
          throw new Error("Using UNIX domain sockets but option `enableUnixSockets` is not enabled");
        let i = /(?<socketPath>.+?):(?<path>.+)/.exec(`${r.pathname}${r.search}`);
        if (i?.groups) {
          let { socketPath: s, path: o } = i.groups;
          this._unixOptions = {
            socketPath: s,
            path: o,
            host: ""
          };
        } else
          this._unixOptions = void 0;
        return;
      }
      this._unixOptions = void 0;
    }
    /**
        Cookie support. You don't have to care about parsing or how to store them.
    
        __Note__: If you provide this option, `options.headers.cookie` will be overridden.
        */
    get cookieJar() {
      return this._internals.cookieJar;
    }
    set cookieJar(e) {
      if (S.any([b.object, b.undefined], e), e === void 0) {
        this._internals.cookieJar = void 0;
        return;
      }
      let { setCookie: t, getCookieString: r } = e;
      S.function_(t), S.function_(r), t.length === 4 && r.length === 0 ? (t = (0, Mc.promisify)(t.bind(e)), r = (0, Mc.promisify)(r.bind(e)),
      this._internals.cookieJar = {
        setCookie: t,
        getCookieString: r
      }) : this._internals.cookieJar = e;
    }
    /**
        You can abort the `request` using [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
    
        *Requires Node.js 16 or later.*
    
        @example
        ```
        import got from 'got';
    
        const abortController = new AbortController();
    
        const request = got('https://httpbin.org/anything', {
            signal: abortController.signal
        });
    
        setTimeout(() => {
            abortController.abort();
        }, 100);
        ```
        */
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    get signal() {
      return this._internals.signal;
    }
    // TODO: Replace `any` with `AbortSignal` when targeting Node 16.
    set signal(e) {
      S.object(e), this._internals.signal = e;
    }
    /**
        Ignore invalid cookies instead of throwing an error.
        Only useful when the `cookieJar` option has been set. Not recommended.
    
        @default false
        */
    get ignoreInvalidCookies() {
      return this._internals.ignoreInvalidCookies;
    }
    set ignoreInvalidCookies(e) {
      S.boolean(e), this._internals.ignoreInvalidCookies = e;
    }
    /**
        Query string that will be added to the request URL.
        This will override the query string in `url`.
    
        If you need to pass in an array, you can do it using a `URLSearchParams` instance.
    
        @example
        ```
        import got from 'got';
    
        const searchParams = new URLSearchParams([['key', 'a'], ['key', 'b']]);
    
        await got('https://example.com', {searchParams});
    
        console.log(searchParams.toString());
        //=> 'key=a&key=b'
        ```
        */
    get searchParams() {
      return this._internals.url ? this._internals.url.searchParams : (this._internals.searchParams === void 0 && (this._internals.searchParams =
      new _r.URLSearchParams()), this._internals.searchParams);
    }
    set searchParams(e) {
      S.any([b.string, b.object, b.undefined], e);
      let t = this._internals.url;
      if (e === void 0) {
        this._internals.searchParams = void 0, t && (t.search = "");
        return;
      }
      let r = this.searchParams, i;
      if (b.string(e))
        i = new _r.URLSearchParams(e);
      else if (e instanceof _r.URLSearchParams)
        i = e;
      else {
        mO(e), i = new _r.URLSearchParams();
        for (let s in e) {
          let o = e[s];
          o === null ? i.append(s, "") : o === void 0 ? r.delete(s) : i.append(s, o);
        }
      }
      if (this._merging) {
        for (let s of i.keys())
          r.delete(s);
        for (let [s, o] of i)
          r.append(s, o);
      } else t ? t.search = r.toString() : this._internals.searchParams = r;
    }
    get searchParameters() {
      throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    set searchParameters(e) {
      throw new Error("The `searchParameters` option does not exist. Use `searchParams` instead.");
    }
    get dnsLookup() {
      return this._internals.dnsLookup;
    }
    set dnsLookup(e) {
      S.any([b.function_, b.undefined], e), this._internals.dnsLookup = e;
    }
    /**
        An instance of [`CacheableLookup`](https://github.com/szmarczak/cacheable-lookup) used for making DNS lookups.
        Useful when making lots of requests to different *public* hostnames.
    
        `CacheableLookup` uses `dns.resolver4(..)` and `dns.resolver6(...)` under the hood and fall backs to `dns.lookup(...)` when the first two fail, which may lead to additional delay.
    
        __Note__: This should stay disabled when making requests to internal hostnames such as `localhost`, `database.local` etc.
    
        @default false
        */
    get dnsCache() {
      return this._internals.dnsCache;
    }
    set dnsCache(e) {
      S.any([b.object, b.boolean, b.undefined], e), e === !0 ? this._internals.dnsCache = gO() : e === !1 ? this._internals.dnsCache = void 0 :
      this._internals.dnsCache = e;
    }
    /**
        User data. `context` is shallow merged and enumerable. If it contains non-enumerable properties they will NOT be merged.
    
        @example
        ```
        import got from 'got';
    
        const instance = got.extend({
            hooks: {
                beforeRequest: [
                    options => {
                        if (!options.context || !options.context.token) {
                            throw new Error('Token required');
                        }
    
                        options.headers.token = options.context.token;
                    }
                ]
            }
        });
    
        const context = {
            token: 'secret'
        };
    
        const response = await instance('https://httpbin.org/headers', {context});
    
        // Let's see the headers
        console.log(response.body);
        ```
        */
    get context() {
      return this._internals.context;
    }
    set context(e) {
      S.object(e), this._merging ? Object.assign(this._internals.context, e) : this._internals.context = { ...e };
    }
    /**
    Hooks allow modifications during the request lifecycle.
    Hook functions may be async and are run serially.
    */
    get hooks() {
      return this._internals.hooks;
    }
    set hooks(e) {
      S.object(e);
      for (let t in e) {
        if (!(t in this._internals.hooks))
          throw new Error(`Unexpected hook event: ${t}`);
        let r = t, i = e[r];
        if (S.any([b.array, b.undefined], i), i)
          for (let s of i)
            S.function_(s);
        if (this._merging)
          i && this._internals.hooks[r].push(...i);
        else {
          if (!i)
            throw new Error(`Missing hook event: ${t}`);
          this._internals.hooks[t] = [...i];
        }
      }
    }
    /**
        Defines if redirect responses should be followed automatically.
    
        Note that if a `303` is sent by the server in response to any request type (`POST`, `DELETE`, etc.), Got will automatically request the resource pointed to in the location header via `GET`.
        This is in accordance with [the spec](https://tools.ietf.org/html/rfc7231#section-6.4.4). You can optionally turn on this behavior also for other redirect codes - see `methodRewriting`.
    
        @default true
        */
    get followRedirect() {
      return this._internals.followRedirect;
    }
    set followRedirect(e) {
      S.boolean(e), this._internals.followRedirect = e;
    }
    get followRedirects() {
      throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    set followRedirects(e) {
      throw new TypeError("The `followRedirects` option does not exist. Use `followRedirect` instead.");
    }
    /**
        If exceeded, the request will be aborted and a `MaxRedirectsError` will be thrown.
    
        @default 10
        */
    get maxRedirects() {
      return this._internals.maxRedirects;
    }
    set maxRedirects(e) {
      S.number(e), this._internals.maxRedirects = e;
    }
    /**
        A cache adapter instance for storing cached response data.
    
        @default false
        */
    get cache() {
      return this._internals.cache;
    }
    set cache(e) {
      S.any([b.object, b.string, b.boolean, b.undefined], e), e === !0 ? this._internals.cache = yO : e === !1 ? this._internals.cache = void 0 :
      this._internals.cache = e;
    }
    /**
        Determines if a `got.HTTPError` is thrown for unsuccessful responses.
    
        If this is disabled, requests that encounter an error status code will be resolved with the `response` instead of throwing.
        This may be useful if you are checking for resource availability and are expecting error responses.
    
        @default true
        */
    get throwHttpErrors() {
      return this._internals.throwHttpErrors;
    }
    set throwHttpErrors(e) {
      S.boolean(e), this._internals.throwHttpErrors = e;
    }
    get username() {
      let e = this._internals.url, t = e ? e.username : this._internals.username;
      return decodeURIComponent(t);
    }
    set username(e) {
      S.string(e);
      let t = this._internals.url, r = encodeURIComponent(e);
      t ? t.username = r : this._internals.username = r;
    }
    get password() {
      let e = this._internals.url, t = e ? e.password : this._internals.password;
      return decodeURIComponent(t);
    }
    set password(e) {
      S.string(e);
      let t = this._internals.url, r = encodeURIComponent(e);
      t ? t.password = r : this._internals.password = r;
    }
    /**
        If set to `true`, Got will additionally accept HTTP2 requests.
    
        It will choose either HTTP/1.1 or HTTP/2 depending on the ALPN protocol.
    
        __Note__: This option requires Node.js 15.10.0 or newer as HTTP/2 support on older Node.js versions is very buggy.
    
        __Note__: Overriding `options.request` will disable HTTP2 support.
    
        @default false
    
        @example
        ```
        import got from 'got';
    
        const {headers} = await got('https://nghttp2.org/httpbin/anything', {http2: true});
    
        console.log(headers.via);
        //=> '2 nghttpx'
        ```
        */
    get http2() {
      return this._internals.http2;
    }
    set http2(e) {
      S.boolean(e), this._internals.http2 = e;
    }
    /**
        Set this to `true` to allow sending body for the `GET` method.
        However, the [HTTP/2 specification](https://tools.ietf.org/html/rfc7540#section-8.1.3) says that `An HTTP GET request includes request header fields and no payload body`, therefore when using the HTTP/2 protocol this option will have no effect.
        This option is only meant to interact with non-compliant servers when you have no other choice.
    
        __Note__: The [RFC 7231](https://tools.ietf.org/html/rfc7231#section-4.3.1) doesn't specify any particular behavior for the GET method having a payload, therefore __it's considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern)__.
    
        @default false
        */
    get allowGetBody() {
      return this._internals.allowGetBody;
    }
    set allowGetBody(e) {
      S.boolean(e), this._internals.allowGetBody = e;
    }
    /**
        Request headers.
    
        Existing headers will be overwritten. Headers set to `undefined` will be omitted.
    
        @default {}
        */
    get headers() {
      return this._internals.headers;
    }
    set headers(e) {
      S.plainObject(e), this._merging ? Object.assign(this._internals.headers, Nc(e)) : this._internals.headers = Nc(e);
    }
    /**
        Specifies if the HTTP request method should be [rewritten as `GET`](https://tools.ietf.org/html/rfc7231#section-6.4) on redirects.
    
        As the [specification](https://tools.ietf.org/html/rfc7231#section-6.4) prefers to rewrite the HTTP method only on `303` responses, this is Got's default behavior.
        Setting `methodRewriting` to `true` will also rewrite `301` and `302` responses, as allowed by the spec. This is the behavior followed by `curl` and browsers.
    
        __Note__: Got never performs method rewriting on `307` and `308` responses, as this is [explicitly prohibited by the specification](https://www.rfc-editor.org/rfc/rfc7231#section-6.4.7).
    
        @default false
        */
    get methodRewriting() {
      return this._internals.methodRewriting;
    }
    set methodRewriting(e) {
      S.boolean(e), this._internals.methodRewriting = e;
    }
    /**
        Indicates which DNS record family to use.
    
        Values:
        - `undefined`: IPv4 (if present) or IPv6
        - `4`: Only IPv4
        - `6`: Only IPv6
    
        @default undefined
        */
    get dnsLookupIpVersion() {
      return this._internals.dnsLookupIpVersion;
    }
    set dnsLookupIpVersion(e) {
      if (e !== void 0 && e !== 4 && e !== 6)
        throw new TypeError(`Invalid DNS lookup IP version: ${e}`);
      this._internals.dnsLookupIpVersion = e;
    }
    /**
        A function used to parse JSON responses.
    
        @example
        ```
        import got from 'got';
        import Bourne from '@hapi/bourne';
    
        const parsed = await got('https://example.com', {
            parseJson: text => Bourne.parse(text)
        }).json();
    
        console.log(parsed);
        ```
        */
    get parseJson() {
      return this._internals.parseJson;
    }
    set parseJson(e) {
      S.function_(e), this._internals.parseJson = e;
    }
    /**
        A function used to stringify the body of JSON requests.
    
        @example
        ```
        import got from 'got';
    
        await got.post('https://example.com', {
            stringifyJson: object => JSON.stringify(object, (key, value) => {
                if (key.startsWith('_')) {
                    return;
                }
    
                return value;
            }),
            json: {
                some: 'payload',
                _ignoreMe: 1234
            }
        });
        ```
    
        @example
        ```
        import got from 'got';
    
        await got.post('https://example.com', {
            stringifyJson: object => JSON.stringify(object, (key, value) => {
                if (typeof value === 'number') {
                    return value.toString();
                }
    
                return value;
            }),
            json: {
                some: 'payload',
                number: 1
            }
        });
        ```
        */
    get stringifyJson() {
      return this._internals.stringifyJson;
    }
    set stringifyJson(e) {
      S.function_(e), this._internals.stringifyJson = e;
    }
    /**
        An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.
    
        Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).
    
        The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
        The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).
    
        By default, it retries *only* on the specified methods, status codes, and on these network errors:
    
        - `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
        - `ECONNRESET`: Connection was forcibly closed by a peer.
        - `EADDRINUSE`: Could not bind to any free port.
        - `ECONNREFUSED`: Connection was refused by the server.
        - `EPIPE`: The remote side of the stream being written has been closed.
        - `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
        - `ENETUNREACH`: No internet connection.
        - `EAI_AGAIN`: DNS lookup timed out.
    
        __Note__: If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
        __Note__: If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
        */
    get retry() {
      return this._internals.retry;
    }
    set retry(e) {
      if (S.plainObject(e), S.any([b.function_, b.undefined], e.calculateDelay), S.any([b.number, b.undefined], e.maxRetryAfter), S.any([b.number,
      b.undefined], e.limit), S.any([b.array, b.undefined], e.methods), S.any([b.array, b.undefined], e.statusCodes), S.any([b.array, b.undefined],
      e.errorCodes), S.any([b.number, b.undefined], e.noise), e.noise && Math.abs(e.noise) > 100)
        throw new Error(`The maximum acceptable retry noise is +/- 100ms, got ${e.noise}`);
      for (let r in e)
        if (!(r in this._internals.retry))
          throw new Error(`Unexpected retry option: ${r}`);
      this._merging ? Object.assign(this._internals.retry, e) : this._internals.retry = { ...e };
      let { retry: t } = this._internals;
      t.methods = [...new Set(t.methods.map((r) => r.toUpperCase()))], t.statusCodes = [...new Set(t.statusCodes)], t.errorCodes = [...new Set(
      t.errorCodes)];
    }
    /**
        From `http.RequestOptions`.
    
        The IP address used to send the request from.
        */
    get localAddress() {
      return this._internals.localAddress;
    }
    set localAddress(e) {
      S.any([b.string, b.undefined], e), this._internals.localAddress = e;
    }
    /**
        The HTTP method used to make the request.
    
        @default 'GET'
        */
    get method() {
      return this._internals.method;
    }
    set method(e) {
      S.string(e), this._internals.method = e.toUpperCase();
    }
    get createConnection() {
      return this._internals.createConnection;
    }
    set createConnection(e) {
      S.any([b.function_, b.undefined], e), this._internals.createConnection = e;
    }
    /**
        From `http-cache-semantics`
    
        @default {}
        */
    get cacheOptions() {
      return this._internals.cacheOptions;
    }
    set cacheOptions(e) {
      S.plainObject(e), S.any([b.boolean, b.undefined], e.shared), S.any([b.number, b.undefined], e.cacheHeuristic), S.any([b.number, b.undefined],
      e.immutableMinTimeToLive), S.any([b.boolean, b.undefined], e.ignoreCargoCult);
      for (let t in e)
        if (!(t in this._internals.cacheOptions))
          throw new Error(`Cache option \`${t}\` does not exist`);
      this._merging ? Object.assign(this._internals.cacheOptions, e) : this._internals.cacheOptions = { ...e };
    }
    /**
    Options for the advanced HTTPS API.
    */
    get https() {
      return this._internals.https;
    }
    set https(e) {
      S.plainObject(e), S.any([b.boolean, b.undefined], e.rejectUnauthorized), S.any([b.function_, b.undefined], e.checkServerIdentity), S.any(
      [b.string, b.object, b.array, b.undefined], e.certificateAuthority), S.any([b.string, b.object, b.array, b.undefined], e.key), S.any([
      b.string, b.object, b.array, b.undefined], e.certificate), S.any([b.string, b.undefined], e.passphrase), S.any([b.string, b.buffer, b.
      array, b.undefined], e.pfx), S.any([b.array, b.undefined], e.alpnProtocols), S.any([b.string, b.undefined], e.ciphers), S.any([b.string,
      b.buffer, b.undefined], e.dhparam), S.any([b.string, b.undefined], e.signatureAlgorithms), S.any([b.string, b.undefined], e.minVersion),
      S.any([b.string, b.undefined], e.maxVersion), S.any([b.boolean, b.undefined], e.honorCipherOrder), S.any([b.number, b.undefined], e.tlsSessionLifetime),
      S.any([b.string, b.undefined], e.ecdhCurve), S.any([b.string, b.buffer, b.array, b.undefined], e.certificateRevocationLists);
      for (let t in e)
        if (!(t in this._internals.https))
          throw new Error(`HTTPS option \`${t}\` does not exist`);
      this._merging ? Object.assign(this._internals.https, e) : this._internals.https = { ...e };
    }
    /**
        [Encoding](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) to be used on `setEncoding` of the response data.
    
        To get a [`Buffer`](https://nodejs.org/api/buffer.html), you need to set `responseType` to `buffer` instead.
        Don't set this option to `null`.
    
        __Note__: This doesn't affect streams! Instead, you need to do `got.stream(...).setEncoding(encoding)`.
    
        @default 'utf-8'
        */
    get encoding() {
      return this._internals.encoding;
    }
    set encoding(e) {
      if (e === null)
        throw new TypeError("To get a Buffer, set `options.responseType` to `buffer` instead");
      S.any([b.string, b.undefined], e), this._internals.encoding = e;
    }
    /**
        When set to `true` the promise will return the Response body instead of the Response object.
    
        @default false
        */
    get resolveBodyOnly() {
      return this._internals.resolveBodyOnly;
    }
    set resolveBodyOnly(e) {
      S.boolean(e), this._internals.resolveBodyOnly = e;
    }
    /**
        Returns a `Stream` instead of a `Promise`.
        This is equivalent to calling `got.stream(url, options?)`.
    
        @default false
        */
    get isStream() {
      return this._internals.isStream;
    }
    set isStream(e) {
      S.boolean(e), this._internals.isStream = e;
    }
    /**
        The parsing method.
    
        The promise also has `.text()`, `.json()` and `.buffer()` methods which return another Got promise for the parsed body.
    
        It's like setting the options to `{responseType: 'json', resolveBodyOnly: true}` but without affecting the main Got promise.
    
        __Note__: When using streams, this option is ignored.
    
        @example
        ```
        const responsePromise = got(url);
        const bufferPromise = responsePromise.buffer();
        const jsonPromise = responsePromise.json();
    
        const [response, buffer, json] = Promise.all([responsePromise, bufferPromise, jsonPromise]);
        // `response` is an instance of Got Response
        // `buffer` is an instance of Buffer
        // `json` is an object
        ```
    
        @example
        ```
        // This
        const body = await got(url).json();
    
        // is semantically the same as this
        const body = await got(url, {responseType: 'json', resolveBodyOnly: true});
        ```
        */
    get responseType() {
      return this._internals.responseType;
    }
    set responseType(e) {
      if (e === void 0) {
        this._internals.responseType = "text";
        return;
      }
      if (e !== "text" && e !== "buffer" && e !== "json")
        throw new Error(`Invalid \`responseType\` option: ${e}`);
      this._internals.responseType = e;
    }
    get pagination() {
      return this._internals.pagination;
    }
    set pagination(e) {
      S.object(e), this._merging ? Object.assign(this._internals.pagination, e) : this._internals.pagination = e;
    }
    get auth() {
      throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    set auth(e) {
      throw new Error("Parameter `auth` is deprecated. Use `username` / `password` instead.");
    }
    get setHost() {
      return this._internals.setHost;
    }
    set setHost(e) {
      S.boolean(e), this._internals.setHost = e;
    }
    get maxHeaderSize() {
      return this._internals.maxHeaderSize;
    }
    set maxHeaderSize(e) {
      S.any([b.number, b.undefined], e), this._internals.maxHeaderSize = e;
    }
    get enableUnixSockets() {
      return this._internals.enableUnixSockets;
    }
    set enableUnixSockets(e) {
      S.boolean(e), this._internals.enableUnixSockets = e;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    toJSON() {
      return { ...this._internals };
    }
    [Symbol.for("nodejs.util.inspect.custom")](e, t) {
      return (0, Mc.inspect)(this._internals, t);
    }
    createNativeRequestOptions() {
      var e;
      let t = this._internals, r = t.url, i;
      r.protocol === "https:" ? i = t.http2 ? t.agent : t.agent.https : i = t.agent.http;
      let { https: s } = t, { pfx: o } = s;
      return b.array(o) && b.plainObject(o[0]) && (o = o.map((u) => ({
        buf: u.buffer,
        passphrase: u.passphrase
      }))), {
        ...t.cacheOptions,
        ...this._unixOptions,
        // HTTPS options
        // eslint-disable-next-line @typescript-eslint/naming-convention
        ALPNProtocols: s.alpnProtocols,
        ca: s.certificateAuthority,
        cert: s.certificate,
        key: s.key,
        passphrase: s.passphrase,
        pfx: s.pfx,
        rejectUnauthorized: s.rejectUnauthorized,
        checkServerIdentity: s.checkServerIdentity ?? rO.checkServerIdentity,
        ciphers: s.ciphers,
        honorCipherOrder: s.honorCipherOrder,
        minVersion: s.minVersion,
        maxVersion: s.maxVersion,
        sigalgs: s.signatureAlgorithms,
        sessionTimeout: s.tlsSessionLifetime,
        dhparam: s.dhparam,
        ecdhCurve: s.ecdhCurve,
        crl: s.certificateRevocationLists,
        // HTTP options
        lookup: t.dnsLookup ?? ((e = t.dnsCache) == null ? void 0 : e.lookup),
        family: t.dnsLookupIpVersion,
        agent: i,
        setHost: t.setHost,
        method: t.method,
        maxHeaderSize: t.maxHeaderSize,
        localAddress: t.localAddress,
        headers: t.headers,
        createConnection: t.createConnection,
        timeout: t.http2 ? _O(t) : void 0,
        // HTTP/2 options
        h2session: t.h2session
      };
    }
    getRequestFunction() {
      let e = this._internals.url, { request: t } = this._internals;
      return !t && e ? this.getFallbackRequestFunction() : t;
    }
    getFallbackRequestFunction() {
      let e = this._internals.url;
      if (e) {
        if (e.protocol === "https:") {
          if (this._internals.http2) {
            if (vv < 15 || vv === 15 && DO < 10) {
              let t = new Error("To use the `http2` option, install Node.js 15.10.0 or above");
              throw t.code = "EUNSUPPORTED", t;
            }
            return dO.default.auto;
          }
          return nO.default.request;
        }
        return iO.default.request;
      }
    }
    freeze() {
      let e = this._internals;
      Object.freeze(e), Object.freeze(e.hooks), Object.freeze(e.hooks.afterResponse), Object.freeze(e.hooks.beforeError), Object.freeze(e.hooks.
      beforeRedirect), Object.freeze(e.hooks.beforeRequest), Object.freeze(e.hooks.beforeRetry), Object.freeze(e.hooks.init), Object.freeze(
      e.https), Object.freeze(e.cacheOptions), Object.freeze(e.agent), Object.freeze(e.headers), Object.freeze(e.timeout), Object.freeze(e.retry),
      Object.freeze(e.retry.errorCodes), Object.freeze(e.retry.methods), Object.freeze(e.retry.statusCodes);
    }
  }, Uo = /* @__PURE__ */ n((e) => {
    let { statusCode: t } = e, r = e.request.options.followRedirect ? 299 : 399;
    return t >= 200 && t <= r || t === 304;
  }, "isResponseOk"), Ev = class extends ve {
    static {
      n(this, "ParseError");
    }
    constructor(e, t) {
      let { options: r } = t.request;
      super(`${e.message} in "${r.url.toString()}"`, e, t.request), this.name = "ParseError", this.code = "ERR_BODY_PARSE_FAILURE";
    }
  }, Cv = /* @__PURE__ */ n((e, t, r, i) => {
    let { rawBody: s } = e;
    try {
      if (t === "text")
        return s.toString(i);
      if (t === "json")
        return s.length === 0 ? "" : r(s.toString(i));
      if (t === "buffer")
        return s;
    } catch (o) {
      throw new Ev(o, e);
    }
    throw new Ev({
      message: `Unknown body type '${t}'`,
      name: "Error"
    }, e);
  }, "parseBody");
  function EO(e) {
    return e.writable && !e.writableEnded;
  }
  n(EO, "isClientRequest");
  var CO = EO;
  function Fv(e) {
    return e.protocol === "unix:" || e.hostname === "unix";
  }
  n(Fv, "isUnixSocketURL");
  var FO = b.string(zv.default.versions.brotli), xO = /* @__PURE__ */ new Set(["GET", "HEAD"]), Lc = new XB(), SO = /* @__PURE__ */ new Set(
  [300, 301, 302, 303, 304, 307, 308]), AO = [
    "socket",
    "connect",
    "continue",
    "information",
    "upgrade"
  ], Lo = /* @__PURE__ */ n(() => {
  }, "noop2"), Hc = class extends cB.Duplex {
    static {
      n(this, "Request");
    }
    constructor(e, t, r) {
      super({
        // Don't destroy immediately, as the error may be emitted on unsuccessful retry
        autoDestroy: !1,
        // It needs to be zero because we're just proxying the data to another stream
        highWaterMark: 0
      }), Object.defineProperty(this, "constructor", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_noPipe", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "options", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "response", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "requestUrl", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "redirectUrls", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "retryCount", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_stopRetry", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_downloadedSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_uploadedSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_stopReading", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_pipedServerResponses", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_request", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_responseSize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_bodySize", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_unproxyEvents", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_isFromCache", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_cannotHaveBody", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_triggerRead", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_cancelTimeouts", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_removeListeners", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_nativeResponse", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_flushed", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_aborted", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), Object.defineProperty(this, "_requestInitialized", {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: void 0
      }), this._downloadedSize = 0, this._uploadedSize = 0, this._stopReading = !1, this._pipedServerResponses = /* @__PURE__ */ new Set(), this.
      _cannotHaveBody = !1, this._unproxyEvents = Lo, this._triggerRead = !1, this._cancelTimeouts = Lo, this._removeListeners = Lo, this._jobs =
      [], this._flushed = !1, this._requestInitialized = !1, this._aborted = !1, this.redirectUrls = [], this.retryCount = 0, this._stopRetry =
      Lo, this.on("pipe", (s) => {
        s.headers && Object.assign(this.options.headers, s.headers);
      }), this.on("newListener", (s) => {
        if (s === "retry" && this.listenerCount("retry") > 0)
          throw new Error("A retry listener has been attached already.");
      });
      try {
        if (this.options = new jt(e, t, r), !this.options.url) {
          if (this.options.prefixUrl === "")
            throw new TypeError("Missing `url` property");
          this.options.url = "";
        }
        this.requestUrl = this.options.url;
      } catch (s) {
        let { options: o } = s;
        o && (this.options = o), this.flush = async () => {
          this.flush = async () => {
          }, this.destroy(s);
        };
        return;
      }
      let { body: i } = this.options;
      if (b.nodeStream(i) && i.once("error", (s) => {
        this._flushed ? this._beforeError(new nv(s, this)) : this.flush = async () => {
          this.flush = async () => {
          }, this._beforeError(new nv(s, this));
        };
      }), this.options.signal) {
        let s = /* @__PURE__ */ n(() => {
          this.destroy(new lB(this));
        }, "abort");
        this.options.signal.aborted ? s() : (this.options.signal.addEventListener("abort", s), this._removeListeners = () => {
          this.options.signal.removeEventListener("abort", s);
        });
      }
    }
    async flush() {
      var e;
      if (!this._flushed) {
        this._flushed = !0;
        try {
          if (await this._finalizeBody(), this.destroyed)
            return;
          if (await this._makeRequest(), this.destroyed) {
            (e = this._request) == null || e.destroy();
            return;
          }
          for (let t of this._jobs)
            t();
          this._jobs.length = 0, this._requestInitialized = !0;
        } catch (t) {
          this._beforeError(t);
        }
      }
    }
    _beforeError(e) {
      if (this._stopReading)
        return;
      let { response: t, options: r } = this, i = this.retryCount + (e.name === "RetryError" ? 0 : 1);
      this._stopReading = !0, e instanceof ve || (e = new ve(e.message, e, this));
      let s = e;
      (async () => {
        var o, u;
        if (t?.readable && !t.rawBody && !((u = (o = this._request) == null ? void 0 : o.socket) != null && u.destroyed) && (t.setEncoding(this.
        readableEncoding), await this._setRawBody(t) && (t.body = t.rawBody.toString())), this.listenerCount("retry") !== 0) {
          let a;
          try {
            let l;
            t && "retry-after" in t.headers && (l = Number(t.headers["retry-after"]), Number.isNaN(l) ? (l = Date.parse(t.headers["retry-aft\
er"]) - Date.now(), l <= 0 && (l = 1)) : l *= 1e3);
            let c = r.retry;
            a = await c.calculateDelay({
              attemptCount: i,
              retryOptions: c,
              error: s,
              retryAfter: l,
              computedValue: eO({
                attemptCount: i,
                retryOptions: c,
                error: s,
                retryAfter: l,
                computedValue: c.maxRetryAfter ?? r.timeout.request ?? Number.POSITIVE_INFINITY
              })
            });
          } catch (l) {
            this._error(new ve(l.message, l, this));
            return;
          }
          if (a) {
            if (await new Promise((l) => {
              let c = setTimeout(l, a);
              this._stopRetry = () => {
                clearTimeout(c), l();
              };
            }), this.destroyed)
              return;
            try {
              for (let l of this.options.hooks.beforeRetry)
                await l(s, this.retryCount + 1);
            } catch (l) {
              this._error(new ve(l.message, e, this));
              return;
            }
            if (this.destroyed)
              return;
            this.destroy(), this.emit("retry", this.retryCount + 1, e, (l) => {
              let c = new Hc(r.url, l, r);
              return c.retryCount = this.retryCount + 1, zv.default.nextTick(() => {
                c.flush();
              }), c;
            });
            return;
          }
        }
        this._error(s);
      })();
    }
    _read() {
      this._triggerRead = !0;
      let { response: e } = this;
      if (e && !this._stopReading) {
        e.readableLength && (this._triggerRead = !1);
        let t;
        for (; (t = e.read()) !== null; ) {
          this._downloadedSize += t.length;
          let r = this.downloadProgress;
          r.percent < 1 && this.emit("downloadProgress", r), this.push(t);
        }
      }
    }
    _write(e, t, r) {
      let i = /* @__PURE__ */ n(() => {
        this._writeRequest(e, t, r);
      }, "write");
      this._requestInitialized ? i() : this._jobs.push(i);
    }
    _final(e) {
      let t = /* @__PURE__ */ n(() => {
        if (!this._request || this._request.destroyed) {
          e();
          return;
        }
        this._request.end((r) => {
          var i;
          (i = this._request._writableState) != null && i.errored || (r || (this._bodySize = this._uploadedSize, this.emit("uploadProgress",
          this.uploadProgress), this._request.emit("upload-complete")), e(r));
        });
      }, "endRequest");
      this._requestInitialized ? t() : this._jobs.push(t);
    }
    _destroy(e, t) {
      if (this._stopReading = !0, this.flush = async () => {
      }, this._stopRetry(), this._cancelTimeouts(), this._removeListeners(), this.options) {
        let { body: r } = this.options;
        b.nodeStream(r) && r.destroy();
      }
      this._request && this._request.destroy(), e !== null && !b.undefined(e) && !(e instanceof ve) && (e = new ve(e.message, e, this)), t(e);
    }
    pipe(e, t) {
      return e instanceof kc.ServerResponse && this._pipedServerResponses.add(e), super.pipe(e, t);
    }
    unpipe(e) {
      return e instanceof kc.ServerResponse && this._pipedServerResponses.delete(e), super.unpipe(e), this;
    }
    async _finalizeBody() {
      let { options: e } = this, { headers: t } = e, r = !b.undefined(e.form), i = !b.undefined(e.json), s = !b.undefined(e.body), o = xO.has(
      e.method) && !(e.method === "GET" && e.allowGetBody);
      if (this._cannotHaveBody = o, r || i || s) {
        if (o)
          throw new TypeError(`The \`${e.method}\` method cannot be used with a body`);
        let u = !b.string(t["content-type"]);
        if (s) {
          if ($c(e.body)) {
            let l = new $B(e.body);
            u && (t["content-type"] = l.headers["Content-Type"]), "Content-Length" in l.headers && (t["content-length"] = l.headers["Content\
-Length"]), e.body = l.encode();
          }
          Gv(e.body) && u && (t["content-type"] = `multipart/form-data; boundary=${e.body.getBoundary()}`);
        } else if (r) {
          u && (t["content-type"] = "application/x-www-form-urlencoded");
          let { form: l } = e;
          e.form = void 0, e.body = new ov.URLSearchParams(l).toString();
        } else {
          u && (t["content-type"] = "application/json");
          let { json: l } = e;
          e.json = void 0, e.body = e.stringifyJson(l);
        }
        let a = await VB(e.body, e.headers);
        b.undefined(t["content-length"]) && b.undefined(t["transfer-encoding"]) && !o && !b.undefined(a) && (t["content-length"] = String(a));
      }
      e.responseType === "json" && !("accept" in e.headers) && (e.headers.accept = "application/json"), this._bodySize = Number(t["content-l\
ength"]) || void 0;
    }
    async _onResponseBase(e) {
      if (this.isAborted)
        return;
      let { options: t } = this, { url: r } = t;
      this._nativeResponse = e, t.decompress && (e = (0, PB.default)(e));
      let i = e.statusCode, s = e;
      s.statusMessage = s.statusMessage ? s.statusMessage : kc.default.STATUS_CODES[i], s.url = t.url.toString(), s.requestUrl = this.requestUrl,
      s.redirectUrls = this.redirectUrls, s.request = this, s.isFromCache = this._nativeResponse.fromCache ?? !1, s.ip = this.ip, s.retryCount =
      this.retryCount, s.ok = Uo(s), this._isFromCache = s.isFromCache, this._responseSize = Number(e.headers["content-length"]) || void 0, this.
      response = s, e.once("end", () => {
        this._responseSize = this._downloadedSize, this.emit("downloadProgress", this.downloadProgress);
      }), e.once("error", (u) => {
        this._aborted = !0, e.destroy(), this._beforeError(new sv(u, this));
      }), e.once("aborted", () => {
        this._aborted = !0, this._beforeError(new sv({
          name: "Error",
          message: "The server aborted pending request",
          code: "ECONNRESET"
        }, this));
      }), this.emit("downloadProgress", this.downloadProgress);
      let o = e.headers["set-cookie"];
      if (b.object(t.cookieJar) && o) {
        let u = o.map(async (a) => t.cookieJar.setCookie(a, r.toString()));
        t.ignoreInvalidCookies && (u = u.map(async (a) => {
          try {
            await a;
          } catch {
          }
        }));
        try {
          await Promise.all(u);
        } catch (a) {
          this._beforeError(a);
          return;
        }
      }
      if (!this.isAborted) {
        if (t.followRedirect && e.headers.location && SO.has(i)) {
          if (e.resume(), this._cancelTimeouts(), this._unproxyEvents(), this.redirectUrls.length >= t.maxRedirects) {
            this._beforeError(new sB(this));
            return;
          }
          this._request = void 0;
          let u = new jt(void 0, void 0, this.options), a = i === 303 && u.method !== "GET" && u.method !== "HEAD", l = i !== 307 && i !== 308,
          c = u.methodRewriting && l;
          (a || c) && (u.method = "GET", u.body = void 0, u.json = void 0, u.form = void 0, delete u.headers["content-length"]);
          try {
            let h = Rc.Buffer.from(e.headers.location, "binary").toString(), p = new ov.URL(h, r);
            if (!Fv(r) && Fv(p)) {
              this._beforeError(new ve("Cannot redirect to UNIX socket", {}, this));
              return;
            }
            p.hostname !== r.hostname || p.port !== r.port ? ("host" in u.headers && delete u.headers.host, "cookie" in u.headers && delete u.
            headers.cookie, "authorization" in u.headers && delete u.headers.authorization, (u.username || u.password) && (u.username = "", u.
            password = "")) : (p.username = u.username, p.password = u.password), this.redirectUrls.push(p), u.prefixUrl = "", u.url = p;
            for (let d of u.hooks.beforeRedirect)
              await d(u, s);
            this.emit("redirect", u, s), this.options = u, await this._makeRequest();
          } catch (h) {
            this._beforeError(h);
            return;
          }
          return;
        }
        if (t.isStream && t.throwHttpErrors && !Uo(s)) {
          this._beforeError(new No(s));
          return;
        }
        if (e.on("readable", () => {
          this._triggerRead && this._read();
        }), this.on("resume", () => {
          e.resume();
        }), this.on("pause", () => {
          e.pause();
        }), e.once("end", () => {
          this.push(null);
        }), this._noPipe) {
          await this._setRawBody() && this.emit("response", e);
          return;
        }
        this.emit("response", e);
        for (let u of this._pipedServerResponses)
          if (!u.headersSent) {
            for (let a in e.headers) {
              let l = t.decompress ? a !== "content-encoding" : !0, c = e.headers[a];
              l && u.setHeader(a, c);
            }
            u.statusCode = i;
          }
      }
    }
    async _setRawBody(e = this) {
      if (e.readableEnded)
        return !1;
      try {
        let t = await (0, qB.buffer)(e);
        if (!this.isAborted)
          return this.response.rawBody = t, !0;
      } catch {
      }
      return !1;
    }
    async _onResponse(e) {
      try {
        await this._onResponseBase(e);
      } catch (t) {
        this._beforeError(t);
      }
    }
    _onRequest(e) {
      let { options: t } = this, { timeout: r, url: i } = t;
      DB(e), this.options.http2 && e.setTimeout(0), this._cancelTimeouts = KB(e, r, i);
      let s = t.cache ? "cacheableResponse" : "response";
      e.once(s, (o) => {
        this._onResponse(o);
      }), e.once("error", (o) => {
        this._aborted = !0, e.destroy(), o = o instanceof Yv ? new uB(o, this.timings, this) : new ve(o.message, o, this), this._beforeError(
        o);
      }), this._unproxyEvents = Jv(e, this, AO), this._request = e, this.emit("uploadProgress", this.uploadProgress), this._sendBody(), this.
      emit("request", e);
    }
    async _asyncWrite(e) {
      return new Promise((t, r) => {
        super.write(e, (i) => {
          if (i) {
            r(i);
            return;
          }
          t();
        });
      });
    }
    _sendBody() {
      let { body: e } = this.options, t = this.redirectUrls.length === 0 ? this : this._request ?? this;
      b.nodeStream(e) ? e.pipe(t) : b.generator(e) || b.asyncGenerator(e) ? (async () => {
        try {
          for await (let r of e)
            await this._asyncWrite(r);
          super.end();
        } catch (r) {
          this._beforeError(r);
        }
      })() : b.undefined(e) ? (this._cannotHaveBody || this._noPipe) && t.end() : (this._writeRequest(e, void 0, () => {
      }), t.end());
    }
    _prepareCache(e) {
      if (!Lc.has(e)) {
        let t = new OB((r, i) => {
          let s = r._request(r, i);
          return b.promise(s) && (s.once = (o, u) => {
            if (o === "error")
              (async () => {
                try {
                  await s;
                } catch (a) {
                  u(a);
                }
              })();
            else if (o === "abort")
              (async () => {
                try {
                  (await s).once("abort", u);
                } catch {
                }
              })();
            else
              throw new Error(`Unknown HTTP2 promise event: ${o}`);
            return s;
          }), s;
        }, e);
        Lc.set(e, t.request());
      }
    }
    async _createCacheableRequest(e, t) {
      return new Promise((r, i) => {
        Object.assign(t, QB(e));
        let s, o = Lc.get(t.cache)(t, async (u) => {
          if (u._readableState.autoDestroy = !1, s) {
            let a = /* @__PURE__ */ n(() => {
              u.req && (u.complete = u.req.res.complete);
            }, "fix");
            u.prependOnceListener("end", a), a(), (await s).emit("cacheableResponse", u);
          }
          r(u);
        });
        o.once("error", i), o.once("request", async (u) => {
          s = u, r(s);
        });
      });
    }
    async _makeRequest() {
      let { options: e } = this, { headers: t, username: r, password: i } = e, s = e.cookieJar;
      for (let l in t)
        if (b.undefined(t[l]))
          delete t[l];
        else if (b.null_(t[l]))
          throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${l}\` header`);
      if (e.decompress && b.undefined(t["accept-encoding"]) && (t["accept-encoding"] = FO ? "gzip, deflate, br" : "gzip, deflate"), r || i) {
        let l = Rc.Buffer.from(`${r}:${i}`).toString("base64");
        t.authorization = `Basic ${l}`;
      }
      if (s) {
        let l = await s.getCookieString(e.url.toString());
        b.nonEmptyString(l) && (t.cookie = l);
      }
      e.prefixUrl = "";
      let o;
      for (let l of e.hooks.beforeRequest) {
        let c = await l(e);
        if (!b.undefined(c)) {
          o = /* @__PURE__ */ n(() => c, "request");
          break;
        }
      }
      o || (o = e.getRequestFunction());
      let u = e.url;
      this._requestOptions = e.createNativeRequestOptions(), e.cache && (this._requestOptions._request = o, this._requestOptions.cache = e.cache,
      this._requestOptions.body = e.body, this._prepareCache(e.cache));
      let a = e.cache ? this._createCacheableRequest : o;
      try {
        let l = a(u, this._requestOptions);
        b.promise(l) && (l = await l), b.undefined(l) && (l = e.getFallbackRequestFunction()(u, this._requestOptions), b.promise(l) && (l = await l)),
        CO(l) ? this._onRequest(l) : this.writable ? (this.once("finish", () => {
          this._onResponse(l);
        }), this._sendBody()) : this._onResponse(l);
      } catch (l) {
        throw l instanceof Rn ? new oB(l, this) : l;
      }
    }
    async _error(e) {
      try {
        if (!(e instanceof No && !this.options.throwHttpErrors))
          for (let t of this.options.hooks.beforeError)
            e = await t(e);
      } catch (t) {
        e = new ve(t.message, t, this);
      }
      this.destroy(e);
    }
    _writeRequest(e, t, r) {
      !this._request || this._request.destroyed || this._request.write(e, t, (i) => {
        if (!i && !this._request.destroyed) {
          this._uploadedSize += Rc.Buffer.byteLength(e, t);
          let s = this.uploadProgress;
          s.percent < 1 && this.emit("uploadProgress", s);
        }
        r(i);
      });
    }
    /**
    The remote IP address.
    */
    get ip() {
      var e;
      return (e = this.socket) == null ? void 0 : e.remoteAddress;
    }
    /**
    Indicates whether the request has been aborted or not.
    */
    get isAborted() {
      return this._aborted;
    }
    get socket() {
      var e;
      return ((e = this._request) == null ? void 0 : e.socket) ?? void 0;
    }
    /**
    Progress event for downloading (receiving a response).
    */
    get downloadProgress() {
      let e;
      return this._responseSize ? e = this._downloadedSize / this._responseSize : this._responseSize === this._downloadedSize ? e = 1 : e = 0,
      {
        percent: e,
        transferred: this._downloadedSize,
        total: this._responseSize
      };
    }
    /**
    Progress event for uploading (sending a request).
    */
    get uploadProgress() {
      let e;
      return this._bodySize ? e = this._uploadedSize / this._bodySize : this._bodySize === this._uploadedSize ? e = 1 : e = 0, {
        percent: e,
        transferred: this._uploadedSize,
        total: this._bodySize
      };
    }
    /**
        The object contains the following properties:
    
        - `start` - Time when the request started.
        - `socket` - Time when a socket was assigned to the request.
        - `lookup` - Time when the DNS lookup finished.
        - `connect` - Time when the socket successfully connected.
        - `secureConnect` - Time when the socket securely connected.
        - `upload` - Time when the request finished uploading.
        - `response` - Time when the request fired `response` event.
        - `end` - Time when the response fired `end` event.
        - `error` - Time when the request fired `error` event.
        - `abort` - Time when the request fired `abort` event.
        - `phases`
            - `wait` - `timings.socket - timings.start`
            - `dns` - `timings.lookup - timings.socket`
            - `tcp` - `timings.connect - timings.lookup`
            - `tls` - `timings.secureConnect - timings.connect`
            - `request` - `timings.upload - (timings.secureConnect || timings.connect)`
            - `firstByte` - `timings.response - timings.upload`
            - `download` - `timings.end - timings.response`
            - `total` - `(timings.end || timings.error || timings.abort) - timings.start`
    
        If something has not been measured yet, it will be `undefined`.
    
        __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.
        */
    get timings() {
      var e;
      return (e = this._request) == null ? void 0 : e.timings;
    }
    /**
    Whether the response was retrieved from the cache.
    */
    get isFromCache() {
      return this._isFromCache;
    }
    get reusedSocket() {
      var e;
      return (e = this._request) == null ? void 0 : e.reusedSocket;
    }
  }, TO = class extends ve {
    static {
      n(this, "CancelError2");
    }
    constructor(e) {
      super("Promise was canceled", {}, e), this.name = "CancelError", this.code = "ERR_CANCELED";
    }
    /**
    Whether the promise is canceled.
    */
    get isCanceled() {
      return !0;
    }
  }, RO = [
    "request",
    "response",
    "redirect",
    "uploadProgress",
    "downloadProgress"
  ];
  function xv(e) {
    let t, r, i, s = new rB.EventEmitter(), o = new Wc((a, l, c) => {
      c(() => {
        t.destroy();
      }), c.shouldReject = !1, c(() => {
        l(new TO(t));
      });
      let h = /* @__PURE__ */ n((p) => {
        var d;
        c(() => {
        });
        let f = e ?? new Hc(void 0, void 0, i);
        f.retryCount = p, f._noPipe = !0, t = f, f.once("response", async (y) => {
          let _ = (y.headers["content-encoding"] ?? "").toLowerCase(), C = _ === "gzip" || _ === "deflate" || _ === "br", { options: w } = f;
          if (C && !w.decompress)
            y.body = y.rawBody;
          else
            try {
              y.body = Cv(y, w.responseType, w.parseJson, w.encoding);
            } catch (E) {
              if (y.body = y.rawBody.toString(), Uo(y)) {
                f._beforeError(E);
                return;
              }
            }
          try {
            let E = w.hooks.afterResponse;
            for (let [x, A] of E.entries())
              if (y = await A(y, async (O) => {
                throw w.merge(O), w.prefixUrl = "", O.url && (w.url = O.url), w.hooks.afterResponse = w.hooks.afterResponse.slice(0, x), new aB(
                f);
              }), !(b.object(y) && b.number(y.statusCode) && !b.nullOrUndefined(y.body)))
                throw new TypeError("The `afterResponse` hook returned an invalid value");
          } catch (E) {
            f._beforeError(E);
            return;
          }
          if (r = y, !Uo(y)) {
            f._beforeError(new No(y));
            return;
          }
          f.destroy(), a(f.options.resolveBodyOnly ? y.body : y);
        });
        let m = /* @__PURE__ */ n((y) => {
          if (o.isCanceled)
            return;
          let { options: _ } = f;
          if (y instanceof No && !_.throwHttpErrors) {
            let { response: C } = y;
            f.destroy(), a(f.options.resolveBodyOnly ? C.body : C);
            return;
          }
          l(y);
        }, "onError");
        f.once("error", m);
        let v = (d = f.options) == null ? void 0 : d.body;
        f.once("retry", (y, _) => {
          e = void 0;
          let C = f.options.body;
          if (v === C && b.nodeStream(C)) {
            _.message = "Cannot retry with consumed body stream", m(_);
            return;
          }
          i = f.options, h(y);
        }), Jv(f, s, RO), b.undefined(e) && f.flush();
      }, "makeRequest");
      h(0);
    });
    o.on = (a, l) => (s.on(a, l), o), o.off = (a, l) => (s.off(a, l), o);
    let u = /* @__PURE__ */ n((a) => {
      let l = (async () => {
        await o;
        let { options: c } = r.request;
        return Cv(r, a, c.parseJson, c.encoding);
      })();
      return Object.defineProperties(l, Object.getOwnPropertyDescriptors(o)), l;
    }, "shortcut");
    return o.json = () => {
      if (t.options) {
        let { headers: a } = t.options;
        !t.writableFinished && !("accept" in a) && (a.accept = "application/json");
      }
      return u("json");
    }, o.buffer = () => u("buffer"), o.text = () => u("text"), o;
  }
  n(xv, "asPromise");
  var kO = /* @__PURE__ */ n(async (e) => new Promise((t) => {
    setTimeout(t, e);
  }), "delay"), BO = /* @__PURE__ */ n((e) => b.function_(e), "isGotInstance"), OO = [
    "get",
    "post",
    "put",
    "patch",
    "head",
    "delete"
  ], Kv = /* @__PURE__ */ n((e) => {
    e = {
      options: new jt(void 0, void 0, e.options),
      handlers: [...e.handlers],
      mutableDefaults: e.mutableDefaults
    }, Object.defineProperty(e, "mutableDefaults", {
      enumerable: !0,
      configurable: !1,
      writable: !1
    });
    let t = /* @__PURE__ */ n((i, s, o = e.options) => {
      let u = new Hc(i, s, o), a, l = /* @__PURE__ */ n((p) => (u.options = p, u._noPipe = !p.isStream, u.flush(), p.isStream ? u : (a || (a =
      xv(u)), a)), "lastHandler"), c = 0, h = /* @__PURE__ */ n((p) => {
        let f = (e.handlers[c++] ?? l)(p, h);
        if (b.promise(f) && !u.options.isStream && (a || (a = xv(u)), f !== a)) {
          let m = Object.getOwnPropertyDescriptors(a);
          for (let v in m)
            v in f && delete m[v];
          Object.defineProperties(f, m), f.cancel = a.cancel;
        }
        return f;
      }, "iterateHandlers");
      return h(u.options);
    }, "got2");
    t.extend = (...i) => {
      let s = new jt(void 0, void 0, e.options), o = [...e.handlers], u;
      for (let a of i)
        BO(a) ? (s.merge(a.defaults.options), o.push(...a.defaults.handlers), u = a.defaults.mutableDefaults) : (s.merge(a), a.handlers && o.
        push(...a.handlers), u = a.mutableDefaults);
      return Kv({
        options: s,
        handlers: o,
        mutableDefaults: !!u
      });
    };
    let r = /* @__PURE__ */ n(async function* (i, s) {
      let o = new jt(i, s, e.options);
      o.resolveBodyOnly = !1;
      let { pagination: u } = o;
      S.function_(u.transform), S.function_(u.shouldContinue), S.function_(u.filter), S.function_(u.paginate), S.number(u.countLimit), S.number(
      u.requestLimit), S.number(u.backoff);
      let a = [], { countLimit: l } = u, c = 0;
      for (; c < u.requestLimit; ) {
        c !== 0 && await kO(u.backoff);
        let h = await t(void 0, void 0, o), p = await u.transform(h), d = [];
        S.array(p);
        for (let m of p)
          if (u.filter({ item: m, currentItems: d, allItems: a }) && (!u.shouldContinue({ item: m, currentItems: d, allItems: a }) || (yield m,
          u.stackAllItems && a.push(m), d.push(m), --l <= 0)))
            return;
        let f = u.paginate({
          response: h,
          currentItems: d,
          allItems: a
        });
        if (f === !1)
          return;
        f === h.request.options ? o = h.request.options : (o.merge(f), S.any([b.urlInstance, b.undefined], f.url), f.url !== void 0 && (o.prefixUrl =
        "", o.url = f.url)), c++;
      }
    }, "paginateEach");
    t.paginate = r, t.paginate.all = async (i, s) => {
      let o = [];
      for await (let u of r(i, s))
        o.push(u);
      return o;
    }, t.paginate.each = r, t.stream = (i, s) => t(i, { ...s, isStream: !0 });
    for (let i of OO)
      t[i] = (s, o) => t(s, { ...o, method: i }), t.stream[i] = (s, o) => t(s, { ...o, method: i, isStream: !0 });
    return e.mutableDefaults || (Object.freeze(e.handlers), e.options.freeze()), Object.defineProperty(t, "defaults", {
      value: e,
      writable: !1,
      configurable: !1,
      enumerable: !0
    }), t;
  }, "create"), PO = Kv, qO = {
    options: new jt(),
    handlers: [],
    mutableDefaults: !1
  }, MO = PO(qO), jO = MO, IO = we(Ua()), LO = cb(), NO = we(iv()), Sv = {
    keepAlive: !0,
    maxSockets: 20
  }, UO = {
    http: new Wk.Agent(Sv),
    https: new $k.Agent(Sv)
  };
  async function WO({ url: e, gotOpts: t, extractOpts: r, dir: i }) {
    return new Promise((s, o) => {
      let u = /* @__PURE__ */ n((a) => {
        a ? o(a) : s();
      }, "callback");
      (0, IO.default)(
        jO.stream(e, Object.assign({ agent: UO }, t)),
        (0, NO.default)(),
        (0, LO.extract)(i, r),
        u
      );
    });
  }
  n(WO, "download");
});

// ../node_modules/get-npm-tarball-url/lib/index.js
var t_ = g((K7, e_) => {
  var zc = Object.defineProperty, $O = Object.getOwnPropertyDescriptor, HO = Object.getOwnPropertyNames, zO = Object.prototype.hasOwnProperty,
  VO = /* @__PURE__ */ n((e, t) => {
    for (var r in t)
      zc(e, r, { get: t[r], enumerable: !0 });
  }, "__export"), GO = /* @__PURE__ */ n((e, t, r, i) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let s of HO(t))
        !zO.call(e, s) && s !== r && zc(e, s, { get: /* @__PURE__ */ n(() => t[s], "get"), enumerable: !(i = $O(t, s)) || i.enumerable });
    return e;
  }, "__copyProps"), JO = /* @__PURE__ */ n((e) => GO(zc({}, "__esModule", { value: !0 }), e), "__toCommonJS"), Zv = {};
  VO(Zv, {
    default: /* @__PURE__ */ n(() => YO, "default")
  });
  e_.exports = JO(Zv);
  function YO(e, t, r) {
    let i;
    r?.registry ? i = r.registry.endsWith("/") ? r.registry : `${r.registry}/` : i = "https://registry.npmjs.org/";
    let s = QO(e);
    return `${i}${e}/-/${s}-${KO(t)}.tgz`;
  }
  n(YO, "src_default");
  function KO(e) {
    let t = e.indexOf("+");
    return t === -1 ? e : e.substring(0, t);
  }
  n(KO, "removeBuildMetadataFromVersion");
  function QO(e) {
    return e[0] !== "@" ? e : e.split("/")[1];
  }
  n(QO, "getScopelessName");
});

// ../node_modules/eastasianwidth/eastasianwidth.js
var Jo = g((v9, rf) => {
  var ir = {};
  typeof rf > "u" ? window.eastasianwidth = ir : rf.exports = ir;
  ir.eastAsianWidth = function(e) {
    var t = e.charCodeAt(0), r = e.length == 2 ? e.charCodeAt(1) : 0, i = t;
    return 55296 <= t && t <= 56319 && 56320 <= r && r <= 57343 && (t &= 1023, r &= 1023, i = t << 10 | r, i += 65536), i == 12288 || 65281 <=
    i && i <= 65376 || 65504 <= i && i <= 65510 ? "F" : i == 8361 || 65377 <= i && i <= 65470 || 65474 <= i && i <= 65479 || 65482 <= i && i <=
    65487 || 65490 <= i && i <= 65495 || 65498 <= i && i <= 65500 || 65512 <= i && i <= 65518 ? "H" : 4352 <= i && i <= 4447 || 4515 <= i &&
    i <= 4519 || 4602 <= i && i <= 4607 || 9001 <= i && i <= 9002 || 11904 <= i && i <= 11929 || 11931 <= i && i <= 12019 || 12032 <= i && i <=
    12245 || 12272 <= i && i <= 12283 || 12289 <= i && i <= 12350 || 12353 <= i && i <= 12438 || 12441 <= i && i <= 12543 || 12549 <= i && i <=
    12589 || 12593 <= i && i <= 12686 || 12688 <= i && i <= 12730 || 12736 <= i && i <= 12771 || 12784 <= i && i <= 12830 || 12832 <= i && i <=
    12871 || 12880 <= i && i <= 13054 || 13056 <= i && i <= 19903 || 19968 <= i && i <= 42124 || 42128 <= i && i <= 42182 || 43360 <= i && i <=
    43388 || 44032 <= i && i <= 55203 || 55216 <= i && i <= 55238 || 55243 <= i && i <= 55291 || 63744 <= i && i <= 64255 || 65040 <= i && i <=
    65049 || 65072 <= i && i <= 65106 || 65108 <= i && i <= 65126 || 65128 <= i && i <= 65131 || 110592 <= i && i <= 110593 || 127488 <= i &&
    i <= 127490 || 127504 <= i && i <= 127546 || 127552 <= i && i <= 127560 || 127568 <= i && i <= 127569 || 131072 <= i && i <= 194367 || 177984 <=
    i && i <= 196605 || 196608 <= i && i <= 262141 ? "W" : 32 <= i && i <= 126 || 162 <= i && i <= 163 || 165 <= i && i <= 166 || i == 172 ||
    i == 175 || 10214 <= i && i <= 10221 || 10629 <= i && i <= 10630 ? "Na" : i == 161 || i == 164 || 167 <= i && i <= 168 || i == 170 || 173 <=
    i && i <= 174 || 176 <= i && i <= 180 || 182 <= i && i <= 186 || 188 <= i && i <= 191 || i == 198 || i == 208 || 215 <= i && i <= 216 ||
    222 <= i && i <= 225 || i == 230 || 232 <= i && i <= 234 || 236 <= i && i <= 237 || i == 240 || 242 <= i && i <= 243 || 247 <= i && i <=
    250 || i == 252 || i == 254 || i == 257 || i == 273 || i == 275 || i == 283 || 294 <= i && i <= 295 || i == 299 || 305 <= i && i <= 307 ||
    i == 312 || 319 <= i && i <= 322 || i == 324 || 328 <= i && i <= 331 || i == 333 || 338 <= i && i <= 339 || 358 <= i && i <= 359 || i ==
    363 || i == 462 || i == 464 || i == 466 || i == 468 || i == 470 || i == 472 || i == 474 || i == 476 || i == 593 || i == 609 || i == 708 ||
    i == 711 || 713 <= i && i <= 715 || i == 717 || i == 720 || 728 <= i && i <= 731 || i == 733 || i == 735 || 768 <= i && i <= 879 || 913 <=
    i && i <= 929 || 931 <= i && i <= 937 || 945 <= i && i <= 961 || 963 <= i && i <= 969 || i == 1025 || 1040 <= i && i <= 1103 || i == 1105 ||
    i == 8208 || 8211 <= i && i <= 8214 || 8216 <= i && i <= 8217 || 8220 <= i && i <= 8221 || 8224 <= i && i <= 8226 || 8228 <= i && i <= 8231 ||
    i == 8240 || 8242 <= i && i <= 8243 || i == 8245 || i == 8251 || i == 8254 || i == 8308 || i == 8319 || 8321 <= i && i <= 8324 || i == 8364 ||
    i == 8451 || i == 8453 || i == 8457 || i == 8467 || i == 8470 || 8481 <= i && i <= 8482 || i == 8486 || i == 8491 || 8531 <= i && i <= 8532 ||
    8539 <= i && i <= 8542 || 8544 <= i && i <= 8555 || 8560 <= i && i <= 8569 || i == 8585 || 8592 <= i && i <= 8601 || 8632 <= i && i <= 8633 ||
    i == 8658 || i == 8660 || i == 8679 || i == 8704 || 8706 <= i && i <= 8707 || 8711 <= i && i <= 8712 || i == 8715 || i == 8719 || i == 8721 ||
    i == 8725 || i == 8730 || 8733 <= i && i <= 8736 || i == 8739 || i == 8741 || 8743 <= i && i <= 8748 || i == 8750 || 8756 <= i && i <= 8759 ||
    8764 <= i && i <= 8765 || i == 8776 || i == 8780 || i == 8786 || 8800 <= i && i <= 8801 || 8804 <= i && i <= 8807 || 8810 <= i && i <= 8811 ||
    8814 <= i && i <= 8815 || 8834 <= i && i <= 8835 || 8838 <= i && i <= 8839 || i == 8853 || i == 8857 || i == 8869 || i == 8895 || i == 8978 ||
    9312 <= i && i <= 9449 || 9451 <= i && i <= 9547 || 9552 <= i && i <= 9587 || 9600 <= i && i <= 9615 || 9618 <= i && i <= 9621 || 9632 <=
    i && i <= 9633 || 9635 <= i && i <= 9641 || 9650 <= i && i <= 9651 || 9654 <= i && i <= 9655 || 9660 <= i && i <= 9661 || 9664 <= i && i <=
    9665 || 9670 <= i && i <= 9672 || i == 9675 || 9678 <= i && i <= 9681 || 9698 <= i && i <= 9701 || i == 9711 || 9733 <= i && i <= 9734 ||
    i == 9737 || 9742 <= i && i <= 9743 || 9748 <= i && i <= 9749 || i == 9756 || i == 9758 || i == 9792 || i == 9794 || 9824 <= i && i <= 9825 ||
    9827 <= i && i <= 9829 || 9831 <= i && i <= 9834 || 9836 <= i && i <= 9837 || i == 9839 || 9886 <= i && i <= 9887 || 9918 <= i && i <= 9919 ||
    9924 <= i && i <= 9933 || 9935 <= i && i <= 9953 || i == 9955 || 9960 <= i && i <= 9983 || i == 10045 || i == 10071 || 10102 <= i && i <=
    10111 || 11093 <= i && i <= 11097 || 12872 <= i && i <= 12879 || 57344 <= i && i <= 63743 || 65024 <= i && i <= 65039 || i == 65533 || 127232 <=
    i && i <= 127242 || 127248 <= i && i <= 127277 || 127280 <= i && i <= 127337 || 127344 <= i && i <= 127386 || 917760 <= i && i <= 917999 ||
    983040 <= i && i <= 1048573 || 1048576 <= i && i <= 1114109 ? "A" : "N";
  };
  ir.characterLength = function(e) {
    var t = this.eastAsianWidth(e);
    return t == "F" || t == "W" || t == "A" ? 2 : 1;
  };
  function p_(e) {
    return e.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  n(p_, "stringToArray");
  ir.length = function(e) {
    for (var t = p_(e), r = 0, i = 0; i < t.length; i++)
      r = r + this.characterLength(t[i]);
    return r;
  };
  ir.slice = function(e, t, r) {
    textLen = ir.length(e), t = t || 0, r = r || 1, t < 0 && (t = textLen + t), r < 0 && (r = textLen + r);
    for (var i = "", s = 0, o = p_(e), u = 0; u < o.length; u++) {
      var a = o[u], l = ir.length(a);
      if (s >= t - (l == 2 ? 1 : 0))
        if (s + l <= r)
          i += a;
        else
          break;
      s += l;
    }
    return i;
  };
});

// ../node_modules/emoji-regex/index.js
var Yo = g((E9, D_) => {
  "use strict";
  D_.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../node_modules/cli-boxes/boxes.json
var k_ = g((G9, N6) => {
  N6.exports = {
    single: {
      topLeft: "\u250C",
      top: "\u2500",
      topRight: "\u2510",
      right: "\u2502",
      bottomRight: "\u2518",
      bottom: "\u2500",
      bottomLeft: "\u2514",
      left: "\u2502"
    },
    double: {
      topLeft: "\u2554",
      top: "\u2550",
      topRight: "\u2557",
      right: "\u2551",
      bottomRight: "\u255D",
      bottom: "\u2550",
      bottomLeft: "\u255A",
      left: "\u2551"
    },
    round: {
      topLeft: "\u256D",
      top: "\u2500",
      topRight: "\u256E",
      right: "\u2502",
      bottomRight: "\u256F",
      bottom: "\u2500",
      bottomLeft: "\u2570",
      left: "\u2502"
    },
    bold: {
      topLeft: "\u250F",
      top: "\u2501",
      topRight: "\u2513",
      right: "\u2503",
      bottomRight: "\u251B",
      bottom: "\u2501",
      bottomLeft: "\u2517",
      left: "\u2503"
    },
    singleDouble: {
      topLeft: "\u2553",
      top: "\u2500",
      topRight: "\u2556",
      right: "\u2551",
      bottomRight: "\u255C",
      bottom: "\u2500",
      bottomLeft: "\u2559",
      left: "\u2551"
    },
    doubleSingle: {
      topLeft: "\u2552",
      top: "\u2550",
      topRight: "\u2555",
      right: "\u2502",
      bottomRight: "\u255B",
      bottom: "\u2550",
      bottomLeft: "\u2558",
      left: "\u2502"
    },
    classic: {
      topLeft: "+",
      top: "-",
      topRight: "+",
      right: "|",
      bottomRight: "+",
      bottom: "-",
      bottomLeft: "+",
      left: "|"
    },
    arrow: {
      topLeft: "\u2198",
      top: "\u2193",
      topRight: "\u2199",
      right: "\u2190",
      bottomRight: "\u2196",
      bottom: "\u2191",
      bottomLeft: "\u2197",
      left: "\u2192"
    }
  };
});

// ../node_modules/cli-boxes/index.js
var cf = g((J9, lf) => {
  "use strict";
  var B_ = k_();
  lf.exports = B_;
  lf.exports.default = B_;
});

// ../node_modules/string-width/node_modules/ansi-regex/index.js
var I_ = g((Q9, j_) => {
  "use strict";
  j_.exports = ({ onlyFirst: e = !1 } = {}) => {
    let t = [
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
      "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
    ].join("|");
    return new RegExp(t, e ? void 0 : "g");
  };
});

// ../node_modules/string-width/node_modules/strip-ansi/index.js
var N_ = g((X9, L_) => {
  "use strict";
  var G6 = I_();
  L_.exports = (e) => typeof e == "string" ? e.replace(G6(), "") : e;
});

// ../node_modules/is-fullwidth-code-point/index.js
var W_ = g((Z9, df) => {
  "use strict";
  var U_ = /* @__PURE__ */ n((e) => Number.isNaN(e) ? !1 : e >= 4352 && (e <= 4447 || // Hangul Jamo
  e === 9001 || // LEFT-POINTING ANGLE BRACKET
  e === 9002 || // RIGHT-POINTING ANGLE BRACKET
  // CJK Radicals Supplement .. Enclosed CJK Letters and Months
  11904 <= e && e <= 12871 && e !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
  12880 <= e && e <= 19903 || // CJK Unified Ideographs .. Yi Radicals
  19968 <= e && e <= 42182 || // Hangul Jamo Extended-A
  43360 <= e && e <= 43388 || // Hangul Syllables
  44032 <= e && e <= 55203 || // CJK Compatibility Ideographs
  63744 <= e && e <= 64255 || // Vertical Forms
  65040 <= e && e <= 65049 || // CJK Compatibility Forms .. Small Form Variants
  65072 <= e && e <= 65131 || // Halfwidth and Fullwidth Forms
  65281 <= e && e <= 65376 || 65504 <= e && e <= 65510 || // Kana Supplement
  110592 <= e && e <= 110593 || // Enclosed Ideographic Supplement
  127488 <= e && e <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
  131072 <= e && e <= 262141), "isFullwidthCodePoint");
  df.exports = U_;
  df.exports.default = U_;
});

// ../node_modules/string-width/node_modules/emoji-regex/index.js
var H_ = g((tN, $_) => {
  "use strict";
  $_.exports = function() {
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };
});

// ../node_modules/string-width/index.js
var V_ = g((rN, pf) => {
  "use strict";
  var J6 = N_(), Y6 = W_(), K6 = H_(), z_ = /* @__PURE__ */ n((e) => {
    if (typeof e != "string" || e.length === 0 || (e = J6(e), e.length === 0))
      return 0;
    e = e.replace(K6(), "  ");
    let t = 0;
    for (let r = 0; r < e.length; r++) {
      let i = e.codePointAt(r);
      i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879 || (i > 65535 && r++, t += Y6(i) ? 2 : 1);
    }
    return t;
  }, "stringWidth");
  pf.exports = z_;
  pf.exports.default = z_;
});

// ../node_modules/ansi-align/index.js
var J_ = g((nN, G_) => {
  "use strict";
  var Q6 = V_();
  function Fr(e, t) {
    if (!e) return e;
    t = t || {};
    let r = t.align || "center";
    if (r === "left") return e;
    let i = t.split || `
`, s = t.pad || " ", o = r !== "right" ? X6 : Z6, u = !1;
    Array.isArray(e) || (u = !0, e = String(e).split(i));
    let a, l = 0;
    return e = e.map(function(c) {
      return c = String(c), a = Q6(c), l = Math.max(a, l), {
        str: c,
        width: a
      };
    }).map(function(c) {
      return new Array(o(l, c.width) + 1).join(s) + c.str;
    }), u ? e.join(i) : e;
  }
  n(Fr, "ansiAlign");
  Fr.left = /* @__PURE__ */ n(function(t) {
    return Fr(t, { align: "left" });
  }, "left");
  Fr.center = /* @__PURE__ */ n(function(t) {
    return Fr(t, { align: "center" });
  }, "center");
  Fr.right = /* @__PURE__ */ n(function(t) {
    return Fr(t, { align: "right" });
  }, "right");
  G_.exports = Fr;
  function X6(e, t) {
    return Math.floor((e - t) / 2);
  }
  n(X6, "halfDiff");
  function Z6(e, t) {
    return e - t;
  }
  n(Z6, "fullDiff");
});

// ../node_modules/ts-dedent/dist/index.js
var vf = g((Ln) => {
  "use strict";
  Object.defineProperty(Ln, "__esModule", { value: !0 });
  Ln.dedent = void 0;
  function cE(e) {
    for (var t = [], r = 1; r < arguments.length; r++)
      t[r - 1] = arguments[r];
    var i = Array.from(typeof e == "string" ? [e] : e);
    i[i.length - 1] = i[i.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var s = i.reduce(function(a, l) {
      var c = l.match(/\n([\t ]+|(?!\s).)/g);
      return c ? a.concat(c.map(function(h) {
        var p, d;
        return (d = (p = h.match(/[\t ]/g)) === null || p === void 0 ? void 0 : p.length) !== null && d !== void 0 ? d : 0;
      })) : a;
    }, []);
    if (s.length) {
      var o = new RegExp(`
[	 ]{` + Math.min.apply(Math, s) + "}", "g");
      i = i.map(function(a) {
        return a.replace(o, `
`);
      });
    }
    i[0] = i[0].replace(/^\r?\n/, "");
    var u = i[0];
    return t.forEach(function(a, l) {
      var c = u.match(/(?:^|\n)( *)$/), h = c ? c[1] : "", p = a;
      typeof a == "string" && a.includes(`
`) && (p = String(a).split(`
`).map(function(d, f) {
        return f === 0 ? d : "" + h + d;
      }).join(`
`)), u += p + i[l + 1];
    }), u;
  }
  n(cE, "dedent");
  Ln.dedent = cE;
  Ln.default = cE;
});

// src/cli/index.ts
var TP = {};
xE(TP, {
  ANGULAR_JSON_PATH: () => Nn,
  AngularJSON: () => _f,
  CommunityBuilder: () => n_,
  CoreBuilder: () => Gc,
  CoreWebpackCompilers: () => i_,
  ProjectType: () => zo,
  SUPPORTED_ESLINT_EXTENSIONS: () => gE,
  SUPPORTED_RENDERERS: () => XO,
  SupportedLanguage: () => Jc,
  addToDevDependenciesIfNotPresent: () => a6,
  adjustTemplate: () => l_,
  builderNameToCoreBuilder: () => e6,
  coerceSemver: () => d6,
  compilerNameToCoreCompiler: () => ZO,
  compoDocPreviewPrefix: () => gP,
  configureEslintPlugin: () => SP,
  copyTemplate: () => l6,
  copyTemplateFiles: () => f6,
  detect: () => C6,
  detectBuilder: () => w6,
  detectFrameworkPreset: () => d_,
  detectLanguage: () => E6,
  detectPnp: () => _6,
  externalFrameworks: () => Vc,
  extractEslintInfo: () => xP,
  findEslintFile: () => bE,
  frameworkToDefaultBuilder: () => c6,
  frameworkToRenderer: () => u_,
  getBabelDependencies: () => u6,
  getRendererDir: () => Zc,
  getStorybookVersionSpecifier: () => h6,
  getVersionSafe: () => a_,
  hasStorybookDependencies: () => p6,
  installableProjectTypes: () => r6,
  isNxProject: () => ef,
  isStorybookInstantiated: () => v6,
  normalizeExtends: () => ru,
  promptForCompoDocs: () => bP,
  readFileAsJson: () => s6,
  suggestESLintPlugin: () => AP,
  supportedTemplates: () => Yc,
  unsupportedTemplate: () => Kc,
  writeFileAsJson: () => o6
});
module.exports = SE(TP);

// src/cli/detect.ts
var Go = require("node:fs"), c_ = require("node:path"), On = require("@storybook/core/common"), f_ = require("@storybook/core/node-logger");

// node_modules/find-up/index.js
var Sr = G(require("node:path"), 1);

// ../node_modules/locate-path/index.js
var Rf = G(require("node:process"), 1), kf = G(require("node:path"), 1), $n = G(require("node:fs"), 1), Bf = require("node:url");
var Of = {
  directory: "isDirectory",
  file: "isFile"
};
function AE(e) {
  if (!Object.hasOwnProperty.call(Of, e))
    throw new Error(`Invalid type specified: ${e}`);
}
n(AE, "checkType");
var TE = /* @__PURE__ */ n((e, t) => t[Of[e]](), "matchType"), RE = /* @__PURE__ */ n((e) => e instanceof URL ? (0, Bf.fileURLToPath)(e) : e,
"toPath");
function nu(e, {
  cwd: t = Rf.default.cwd(),
  type: r = "file",
  allowSymlinks: i = !0
} = {}) {
  AE(r), t = RE(t);
  let s = i ? $n.default.statSync : $n.default.lstatSync;
  for (let o of e)
    try {
      let u = s(kf.default.resolve(t, o), {
        throwIfNoEntry: !1
      });
      if (!u)
        continue;
      if (TE(r, u))
        return o;
    } catch {
    }
}
n(nu, "locatePathSync");

// ../node_modules/unicorn-magic/node.js
var Pf = require("node:url");
function su(e) {
  return e instanceof URL ? (0, Pf.fileURLToPath)(e) : e;
}
n(su, "toPath");

// node_modules/path-exists/index.js
var qf = G(require("node:fs"), 1);

// node_modules/find-up/index.js
var kE = Symbol("findUpStop");
function BE(e, t = {}) {
  let r = Sr.default.resolve(su(t.cwd) ?? ""), { root: i } = Sr.default.parse(r), s = Sr.default.resolve(r, su(t.stopAt) ?? i), o = t.limit ??
  Number.POSITIVE_INFINITY, u = [e].flat(), a = /* @__PURE__ */ n((c) => {
    if (typeof e != "function")
      return nu(u, c);
    let h = e(c.cwd);
    return typeof h == "string" ? nu([h], c) : h;
  }, "runMatcher"), l = [];
  for (; ; ) {
    let c = a({ ...t, cwd: r });
    if (c === kE || (c && l.push(Sr.default.resolve(r, c)), r === s || l.length >= o))
      break;
    r = Sr.default.dirname(r);
  }
  return l;
}
n(BE, "findUpMultipleSync");
function Ar(e, t = {}) {
  return BE(e, { ...t, limit: 1 })[0];
}
n(Ar, "findUpSync");

// src/cli/detect.ts
var h_ = G(os(), 1), rr = G(require("semver"), 1);

// src/cli/helpers.ts
var tr = require("node:fs"), et = require("node:path"), s_ = require("@storybook/core/common"), o_ = require("@storybook/core/common");

// node_modules/chalk/source/vendor/ansi-styles/index.js
var fD = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), hD = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), dD = /* @__PURE__ */ n((e = 0) => (t, r, i) => `\x1B[${38 + e};2;${t};${r};${i}m`, "wrapAnsi16m"), ue = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, hj = Object.keys(ue.modifier), jx = Object.keys(ue.color), Ix = Object.keys(ue.bgColor), dj = [...jx, ...Ix];
function Lx() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(ue)) {
    for (let [i, s] of Object.entries(r))
      ue[i] = {
        open: `\x1B[${s[0]}m`,
        close: `\x1B[${s[1]}m`
      }, r[i] = ue[i], e.set(s[0], s[1]);
    Object.defineProperty(ue, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(ue, "codes", {
    value: e,
    enumerable: !1
  }), ue.color.close = "\x1B[39m", ue.bgColor.close = "\x1B[49m", ue.color.ansi = fD(), ue.color.ansi256 = hD(), ue.color.ansi16m = dD(), ue.
  bgColor.ansi = fD(10), ue.bgColor.ansi256 = hD(10), ue.bgColor.ansi16m = dD(10), Object.defineProperties(ue, {
    rgbToAnsi256: {
      value(t, r, i) {
        return t === r && r === i ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 *
        Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [i] = r;
        i.length === 3 && (i = [...i].map((o) => o + o).join(""));
        let s = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          s >> 16 & 255,
          s >> 8 & 255,
          s & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ n((t) => ue.rgbToAnsi256(...ue.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, i, s;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, i = r, s = r;
        else {
          t -= 16;
          let a = t % 36;
          r = Math.floor(t / 36) / 5, i = Math.floor(a / 6) / 5, s = a % 6 / 5;
        }
        let o = Math.max(r, i, s) * 2;
        if (o === 0)
          return 30;
        let u = 30 + (Math.round(s) << 2 | Math.round(i) << 1 | Math.round(r));
        return o === 2 && (u += 60), u;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ n((t, r, i) => ue.ansi256ToAnsi(ue.rgbToAnsi256(t, r, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ n((t) => ue.ansi256ToAnsi(ue.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), ue;
}
n(Lx, "assembleStyles");
var Nx = Lx(), Qe = Nx;

// node_modules/chalk/source/vendor/supports-color/index.js
var as = G(require("node:process"), 1), DD = G(require("node:os"), 1), ya = G(require("node:tty"), 1);
function He(e, t = globalThis.Deno ? globalThis.Deno.args : as.default.argv) {
  let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), s = t.indexOf("--");
  return i !== -1 && (s === -1 || i < s);
}
n(He, "hasFlag");
var { env: de } = as.default, us;
He("no-color") || He("no-colors") || He("color=false") || He("color=never") ? us = 0 : (He("color") || He("colors") || He("color=true") || He(
"color=always")) && (us = 1);
function Ux() {
  if ("FORCE_COLOR" in de)
    return de.FORCE_COLOR === "true" ? 1 : de.FORCE_COLOR === "false" ? 0 : de.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(de.FORCE_COLOR,
    10), 3);
}
n(Ux, "envForceColor");
function Wx(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
n(Wx, "translateLevel");
function $x(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  let i = Ux();
  i !== void 0 && (us = i);
  let s = r ? us : i;
  if (s === 0)
    return 0;
  if (r) {
    if (He("color=16m") || He("color=full") || He("color=truecolor"))
      return 3;
    if (He("color=256"))
      return 2;
  }
  if ("TF_BUILD" in de && "AGENT_NAME" in de)
    return 1;
  if (e && !t && s === void 0)
    return 0;
  let o = s || 0;
  if (de.TERM === "dumb")
    return o;
  if (as.default.platform === "win32") {
    let u = DD.default.release().split(".");
    return Number(u[0]) >= 10 && Number(u[2]) >= 10586 ? Number(u[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in de)
    return "GITHUB_ACTIONS" in de || "GITEA_ACTIONS" in de ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some(
    (u) => u in de) || de.CI_NAME === "codeship" ? 1 : o;
  if ("TEAMCITY_VERSION" in de)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(de.TEAMCITY_VERSION) ? 1 : 0;
  if (de.COLORTERM === "truecolor" || de.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in de) {
    let u = Number.parseInt((de.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (de.TERM_PROGRAM) {
      case "iTerm.app":
        return u >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(de.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(de.TERM) || "COLORTERM" in de ?
  1 : o;
}
n($x, "_supportsColor");
function pD(e, t = {}) {
  let r = $x(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return Wx(r);
}
n(pD, "createSupportsColor");
var Hx = {
  stdout: pD({ isTTY: ya.default.isatty(1) }),
  stderr: pD({ isTTY: ya.default.isatty(2) })
}, mD = Hx;

// node_modules/chalk/source/utilities.js
function yD(e, t, r) {
  let i = e.indexOf(t);
  if (i === -1)
    return e;
  let s = t.length, o = 0, u = "";
  do
    u += e.slice(o, i) + t + r, o = i + s, i = e.indexOf(t, o);
  while (i !== -1);
  return u += e.slice(o), u;
}
n(yD, "stringReplaceAll");
function gD(e, t, r, i) {
  let s = 0, o = "";
  do {
    let u = e[i - 1] === "\r";
    o += e.slice(s, u ? i - 1 : i) + t + (u ? `\r
` : `
`) + r, s = i + 1, i = e.indexOf(`
`, s);
  } while (i !== -1);
  return o += e.slice(s), o;
}
n(gD, "stringEncaseCRLFWithFirstIndex");

// node_modules/chalk/source/index.js
var { stdout: bD, stderr: wD } = mD, ga = Symbol("GENERATOR"), Or = Symbol("STYLER"), Bi = Symbol("IS_EMPTY"), vD = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Pr = /* @__PURE__ */ Object.create(null), zx = /* @__PURE__ */ n((e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let r = bD ? bD.level : 0;
  e.level = t.level === void 0 ? r : t.level;
}, "applyOptions");
var Vx = /* @__PURE__ */ n((e) => {
  let t = /* @__PURE__ */ n((...r) => r.join(" "), "chalk");
  return zx(t, e), Object.setPrototypeOf(t, Oi.prototype), t;
}, "chalkFactory");
function Oi(e) {
  return Vx(e);
}
n(Oi, "createChalk");
Object.setPrototypeOf(Oi.prototype, Function.prototype);
for (let [e, t] of Object.entries(Qe))
  Pr[e] = {
    get() {
      let r = ls(this, wa(t.open, t.close, this[Or]), this[Bi]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Pr.visible = {
  get() {
    let e = ls(this, this[Or], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
var ba = /* @__PURE__ */ n((e, t, r, ...i) => e === "rgb" ? t === "ansi16m" ? Qe[r].ansi16m(...i) : t === "ansi256" ? Qe[r].ansi256(Qe.rgbToAnsi256(
...i)) : Qe[r].ansi(Qe.rgbToAnsi(...i)) : e === "hex" ? ba("rgb", t, r, ...Qe.hexToRgb(...i)) : Qe[r][e](...i), "getModelAnsi"), Gx = ["rgb",
"hex", "ansi256"];
for (let e of Gx) {
  Pr[e] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let s = wa(ba(e, vD[r], "color", ...i), Qe.color.close, this[Or]);
        return ls(this, s, this[Bi]);
      };
    }
  };
  let t = "bg" + e[0].toUpperCase() + e.slice(1);
  Pr[t] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let s = wa(ba(e, vD[r], "bgColor", ...i), Qe.bgColor.close, this[Or]);
        return ls(this, s, this[Bi]);
      };
    }
  };
}
var Jx = Object.defineProperties(() => {
}, {
  ...Pr,
  level: {
    enumerable: !0,
    get() {
      return this[ga].level;
    },
    set(e) {
      this[ga].level = e;
    }
  }
}), wa = /* @__PURE__ */ n((e, t, r) => {
  let i, s;
  return r === void 0 ? (i = e, s = t) : (i = r.openAll + e, s = t + r.closeAll), {
    open: e,
    close: t,
    openAll: i,
    closeAll: s,
    parent: r
  };
}, "createStyler"), ls = /* @__PURE__ */ n((e, t, r) => {
  let i = /* @__PURE__ */ n((...s) => Yx(i, s.length === 1 ? "" + s[0] : s.join(" ")), "builder");
  return Object.setPrototypeOf(i, Jx), i[ga] = e, i[Or] = t, i[Bi] = r, i;
}, "createBuilder"), Yx = /* @__PURE__ */ n((e, t) => {
  if (e.level <= 0 || !t)
    return e[Bi] ? "" : t;
  let r = e[Or];
  if (r === void 0)
    return t;
  let { openAll: i, closeAll: s } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = yD(t, r.close, r.open), r = r.parent;
  let o = t.indexOf(`
`);
  return o !== -1 && (t = gD(t, s, i, o)), i + t + s;
}, "applyStyle");
Object.defineProperties(Oi.prototype, Pr);
var Kx = Oi(), Ej = Oi({ level: wD ? wD.level : 0 });
var cs = Kx;

// src/cli/helpers.ts
var Pe = G(qa(), 1), Er = require("semver");

// ../node_modules/strip-json-comments/index.js
var Ma = Symbol("singleComment"), Dy = Symbol("multiComment"), XS = /* @__PURE__ */ n(() => "", "stripWithoutWhitespace"), ZS = /* @__PURE__ */ n(
(e, t, r) => e.slice(t, r).replace(/\S/g, " "), "stripWithWhitespace"), e3 = /* @__PURE__ */ n((e, t) => {
  let r = t - 1, i = 0;
  for (; e[r] === "\\"; )
    r -= 1, i += 1;
  return !!(i % 2);
}, "isEscaped");
function ja(e, { whitespace: t = !0, trailingCommas: r = !1 } = {}) {
  if (typeof e != "string")
    throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof e}\``);
  let i = t ? ZS : XS, s = !1, o = !1, u = 0, a = "", l = "", c = -1;
  for (let h = 0; h < e.length; h++) {
    let p = e[h], d = e[h + 1];
    if (!o && p === '"' && (e3(e, h) || (s = !s)), !s)
      if (!o && p + d === "//")
        a += e.slice(u, h), u = h, o = Ma, h++;
      else if (o === Ma && p + d === `\r
`) {
        h++, o = !1, a += i(e, u, h), u = h;
        continue;
      } else if (o === Ma && p === `
`)
        o = !1, a += i(e, u, h), u = h;
      else if (!o && p + d === "/*") {
        a += e.slice(u, h), u = h, o = Dy, h++;
        continue;
      } else if (o === Dy && p + d === "*/") {
        h++, o = !1, a += i(e, u, h + 1), u = h + 1;
        continue;
      } else r && !o && (c !== -1 ? p === "}" || p === "]" ? (a += e.slice(u, h), l += i(a, 0, 1) + a.slice(1), a = "", u = h, c = -1) : p !==
      " " && p !== "	" && p !== "\r" && p !== `
` && (a += e.slice(u, h), u = h, c = -1) : p === "," && (l += a + e.slice(u, h), a = "", u = h, c = h));
  }
  return l + a + (o ? i(e.slice(u)) : e.slice(u));
}
n(ja, "stripJsonComments");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var t3 = process.env.NODE_ENV === "production", Ia = "Invariant failed";
function Ui(e, t) {
  if (!e) {
    if (t3)
      throw new Error(Ia);
    var r = typeof t == "function" ? t() : t, i = r ? "".concat(Ia, ": ").concat(r) : Ia;
    throw new Error(i);
  }
}
n(Ui, "invariant");

// src/cli/dirs.ts
var Bn = require("node:path"), Vo = require("@storybook/core/common"), Qc = G(Xv(), 1), Xc = G(t_(), 1);

// src/cli/project_types.ts
var Ho = require("semver");
function r_(e, t) {
  return (0, Ho.validRange)(e) ? (0, Ho.minVersion)(e)?.major === t : !1;
}
n(r_, "eqMajor");
var Vc = [
  { name: "qwik", packageName: "storybook-framework-qwik" },
  { name: "solid", frameworks: ["storybook-solidjs-vite"], renderer: "storybook-solidjs" }
], XO = [
  "react",
  "react-native",
  "vue3",
  "angular",
  "ember",
  "preact",
  "svelte",
  "qwik",
  "solid"
], zo = /* @__PURE__ */ ((E) => (E.UNDETECTED = "UNDETECTED", E.UNSUPPORTED = "UNSUPPORTED", E.REACT = "REACT", E.REACT_SCRIPTS = "REACT_SCR\
IPTS", E.REACT_NATIVE = "REACT_NATIVE", E.REACT_PROJECT = "REACT_PROJECT", E.WEBPACK_REACT = "WEBPACK_REACT", E.NEXTJS = "NEXTJS", E.VUE3 = "\
VUE3", E.ANGULAR = "ANGULAR", E.EMBER = "EMBER", E.WEB_COMPONENTS = "WEB_COMPONENTS", E.HTML = "HTML", E.QWIK = "QWIK", E.PREACT = "PREACT",
E.SVELTE = "SVELTE", E.SVELTEKIT = "SVELTEKIT", E.SERVER = "SERVER", E.NX = "NX", E.SOLID = "SOLID", E))(zo || {}), Gc = /* @__PURE__ */ ((r) => (r.
Webpack5 = "webpack5", r.Vite = "vite", r))(Gc || {}), i_ = /* @__PURE__ */ ((r) => (r.Babel = "babel", r.SWC = "swc", r))(i_ || {}), n_ = /* @__PURE__ */ ((t) => (t.
Rsbuild = "rsbuild", t))(n_ || {}), ZO = {
  "@storybook/addon-webpack5-compiler-babel": "babel",
  "@storybook/addon-webpack5-compiler-swc": "swc"
}, e6 = {
  "@storybook/builder-webpack5": "webpack5",
  "@storybook/builder-vite": "vite"
}, Jc = /* @__PURE__ */ ((i) => (i.JAVASCRIPT = "javascript", i.TYPESCRIPT_3_8 = "typescript-3-8", i.TYPESCRIPT_4_9 = "typescript-4-9", i))(
Jc || {}), Yc = [
  {
    preset: "VUE3",
    dependencies: {
      // This Vue template works with Vue 3
      vue: /* @__PURE__ */ n((e) => e === "next" || r_(e, 3), "vue")
    },
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
  },
  {
    preset: "EMBER",
    dependencies: ["ember-cli"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "NEXTJS",
    dependencies: ["next"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "QWIK",
    dependencies: ["@builder.io/qwik"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "REACT_PROJECT",
    peerDependencies: ["react"],
    matcherFunction: /* @__PURE__ */ n(({ peerDependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "REACT_NATIVE",
    dependencies: ["react-native", "react-native-scripts"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
  },
  {
    preset: "REACT_SCRIPTS",
    // For projects using a custom/forked `react-scripts` package.
    files: ["/node_modules/.bin/react-scripts"],
    // For standard CRA projects
    dependencies: ["react-scripts"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e, files: t }) => (e?.every(Boolean) || t?.every(Boolean)) ?? !1, "matcherFunction")
  },
  {
    preset: "ANGULAR",
    dependencies: ["@angular/core"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "WEB_COMPONENTS",
    dependencies: ["lit-element", "lit-html", "lit"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
  },
  {
    preset: "PREACT",
    dependencies: ["preact"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    // TODO: This only works because it is before the SVELTE template. could be more explicit
    preset: "SVELTEKIT",
    dependencies: ["@sveltejs/kit"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "SVELTE",
    dependencies: ["svelte"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "SOLID",
    dependencies: ["solid-js"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  // DO NOT MOVE ANY TEMPLATES BELOW THIS LINE
  // React is part of every Template, after Storybook is initialized once
  {
    preset: "WEBPACK_REACT",
    dependencies: ["react", "webpack"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  },
  {
    preset: "REACT",
    dependencies: ["react"],
    matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.every(Boolean) ?? !0, "matcherFunction")
  }
], Kc = {
  preset: "UNSUPPORTED",
  dependencies: {
    // TODO(blaine): Remove when we support Nuxt 3
    nuxt: /* @__PURE__ */ n((e) => r_(e, 3), "nuxt")
  },
  matcherFunction: /* @__PURE__ */ n(({ dependencies: e }) => e?.some(Boolean) ?? !1, "matcherFunction")
}, t6 = [
  "UNDETECTED",
  "UNSUPPORTED",
  "NX"
], r6 = Object.values(zo).filter((e) => !t6.includes(e)).map((e) => e.toLowerCase());

// src/cli/dirs.ts
var i6 = /* @__PURE__ */ n(async (e, t) => {
  let r = await (0, Vo.temporaryDirectory)(), s = Vo.versions[t] || await e.latestVersion(t), o = Xc.default.default || Xc.default, u = Qc.default.
  default || Qc.default, a = o(t, s, {
    registry: await e.getRegistryURL()
  });
  return await u({ url: a, dir: r }), (0, Bn.join)(r, "package");
}, "resolveUsingBranchInstall");
async function Zc(e, t) {
  let r = Vc.find((u) => u.name === t), i = r?.renderer || r?.packageName || `@storybook/${t}`, s = (0, Bn.join)(i, "package.json"), o = [];
  try {
    return (0, Bn.dirname)(
      require.resolve(s, {
        paths: [process.cwd()]
      })
    );
  } catch (u) {
    Ui(u instanceof Error), o.push(u);
  }
  try {
    return await i6(e, i);
  } catch (u) {
    Ui(u instanceof Error), o.push(u);
  }
  throw new Error(`Cannot find ${s}, ${o.map((u) => u.stack).join(`

`)}`);
}
n(Zc, "getRendererDir");

// src/cli/helpers.ts
var n6 = console;
function s6(e, t) {
  let r = (0, et.resolve)(e);
  if (!(0, tr.existsSync)(r))
    return !1;
  let i = (0, tr.readFileSync)(r, "utf8"), s = t ? ja(i) : i;
  try {
    return JSON.parse(s);
  } catch (o) {
    throw n6.error(cs.red(`Invalid json in file: ${r}`)), o;
  }
}
n(s6, "readFileAsJson");
var o6 = /* @__PURE__ */ n((e, t) => {
  let r = (0, et.resolve)(e);
  return (0, tr.existsSync)(r) ? ((0, tr.writeFileSync)(r, `${JSON.stringify(t, null, 2)}
`), !0) : !1;
}, "writeFileAsJson");
async function u6(e, t) {
  let r = [], i = "^8.0.0-0", s = t.dependencies["babel-core"] || t.devDependencies["babel-core"];
  if (s) {
    let o = await e.latestVersion(
      "babel-core",
      s
    );
    (0, Er.satisfies)(o, "^6.0.0") && (i = "^7.0.0");
  } else if (!t.dependencies["@babel/core"] && !t.devDependencies["@babel/core"]) {
    let o = await e.getVersion("@babel/core");
    r.push(`@babel/core@${o}`);
  }
  if (!t.dependencies["babel-loader"] && !t.devDependencies["babel-loader"]) {
    let o = await e.getVersion(
      "babel-loader",
      i
    );
    r.push(`babel-loader@${o}`);
  }
  return r;
}
n(u6, "getBabelDependencies");
function a6(e, t, r) {
  !e.dependencies?.[t] && !e.devDependencies?.[t] && (e.devDependencies ? e.devDependencies[t] = r : e.devDependencies = {
    [t]: r
  });
}
n(a6, "addToDevDependenciesIfNotPresent");
function l6(e, t = ".") {
  let r = (0, et.resolve)(e, "template-csf/");
  if (!(0, tr.existsSync)(r))
    throw new Error("Couldn't find template dir");
  (0, Pe.copySync)(r, t, { overwrite: !0 });
}
n(l6, "copyTemplate");
var u_ = s_.frameworkToRenderer, c6 = {
  angular: "webpack5",
  ember: "webpack5",
  "html-vite": "vite",
  "html-webpack5": "webpack5",
  nextjs: "webpack5",
  "experimental-nextjs-vite": "vite",
  "preact-vite": "vite",
  "preact-webpack5": "webpack5",
  qwik: "vite",
  "react-vite": "vite",
  "react-webpack5": "webpack5",
  "server-webpack5": "webpack5",
  solid: "vite",
  "svelte-vite": "vite",
  "svelte-webpack5": "webpack5",
  sveltekit: "vite",
  "vue3-vite": "vite",
  "vue3-webpack5": "webpack5",
  "web-components-vite": "vite",
  "web-components-webpack5": "webpack5",
  // Only to pass type checking, will never be used
  "react-rsbuild": "rsbuild",
  "vue3-rsbuild": "rsbuild"
};
async function a_(e, t) {
  try {
    let r = await e.getInstalledVersion(t);
    return r || (r = (await e.getAllDependencies())[t] ?? ""), (0, Er.coerce)(r, { includePrerelease: !0 })?.toString();
  } catch {
  }
}
n(a_, "getVersionSafe");
async function f6({
  packageManager: e,
  renderer: t,
  language: r,
  destination: i,
  commonAssetsDir: s
}) {
  let o = {
    // keeping this for backwards compatibility in case community packages are using it
    typescript: "ts",
    javascript: "js",
    "typescript-3-8": "ts-3-8",
    "typescript-4-9": "ts-4-9"
  };
  if (t === "svelte") {
    let c = await a_(e, "svelte");
    c && (0, Er.major)(c) >= 5 && (o = {
      // keeping this for backwards compatibility in case community packages are using it
      typescript: "ts",
      javascript: "svelte-5-js",
      "typescript-3-8": "svelte-5-ts-3-8",
      "typescript-4-9": "svelte-5-ts-4-9"
    });
  }
  let u = /* @__PURE__ */ n(async () => {
    let c = await Zc(e, t), h = (0, et.join)(c, "template", "cli"), p = (0, et.join)(h, o[r]), d = (0, et.join)(h, o.javascript), f = (0, et.join)(
    h, o.typescript), m = (0, et.join)(h, o["typescript-3-8"]);
    if (await (0, Pe.pathExists)(p))
      return p;
    if (r === "typescript-4-9" && await (0, Pe.pathExists)(m))
      return m;
    if (await (0, Pe.pathExists)(f))
      return f;
    if (await (0, Pe.pathExists)(d))
      return d;
    if (await (0, Pe.pathExists)(h))
      return h;
    throw new Error(`Unsupported renderer: ${t} (${c})`);
  }, "templatePath"), l = i ?? await (/* @__PURE__ */ n(async () => await (0, Pe.pathExists)("./src") ? "./src/stories" : "./stories", "targ\
etPath"))();
  if (s && await (0, Pe.copy)(s, l, {
    overwrite: !0
  }), await (0, Pe.copy)(await u(), l, { overwrite: !0 }), s) {
    let c = u_[t] || "react";
    c === "vue3" && (c = "vue"), await l_((0, et.join)(l, "Configure.mdx"), { renderer: c });
  }
}
n(f6, "copyTemplateFiles");
async function l_(e, t) {
  let r = await (0, Pe.readFile)(e, "utf8");
  Object.keys(t).forEach((i) => {
    r = r.replaceAll(`{{${i}}}`, `${t[i]}`);
  }), await (0, Pe.writeFile)(e, r);
}
n(l_, "adjustTemplate");
function h6(e) {
  let t = {
    ...e.dependencies,
    ...e.devDependencies,
    ...e.optionalDependencies
  }, r = Object.keys(t).find((i) => o_.versions[i]);
  if (!r)
    throw new Error("Couldn't find any official storybook packages in package.json");
  return t[r];
}
n(h6, "getStorybookVersionSpecifier");
async function ef() {
  return Ar("nx.json");
}
n(ef, "isNxProject");
function d6(e) {
  let t = (0, Er.coerce)(e);
  return Ui(t != null, `Could not coerce ${e} into a semver.`), t;
}
n(d6, "coerceSemver");
async function p6(e) {
  let t = await e.getAllDependencies();
  return Object.keys(t).some((r) => r.includes("storybook"));
}
n(p6, "hasStorybookDependencies");

// src/cli/detect.ts
var D6 = ["vite.config.ts", "vite.config.js", "vite.config.mjs"], m6 = ["webpack.config.js"], y6 = /* @__PURE__ */ n((e, t, r) => {
  let i = e.dependencies?.[t] || e.devDependencies?.[t];
  return i && typeof r == "function" ? r(i) : !!i;
}, "hasDependency"), g6 = /* @__PURE__ */ n((e, t, r) => {
  let i = e.peerDependencies?.[t];
  return i && typeof r == "function" ? r(i) : !!i;
}, "hasPeerDependency"), b6 = /* @__PURE__ */ n((e, t) => {
  let r = {
    dependencies: [!1],
    peerDependencies: [!1],
    files: [!1]
  }, { preset: i, files: s, dependencies: o, peerDependencies: u, matcherFunction: a } = t, l = [];
  Array.isArray(o) ? l = o.map((h) => [h, void 0]) : typeof o == "object" && (l = Object.entries(o)), l.length > 0 && (r.dependencies = l.map(
    ([h, p]) => y6(e, h, p)
  ));
  let c = [];
  return Array.isArray(u) ? c = u.map((h) => [h, void 0]) : typeof u == "object" && (c = Object.entries(u)), c.length > 0 && (r.peerDependencies =
  c.map(
    ([h, p]) => g6(e, h, p)
  )), Array.isArray(s) && s.length > 0 && (r.files = s.map((h) => (0, Go.existsSync)(h))), a(r) ? i : null;
}, "getFrameworkPreset");
function d_(e = {}) {
  let t = [...Yc, Kc].find((r) => b6(e, r) !== null);
  return t ? t.preset : "UNDETECTED";
}
n(d_, "detectFrameworkPreset");
async function w6(e, t) {
  let r = Ar(D6), i = Ar(m6), s = await e.getAllDependencies();
  if (r || s.vite && s.webpack === void 0)
    return (0, On.commandLog)("Detected Vite project. Setting builder to Vite")(), "vite";
  if (i || s.webpack && s.vite !== void 0)
    return (0, On.commandLog)("Detected webpack project. Setting builder to webpack")(), "webpack5";
  switch (t) {
    case "REACT_SCRIPTS":
    case "ANGULAR":
    case "REACT_NATIVE":
    case "NEXTJS":
    case "EMBER":
      return "webpack5";
    default:
      let { builder: o } = await (0, h_.default)(
        {
          type: "select",
          name: "builder",
          message: `
We were not able to detect the right builder for your project. Please select one:`,
          choices: [
            { title: "Vite", value: "vite" },
            { title: "Webpack 5", value: "webpack5" }
          ]
        },
        {
          onCancel: /* @__PURE__ */ n(() => {
            throw new On.HandledError("Canceled by the user");
          }, "onCancel")
        }
      );
      return o;
  }
}
n(w6, "detectBuilder");
function v6(e = (0, c_.resolve)(process.cwd(), ".storybook")) {
  return (0, Go.existsSync)(e);
}
n(v6, "isStorybookInstantiated");
async function _6() {
  return !!Ar([".pnp.js", ".pnp.cjs"]);
}
n(_6, "detectPnp");
async function E6(e) {
  let t = "javascript";
  if ((0, Go.existsSync)("jsconfig.json"))
    return t;
  let r = await e.getAllDependencies().then((l) => !!l.typescript), i = await e.getPackageVersion("typescript"), s = await e.getPackageVersion(
  "prettier"), o = await e.getPackageVersion(
    "@babel/plugin-transform-typescript"
  ), u = await e.getPackageVersion(
    "@typescript-eslint/parser"
  ), a = await e.getPackageVersion("eslint-plugin-storybook");
  return r && i && (rr.default.gte(i, "4.9.0") && (!s || rr.default.gte(s, "2.8.0")) && (!o || rr.default.gte(o, "7.20.0")) && (!u || rr.default.
  gte(u, "5.44.0")) && (!a || rr.default.gte(a, "0.6.8")) ? t = "typescript-4-9" : rr.default.gte(i, "3.8.0") ? t = "typescript-3-8" : rr.default.
  lt(i, "3.8.0") && f_.logger.warn("Detected TypeScript < 3.8, populating with JavaScript examples")), t;
}
n(E6, "detectLanguage");
async function C6(e, t = {}) {
  let r = await e.retrievePackageJson();
  return r ? await ef() ? "NX" : t.html ? "HTML" : d_(r) : "UNDETECTED";
}
n(C6, "detect");

// src/cli/angular/helpers.ts
var mi = require("node:fs"), fE = require("node:path"), hE = require("@storybook/core/node-logger"), dE = require("@storybook/core/server-errors");

// ../node_modules/boxen/index.js
var Mn = G(require("node:process"), 1);

// ../node_modules/ansi-regex/index.js
function tf({ onlyFirst: e = !1 } = {}) {
  let t = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(t, e ? void 0 : "g");
}
n(tf, "ansiRegex");

// ../node_modules/strip-ansi/index.js
var F6 = tf();
function It(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(F6, "");
}
n(It, "stripAnsi");

// ../node_modules/boxen/node_modules/string-width/index.js
var m_ = G(Jo(), 1), y_ = G(Yo(), 1);
function Dt(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = It(e), e.length === 0))
    return 0;
  e = e.replace((0, y_.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, i = 0;
  for (let s of e) {
    let o = s.codePointAt(0);
    if (o <= 31 || o >= 127 && o <= 159 || o >= 768 && o <= 879)
      continue;
    switch (m_.default.eastAsianWidth(s)) {
      case "F":
      case "W":
        i += 2;
        break;
      case "A":
        i += r;
        break;
      default:
        i += 1;
    }
  }
  return i;
}
n(Dt, "stringWidth");

// ../node_modules/boxen/node_modules/chalk/source/vendor/ansi-styles/index.js
var g_ = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), b_ = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), w_ = /* @__PURE__ */ n((e = 0) => (t, r, i) => `\x1B[${38 + e};2;${t};${r};${i}m`, "wrapAnsi16m"), ae = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, S9 = Object.keys(ae.modifier), x6 = Object.keys(ae.color), S6 = Object.keys(ae.bgColor), A9 = [...x6, ...S6];
function A6() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(ae)) {
    for (let [i, s] of Object.entries(r))
      ae[i] = {
        open: `\x1B[${s[0]}m`,
        close: `\x1B[${s[1]}m`
      }, r[i] = ae[i], e.set(s[0], s[1]);
    Object.defineProperty(ae, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(ae, "codes", {
    value: e,
    enumerable: !1
  }), ae.color.close = "\x1B[39m", ae.bgColor.close = "\x1B[49m", ae.color.ansi = g_(), ae.color.ansi256 = b_(), ae.color.ansi16m = w_(), ae.
  bgColor.ansi = g_(10), ae.bgColor.ansi256 = b_(10), ae.bgColor.ansi16m = w_(10), Object.defineProperties(ae, {
    rgbToAnsi256: {
      value(t, r, i) {
        return t === r && r === i ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(t / 255 * 5) + 6 *
        Math.round(r / 255 * 5) + Math.round(i / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(t) {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [i] = r;
        i.length === 3 && (i = [...i].map((o) => o + o).join(""));
        let s = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          s >> 16 & 255,
          s >> 8 & 255,
          s & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ n((t) => ae.rgbToAnsi256(...ae.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(t) {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, i, s;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, i = r, s = r;
        else {
          t -= 16;
          let a = t % 36;
          r = Math.floor(t / 36) / 5, i = Math.floor(a / 6) / 5, s = a % 6 / 5;
        }
        let o = Math.max(r, i, s) * 2;
        if (o === 0)
          return 30;
        let u = 30 + (Math.round(s) << 2 | Math.round(i) << 1 | Math.round(r));
        return o === 2 && (u += 60), u;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ n((t, r, i) => ae.ansi256ToAnsi(ae.rgbToAnsi256(t, r, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ n((t) => ae.ansi256ToAnsi(ae.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), ae;
}
n(A6, "assembleStyles");
var T6 = A6(), tt = T6;

// ../node_modules/boxen/node_modules/chalk/source/vendor/supports-color/index.js
var Qo = G(require("node:process"), 1), __ = G(require("node:os"), 1), nf = G(require("node:tty"), 1);
function Je(e, t = globalThis.Deno ? globalThis.Deno.args : Qo.default.argv) {
  let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", i = t.indexOf(r + e), s = t.indexOf("--");
  return i !== -1 && (s === -1 || i < s);
}
n(Je, "hasFlag");
var { env: De } = Qo.default, Ko;
Je("no-color") || Je("no-colors") || Je("color=false") || Je("color=never") ? Ko = 0 : (Je("color") || Je("colors") || Je("color=true") || Je(
"color=always")) && (Ko = 1);
function R6() {
  if ("FORCE_COLOR" in De)
    return De.FORCE_COLOR === "true" ? 1 : De.FORCE_COLOR === "false" ? 0 : De.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(De.FORCE_COLOR,
    10), 3);
}
n(R6, "envForceColor");
function k6(e) {
  return e === 0 ? !1 : {
    level: e,
    hasBasic: !0,
    has256: e >= 2,
    has16m: e >= 3
  };
}
n(k6, "translateLevel");
function B6(e, { streamIsTTY: t, sniffFlags: r = !0 } = {}) {
  let i = R6();
  i !== void 0 && (Ko = i);
  let s = r ? Ko : i;
  if (s === 0)
    return 0;
  if (r) {
    if (Je("color=16m") || Je("color=full") || Je("color=truecolor"))
      return 3;
    if (Je("color=256"))
      return 2;
  }
  if ("TF_BUILD" in De && "AGENT_NAME" in De)
    return 1;
  if (e && !t && s === void 0)
    return 0;
  let o = s || 0;
  if (De.TERM === "dumb")
    return o;
  if (Qo.default.platform === "win32") {
    let u = __.default.release().split(".");
    return Number(u[0]) >= 10 && Number(u[2]) >= 10586 ? Number(u[2]) >= 14931 ? 3 : 2 : 1;
  }
  if ("CI" in De)
    return "GITHUB_ACTIONS" in De || "GITEA_ACTIONS" in De ? 3 : ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some(
    (u) => u in De) || De.CI_NAME === "codeship" ? 1 : o;
  if ("TEAMCITY_VERSION" in De)
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(De.TEAMCITY_VERSION) ? 1 : 0;
  if (De.COLORTERM === "truecolor" || De.TERM === "xterm-kitty")
    return 3;
  if ("TERM_PROGRAM" in De) {
    let u = Number.parseInt((De.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (De.TERM_PROGRAM) {
      case "iTerm.app":
        return u >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  return /-256(color)?$/i.test(De.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(De.TERM) || "COLORTERM" in De ?
  1 : o;
}
n(B6, "_supportsColor");
function v_(e, t = {}) {
  let r = B6(e, {
    streamIsTTY: e && e.isTTY,
    ...t
  });
  return k6(r);
}
n(v_, "createSupportsColor");
var O6 = {
  stdout: v_({ isTTY: nf.default.isatty(1) }),
  stderr: v_({ isTTY: nf.default.isatty(2) })
}, E_ = O6;

// ../node_modules/boxen/node_modules/chalk/source/utilities.js
function C_(e, t, r) {
  let i = e.indexOf(t);
  if (i === -1)
    return e;
  let s = t.length, o = 0, u = "";
  do
    u += e.slice(o, i) + t + r, o = i + s, i = e.indexOf(t, o);
  while (i !== -1);
  return u += e.slice(o), u;
}
n(C_, "stringReplaceAll");
function F_(e, t, r, i) {
  let s = 0, o = "";
  do {
    let u = e[i - 1] === "\r";
    o += e.slice(s, u ? i - 1 : i) + t + (u ? `\r
` : `
`) + r, s = i + 1, i = e.indexOf(`
`, s);
  } while (i !== -1);
  return o += e.slice(s), o;
}
n(F_, "stringEncaseCRLFWithFirstIndex");

// ../node_modules/boxen/node_modules/chalk/source/index.js
var { stdout: x_, stderr: S_ } = E_, sf = Symbol("GENERATOR"), pi = Symbol("STYLER"), Pn = Symbol("IS_EMPTY"), A_ = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], Di = /* @__PURE__ */ Object.create(null), P6 = /* @__PURE__ */ n((e, t = {}) => {
  if (t.level && !(Number.isInteger(t.level) && t.level >= 0 && t.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  let r = x_ ? x_.level : 0;
  e.level = t.level === void 0 ? r : t.level;
}, "applyOptions");
var q6 = /* @__PURE__ */ n((e) => {
  let t = /* @__PURE__ */ n((...r) => r.join(" "), "chalk");
  return P6(t, e), Object.setPrototypeOf(t, qn.prototype), t;
}, "chalkFactory");
function qn(e) {
  return q6(e);
}
n(qn, "createChalk");
Object.setPrototypeOf(qn.prototype, Function.prototype);
for (let [e, t] of Object.entries(tt))
  Di[e] = {
    get() {
      let r = Xo(this, uf(t.open, t.close, this[pi]), this[Pn]);
      return Object.defineProperty(this, e, { value: r }), r;
    }
  };
Di.visible = {
  get() {
    let e = Xo(this, this[pi], !0);
    return Object.defineProperty(this, "visible", { value: e }), e;
  }
};
var of = /* @__PURE__ */ n((e, t, r, ...i) => e === "rgb" ? t === "ansi16m" ? tt[r].ansi16m(...i) : t === "ansi256" ? tt[r].ansi256(tt.rgbToAnsi256(
...i)) : tt[r].ansi(tt.rgbToAnsi(...i)) : e === "hex" ? of("rgb", t, r, ...tt.hexToRgb(...i)) : tt[r][e](...i), "getModelAnsi"), M6 = ["rgb",
"hex", "ansi256"];
for (let e of M6) {
  Di[e] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let s = uf(of(e, A_[r], "color", ...i), tt.color.close, this[pi]);
        return Xo(this, s, this[Pn]);
      };
    }
  };
  let t = "bg" + e[0].toUpperCase() + e.slice(1);
  Di[t] = {
    get() {
      let { level: r } = this;
      return function(...i) {
        let s = uf(of(e, A_[r], "bgColor", ...i), tt.bgColor.close, this[pi]);
        return Xo(this, s, this[Pn]);
      };
    }
  };
}
var j6 = Object.defineProperties(() => {
}, {
  ...Di,
  level: {
    enumerable: !0,
    get() {
      return this[sf].level;
    },
    set(e) {
      this[sf].level = e;
    }
  }
}), uf = /* @__PURE__ */ n((e, t, r) => {
  let i, s;
  return r === void 0 ? (i = e, s = t) : (i = r.openAll + e, s = t + r.closeAll), {
    open: e,
    close: t,
    openAll: i,
    closeAll: s,
    parent: r
  };
}, "createStyler"), Xo = /* @__PURE__ */ n((e, t, r) => {
  let i = /* @__PURE__ */ n((...s) => I6(i, s.length === 1 ? "" + s[0] : s.join(" ")), "builder");
  return Object.setPrototypeOf(i, j6), i[sf] = e, i[pi] = t, i[Pn] = r, i;
}, "createBuilder"), I6 = /* @__PURE__ */ n((e, t) => {
  if (e.level <= 0 || !t)
    return e[Pn] ? "" : t;
  let r = e[pi];
  if (r === void 0)
    return t;
  let { openAll: i, closeAll: s } = r;
  if (t.includes("\x1B"))
    for (; r !== void 0; )
      t = C_(t, r.close, r.open), r = r.parent;
  let o = t.indexOf(`
`);
  return o !== -1 && (t = F_(t, s, i, o)), i + t + s;
}, "applyStyle");
Object.defineProperties(qn.prototype, Di);
var L6 = qn(), I9 = qn({ level: S_ ? S_.level : 0 });
var Cr = L6;

// ../node_modules/widest-line/node_modules/string-width/index.js
var T_ = G(Jo(), 1), R_ = G(Yo(), 1);
function af(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = It(e), e.length === 0))
    return 0;
  e = e.replace((0, R_.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, i = 0;
  for (let s of e) {
    let o = s.codePointAt(0);
    if (o <= 31 || o >= 127 && o <= 159 || o >= 768 && o <= 879)
      continue;
    switch (T_.default.eastAsianWidth(s)) {
      case "F":
      case "W":
        i += 2;
        break;
      case "A":
        i += r;
        break;
      default:
        i += 1;
    }
  }
  return i;
}
n(af, "stringWidth");

// ../node_modules/widest-line/index.js
function Zo(e) {
  let t = 0;
  for (let r of e.split(`
`))
    t = Math.max(t, af(r));
  return t;
}
n(Zo, "widestLine");

// ../node_modules/boxen/index.js
var aE = G(cf(), 1);

// ../node_modules/boxen/node_modules/camelcase/index.js
var U6 = /[\p{Lu}]/u, W6 = /[\p{Ll}]/u, O_ = /^[\p{Lu}](?![\p{Lu}])/gu, M_ = /([\p{Alpha}\p{N}_]|$)/u, ff = /[_.\- ]+/, $6 = new RegExp("^" +
ff.source), P_ = new RegExp(ff.source + M_.source, "gu"), q_ = new RegExp("\\d+" + M_.source, "gu"), H6 = /* @__PURE__ */ n((e, t, r, i) => {
  let s = !1, o = !1, u = !1, a = !1;
  for (let l = 0; l < e.length; l++) {
    let c = e[l];
    a = l > 2 ? e[l - 3] === "-" : !0, s && U6.test(c) ? (e = e.slice(0, l) + "-" + e.slice(l), s = !1, u = o, o = !0, l++) : o && u && W6.test(
    c) && (!a || i) ? (e = e.slice(0, l - 1) + "-" + e.slice(l - 1), u = o, o = !1, s = !0) : (s = t(c) === c && r(c) !== c, u = o, o = r(c) ===
    c && t(c) !== c);
  }
  return e;
}, "preserveCamelCase"), z6 = /* @__PURE__ */ n((e, t) => (O_.lastIndex = 0, e.replace(O_, (r) => t(r))), "preserveConsecutiveUppercase"), V6 = /* @__PURE__ */ n(
(e, t) => (P_.lastIndex = 0, q_.lastIndex = 0, e.replace(P_, (r, i) => t(i)).replace(q_, (r) => t(r))), "postProcess");
function hf(e, t) {
  if (!(typeof e == "string" || Array.isArray(e)))
    throw new TypeError("Expected the input to be `string | string[]`");
  if (t = {
    pascalCase: !1,
    preserveConsecutiveUppercase: !1,
    ...t
  }, Array.isArray(e) ? e = e.map((o) => o.trim()).filter((o) => o.length).join("-") : e = e.trim(), e.length === 0)
    return "";
  let r = t.locale === !1 ? (o) => o.toLowerCase() : (o) => o.toLocaleLowerCase(t.locale), i = t.locale === !1 ? (o) => o.toUpperCase() : (o) => o.
  toLocaleUpperCase(t.locale);
  return e.length === 1 ? ff.test(e) ? "" : t.pascalCase ? i(e) : r(e) : (e !== r(e) && (e = H6(e, r, i, t.preserveConsecutiveUppercase)), e =
  e.replace($6, ""), e = t.preserveConsecutiveUppercase ? z6(e, r) : r(e), t.pascalCase && (e = i(e.charAt(0)) + e.slice(1)), V6(e, i));
}
n(hf, "camelCase");

// ../node_modules/boxen/index.js
var gf = G(J_(), 1);

// ../node_modules/wrap-ansi/node_modules/string-width/index.js
var Y_ = G(Jo(), 1), K_ = G(Yo(), 1);
function xr(e, t = {}) {
  if (typeof e != "string" || e.length === 0 || (t = {
    ambiguousIsNarrow: !0,
    ...t
  }, e = It(e), e.length === 0))
    return 0;
  e = e.replace((0, K_.default)(), "  ");
  let r = t.ambiguousIsNarrow ? 1 : 2, i = 0;
  for (let s of e) {
    let o = s.codePointAt(0);
    if (o <= 31 || o >= 127 && o <= 159 || o >= 768 && o <= 879)
      continue;
    switch (Y_.default.eastAsianWidth(s)) {
      case "F":
      case "W":
        i += 2;
        break;
      case "A":
        i += r;
        break;
      default:
        i += 1;
    }
  }
  return i;
}
n(xr, "stringWidth");

// ../node_modules/wrap-ansi/node_modules/ansi-styles/index.js
var Q_ = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${t + e}m`, "wrapAnsi16"), X_ = /* @__PURE__ */ n((e = 0) => (t) => `\x1B[${38 + e};5;${t}\
m`, "wrapAnsi256"), Z_ = /* @__PURE__ */ n((e = 0) => (t, r, i) => `\x1B[${38 + e};2;${t};${r};${i}m`, "wrapAnsi16m"), le = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
}, lN = Object.keys(le.modifier), eP = Object.keys(le.color), tP = Object.keys(le.bgColor), cN = [...eP, ...tP];
function rP() {
  let e = /* @__PURE__ */ new Map();
  for (let [t, r] of Object.entries(le)) {
    for (let [i, s] of Object.entries(r))
      le[i] = {
        open: `\x1B[${s[0]}m`,
        close: `\x1B[${s[1]}m`
      }, r[i] = le[i], e.set(s[0], s[1]);
    Object.defineProperty(le, t, {
      value: r,
      enumerable: !1
    });
  }
  return Object.defineProperty(le, "codes", {
    value: e,
    enumerable: !1
  }), le.color.close = "\x1B[39m", le.bgColor.close = "\x1B[49m", le.color.ansi = Q_(), le.color.ansi256 = X_(), le.color.ansi16m = Z_(), le.
  bgColor.ansi = Q_(10), le.bgColor.ansi256 = X_(10), le.bgColor.ansi16m = Z_(10), Object.defineProperties(le, {
    rgbToAnsi256: {
      value: /* @__PURE__ */ n((t, r, i) => t === r && r === i ? t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232 : 16 + 36 *
      Math.round(t / 255 * 5) + 6 * Math.round(r / 255 * 5) + Math.round(i / 255 * 5), "value"),
      enumerable: !1
    },
    hexToRgb: {
      value: /* @__PURE__ */ n((t) => {
        let r = /[a-f\d]{6}|[a-f\d]{3}/i.exec(t.toString(16));
        if (!r)
          return [0, 0, 0];
        let [i] = r;
        i.length === 3 && (i = [...i].map((o) => o + o).join(""));
        let s = Number.parseInt(i, 16);
        return [
          /* eslint-disable no-bitwise */
          s >> 16 & 255,
          s >> 8 & 255,
          s & 255
          /* eslint-enable no-bitwise */
        ];
      }, "value"),
      enumerable: !1
    },
    hexToAnsi256: {
      value: /* @__PURE__ */ n((t) => le.rgbToAnsi256(...le.hexToRgb(t)), "value"),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value: /* @__PURE__ */ n((t) => {
        if (t < 8)
          return 30 + t;
        if (t < 16)
          return 90 + (t - 8);
        let r, i, s;
        if (t >= 232)
          r = ((t - 232) * 10 + 8) / 255, i = r, s = r;
        else {
          t -= 16;
          let a = t % 36;
          r = Math.floor(t / 36) / 5, i = Math.floor(a / 6) / 5, s = a % 6 / 5;
        }
        let o = Math.max(r, i, s) * 2;
        if (o === 0)
          return 30;
        let u = 30 + (Math.round(s) << 2 | Math.round(i) << 1 | Math.round(r));
        return o === 2 && (u += 60), u;
      }, "value"),
      enumerable: !1
    },
    rgbToAnsi: {
      value: /* @__PURE__ */ n((t, r, i) => le.ansi256ToAnsi(le.rgbToAnsi256(t, r, i)), "value"),
      enumerable: !1
    },
    hexToAnsi: {
      value: /* @__PURE__ */ n((t) => le.ansi256ToAnsi(le.hexToAnsi256(t)), "value"),
      enumerable: !1
    }
  }), le;
}
n(rP, "assembleStyles");
var iP = rP(), eE = iP;

// ../node_modules/wrap-ansi/index.js
var eu = /* @__PURE__ */ new Set([
  "\x1B",
  "\x9B"
]), nP = 39, mf = "\x07", iE = "[", sP = "]", nE = "m", yf = `${sP}8;;`, tE = /* @__PURE__ */ n((e) => `${eu.values().next().value}${iE}${e}${nE}`,
"wrapAnsiCode"), rE = /* @__PURE__ */ n((e) => `${eu.values().next().value}${yf}${e}${mf}`, "wrapAnsiHyperlink"), oP = /* @__PURE__ */ n((e) => e.
split(" ").map((t) => xr(t)), "wordLengths"), Df = /* @__PURE__ */ n((e, t, r) => {
  let i = [...t], s = !1, o = !1, u = xr(It(e[e.length - 1]));
  for (let [a, l] of i.entries()) {
    let c = xr(l);
    if (u + c <= r ? e[e.length - 1] += l : (e.push(l), u = 0), eu.has(l) && (s = !0, o = i.slice(a + 1).join("").startsWith(yf)), s) {
      o ? l === mf && (s = !1, o = !1) : l === nE && (s = !1);
      continue;
    }
    u += c, u === r && a < i.length - 1 && (e.push(""), u = 0);
  }
  !u && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
}, "wrapWord"), uP = /* @__PURE__ */ n((e) => {
  let t = e.split(" "), r = t.length;
  for (; r > 0 && !(xr(t[r - 1]) > 0); )
    r--;
  return r === t.length ? e : t.slice(0, r).join(" ") + t.slice(r).join("");
}, "stringVisibleTrimSpacesRight"), aP = /* @__PURE__ */ n((e, t, r = {}) => {
  if (r.trim !== !1 && e.trim() === "")
    return "";
  let i = "", s, o, u = oP(e), a = [""];
  for (let [c, h] of e.split(" ").entries()) {
    r.trim !== !1 && (a[a.length - 1] = a[a.length - 1].trimStart());
    let p = xr(a[a.length - 1]);
    if (c !== 0 && (p >= t && (r.wordWrap === !1 || r.trim === !1) && (a.push(""), p = 0), (p > 0 || r.trim === !1) && (a[a.length - 1] += "\
 ", p++)), r.hard && u[c] > t) {
      let d = t - p, f = 1 + Math.floor((u[c] - d - 1) / t);
      Math.floor((u[c] - 1) / t) < f && a.push(""), Df(a, h, t);
      continue;
    }
    if (p + u[c] > t && p > 0 && u[c] > 0) {
      if (r.wordWrap === !1 && p < t) {
        Df(a, h, t);
        continue;
      }
      a.push("");
    }
    if (p + u[c] > t && r.wordWrap === !1) {
      Df(a, h, t);
      continue;
    }
    a[a.length - 1] += h;
  }
  r.trim !== !1 && (a = a.map((c) => uP(c)));
  let l = [...a.join(`
`)];
  for (let [c, h] of l.entries()) {
    if (i += h, eu.has(h)) {
      let { groups: d } = new RegExp(`(?:\\${iE}(?<code>\\d+)m|\\${yf}(?<uri>.*)${mf})`).exec(l.slice(c).join("")) || { groups: {} };
      if (d.code !== void 0) {
        let f = Number.parseFloat(d.code);
        s = f === nP ? void 0 : f;
      } else d.uri !== void 0 && (o = d.uri.length === 0 ? void 0 : d.uri);
    }
    let p = eE.codes.get(Number(s));
    l[c + 1] === `
` ? (o && (i += rE("")), s && p && (i += tE(p))) : h === `
` && (s && p && (i += tE(s)), o && (i += rE(o)));
  }
  return i;
}, "exec");
function tu(e, t, r) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((i) => aP(i, t, r)).join(`
`);
}
n(tu, "wrapAnsi");

// ../node_modules/boxen/index.js
var yP = G(cf(), 1);
var nr = `
`, Le = " ", jn = "none", lE = /* @__PURE__ */ n(() => {
  let { env: e, stdout: t, stderr: r } = Mn.default;
  return t?.columns ? t.columns : r?.columns ? r.columns : e.COLUMNS ? Number.parseInt(e.COLUMNS, 10) : 80;
}, "terminalColumns"), sE = /* @__PURE__ */ n((e) => typeof e == "number" ? {
  top: e,
  right: e * 3,
  bottom: e,
  left: e * 3
} : {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  ...e
}, "getObject"), In = /* @__PURE__ */ n((e) => e === jn ? 0 : 2, "getBorderWidth"), lP = /* @__PURE__ */ n((e) => {
  let t = [
    "topLeft",
    "topRight",
    "bottomRight",
    "bottomLeft",
    "left",
    "right",
    "top",
    "bottom"
  ], r;
  if (e === jn) {
    e = {};
    for (let i of t)
      e[i] = "";
  }
  if (typeof e == "string") {
    if (r = aE.default[e], !r)
      throw new TypeError(`Invalid border style: ${e}`);
  } else {
    typeof e?.vertical == "string" && (e.left = e.vertical, e.right = e.vertical), typeof e?.horizontal == "string" && (e.top = e.horizontal,
    e.bottom = e.horizontal);
    for (let i of t)
      if (e[i] === null || typeof e[i] != "string")
        throw new TypeError(`Invalid border style: ${i}`);
    r = e;
  }
  return r;
}, "getBorderChars"), cP = /* @__PURE__ */ n((e, t, r) => {
  let i = "", s = Dt(e);
  switch (r) {
    case "left": {
      i = e + t.slice(s);
      break;
    }
    case "right": {
      i = t.slice(s) + e;
      break;
    }
    default: {
      t = t.slice(s), t.length % 2 === 1 ? (t = t.slice(Math.floor(t.length / 2)), i = t.slice(1) + e + t) : (t = t.slice(t.length / 2), i =
      t + e + t);
      break;
    }
  }
  return i;
}, "makeTitle"), fP = /* @__PURE__ */ n((e, { padding: t, width: r, textAlignment: i, height: s }) => {
  e = (0, gf.default)(e, { align: i });
  let o = e.split(nr), u = Zo(e), a = r - t.left - t.right;
  if (u > a) {
    let h = [];
    for (let p of o) {
      let d = tu(p, a, { hard: !0 }), m = (0, gf.default)(d, { align: i }).split(`
`), v = Math.max(...m.map((y) => Dt(y)));
      for (let y of m) {
        let _;
        switch (i) {
          case "center": {
            _ = Le.repeat((a - v) / 2) + y;
            break;
          }
          case "right": {
            _ = Le.repeat(a - v) + y;
            break;
          }
          default: {
            _ = y;
            break;
          }
        }
        h.push(_);
      }
    }
    o = h;
  }
  i === "center" && u < a ? o = o.map((h) => Le.repeat((a - u) / 2) + h) : i === "right" && u < a && (o = o.map((h) => Le.repeat(a - u) + h));
  let l = Le.repeat(t.left), c = Le.repeat(t.right);
  return o = o.map((h) => l + h + c), o = o.map((h) => {
    if (r - Dt(h) > 0)
      switch (i) {
        case "center":
          return h + Le.repeat(r - Dt(h));
        case "right":
          return h + Le.repeat(r - Dt(h));
        default:
          return h + Le.repeat(r - Dt(h));
      }
    return h;
  }), t.top > 0 && (o = [...Array.from({ length: t.top }).fill(Le.repeat(r)), ...o]), t.bottom > 0 && (o = [...o, ...Array.from({ length: t.
  bottom }).fill(Le.repeat(r))]), s && o.length > s ? o = o.slice(0, s) : s && o.length < s && (o = [...o, ...Array.from({ length: s - o.length }).
  fill(Le.repeat(r))]), o.join(nr);
}, "makeContentText"), hP = /* @__PURE__ */ n((e, t, r) => {
  let i = /* @__PURE__ */ n((h) => {
    let p = r.borderColor ? DP(r.borderColor)(h) : h;
    return r.dimBorder ? Cr.dim(p) : p;
  }, "colorizeBorder"), s = /* @__PURE__ */ n((h) => r.backgroundColor ? mP(r.backgroundColor)(h) : h, "colorizeContent"), o = lP(r.borderStyle),
  u = lE(), a = Le.repeat(r.margin.left);
  if (r.float === "center") {
    let h = Math.max((u - t - In(r.borderStyle)) / 2, 0);
    a = Le.repeat(h);
  } else if (r.float === "right") {
    let h = Math.max(u - t - r.margin.right - In(r.borderStyle), 0);
    a = Le.repeat(h);
  }
  let l = "";
  r.margin.top && (l += nr.repeat(r.margin.top)), (r.borderStyle !== jn || r.title) && (l += i(a + o.topLeft + (r.title ? cP(r.title, o.top.
  repeat(t), r.titleAlignment) : o.top.repeat(t)) + o.topRight) + nr);
  let c = e.split(nr);
  return l += c.map((h) => a + i(o.left) + s(h) + i(o.right)).join(nr), r.borderStyle !== jn && (l += nr + i(a + o.bottomLeft + o.bottom.repeat(
  t) + o.bottomRight)), r.margin.bottom && (l += nr.repeat(r.margin.bottom)), l;
}, "boxContent"), dP = /* @__PURE__ */ n((e) => {
  if (e.fullscreen && Mn.default?.stdout) {
    let t = [Mn.default.stdout.columns, Mn.default.stdout.rows];
    typeof e.fullscreen == "function" && (t = e.fullscreen(...t)), e.width || (e.width = t[0]), e.height || (e.height = t[1]);
  }
  return e.width && (e.width = Math.max(1, e.width - In(e.borderStyle))), e.height && (e.height = Math.max(1, e.height - In(e.borderStyle))),
  e;
}, "sanitizeOptions"), oE = /* @__PURE__ */ n((e, t) => t === jn ? e : ` ${e} `, "formatTitle"), pP = /* @__PURE__ */ n((e, t) => {
  t = dP(t);
  let r = t.width !== void 0, i = lE(), s = In(t.borderStyle), o = i - t.margin.left - t.margin.right - s, u = Zo(tu(e, i - s, { hard: !0, trim: !1 })) +
  t.padding.left + t.padding.right;
  if (t.title && r ? (t.title = t.title.slice(0, Math.max(0, t.width - 2)), t.title && (t.title = oE(t.title, t.borderStyle))) : t.title && (t.
  title = t.title.slice(0, Math.max(0, o - 2)), t.title && (t.title = oE(t.title, t.borderStyle), Dt(t.title) > u && (t.width = Dt(t.title)))),
  t.width = t.width ? t.width : u, !r) {
    if (t.margin.left && t.margin.right && t.width > o) {
      let l = (i - t.width - s) / (t.margin.left + t.margin.right);
      t.margin.left = Math.max(0, Math.floor(t.margin.left * l)), t.margin.right = Math.max(0, Math.floor(t.margin.right * l));
    }
    t.width = Math.min(t.width, i - s - t.margin.left - t.margin.right);
  }
  return t.width - (t.padding.left + t.padding.right) <= 0 && (t.padding.left = 0, t.padding.right = 0), t.height && t.height - (t.padding.top +
  t.padding.bottom) <= 0 && (t.padding.top = 0, t.padding.bottom = 0), t;
}, "determineDimensions"), bf = /* @__PURE__ */ n((e) => e.match(/^#(?:[0-f]{3}){1,2}$/i), "isHex"), uE = /* @__PURE__ */ n((e) => typeof e ==
"string" && (Cr[e] ?? bf(e)), "isColorValid"), DP = /* @__PURE__ */ n((e) => bf(e) ? Cr.hex(e) : Cr[e], "getColorFn"), mP = /* @__PURE__ */ n(
(e) => bf(e) ? Cr.bgHex(e) : Cr[hf(["bg", e])], "getBGColorFn");
function wf(e, t) {
  if (t = {
    padding: 0,
    borderStyle: "single",
    dimBorder: !1,
    textAlignment: "left",
    float: "left",
    titleAlignment: "left",
    ...t
  }, t.align && (t.textAlignment = t.align), t.borderColor && !uE(t.borderColor))
    throw new Error(`${t.borderColor} is not a valid borderColor`);
  if (t.backgroundColor && !uE(t.backgroundColor))
    throw new Error(`${t.backgroundColor} is not a valid backgroundColor`);
  return t.padding = sE(t.padding), t.margin = sE(t.margin), t = pP(e, t), e = fP(e, t), hP(e, t.width, t);
}
n(wf, "boxen");

// src/cli/angular/helpers.ts
var Ef = G(os(), 1), Cf = G(vf(), 1);
var Nn = "angular.json", gP = Cf.dedent`
  import { setCompodocJson } from "@storybook/addon-docs/angular";
  import docJson from "../documentation.json";
  setCompodocJson(docJson);
`.trimStart(), bP = /* @__PURE__ */ n(async () => {
  hE.logger.plain(
    // Create a text which explains the user why compodoc is necessary
    wf(
      Cf.dedent`
      Compodoc is a great tool to generate documentation for your Angular projects.
      Storybook can use the documentation generated by Compodoc to extract argument definitions
      and JSDOC comments to display them in the Storybook UI. We highly recommend using Compodoc for
      your Angular projects to get the best experience out of Storybook.
    `,
      { title: "Compodoc", borderStyle: "round", padding: 1, borderColor: "#F1618C" }
    )
  );
  let { useCompoDoc: e } = await (0, Ef.default)({
    type: "confirm",
    name: "useCompoDoc",
    message: "Do you want to use Compodoc for documentation?"
  });
  return e;
}, "promptForCompoDocs"), _f = class {
  static {
    n(this, "AngularJSON");
  }
  constructor() {
    if (!(0, mi.existsSync)(Nn))
      throw new dE.MissingAngularJsonError({ path: (0, fE.join)(process.cwd(), Nn) });
    let t = (0, mi.readFileSync)(Nn, "utf8");
    this.json = JSON.parse(t);
  }
  get projects() {
    return this.json.projects;
  }
  get projectsWithoutStorybook() {
    return Object.keys(this.projects).filter((t) => {
      let { architect: r } = this.projects[t];
      return !r.storybook;
    });
  }
  get hasStorybookBuilder() {
    return Object.keys(this.projects).some((t) => {
      let { architect: r } = this.projects[t];
      return Object.keys(r).some((i) => r[i].builder === "@storybook/angular:start-storybook");
    });
  }
  get rootProject() {
    let t = Object.keys(this.projects).find((r) => {
      let { root: i } = this.projects[r];
      return i === "" || i === ".";
    });
    return t ? this.projects[t] : null;
  }
  getProjectSettingsByName(t) {
    return this.projects[t];
  }
  async getProjectName() {
    if (this.projectsWithoutStorybook.length > 1) {
      let { projectName: t } = await (0, Ef.default)({
        type: "select",
        name: "projectName",
        message: "For which project do you want to generate Storybook configuration?",
        choices: this.projectsWithoutStorybook.map((r) => ({
          title: r,
          value: r
        }))
      });
      return t;
    }
    return this.projectsWithoutStorybook[0];
  }
  addStorybookEntries({
    angularProjectName: t,
    storybookFolder: r,
    useCompodoc: i,
    root: s
  }) {
    let { architect: o } = this.projects[t], u = {
      configDir: r,
      browserTarget: `${t}:build`,
      compodoc: i,
      ...i && { compodocArgs: ["-e", "json", "-d", s || "."] }
    };
    o.storybook || (o.storybook = {
      builder: "@storybook/angular:start-storybook",
      options: {
        ...u,
        port: 6006
      }
    }), o["build-storybook"] || (o["build-storybook"] = {
      builder: "@storybook/angular:build-storybook",
      options: {
        ...u,
        outputDir: Object.keys(this.projects).length === 1 ? "storybook-static" : `dist/storybook/${t}`
      }
    });
  }
  write() {
    (0, mi.writeFileSync)(Nn, JSON.stringify(this.json, null, 2));
  }
};

// src/cli/eslintPlugin.ts
var xf = require("node:fs"), Sf = require("@storybook/core/common"), iu = require("@storybook/core/csf-tools");

// ../node_modules/detect-indent/index.js
var wP = /^(?:( )+|\t+)/, Un = "space", DE = "tab";
function pE(e, t) {
  let r = /* @__PURE__ */ new Map(), i = 0, s, o;
  for (let u of e.split(/\n/g)) {
    if (!u)
      continue;
    let a, l, c, h, p, d = u.match(wP);
    if (d === null)
      i = 0, s = "";
    else {
      if (a = d[0].length, l = d[1] ? Un : DE, t && l === Un && a === 1)
        continue;
      l !== s && (i = 0), s = l, c = 1, h = 0;
      let f = a - i;
      if (i = a, f === 0)
        c = 0, h = 1;
      else {
        let m = f > 0 ? f : -f;
        o = vP(l, m);
      }
      p = r.get(o), p = p === void 0 ? [1, 0] : [p[0] + c, p[1] + h], r.set(o, p);
    }
  }
  return r;
}
n(pE, "makeIndentsMap");
function vP(e, t) {
  return (e === Un ? "s" : "t") + String(t);
}
n(vP, "encodeIndentsKey");
function _P(e) {
  let r = e[0] === "s" ? Un : DE, i = Number(e.slice(1));
  return { type: r, amount: i };
}
n(_P, "decodeIndentsKey");
function EP(e) {
  let t, r = 0, i = 0;
  for (let [s, [o, u]] of e)
    (o > r || o === r && u > i) && (r = o, i = u, t = s);
  return t;
}
n(EP, "getMostUsedKey");
function CP(e, t) {
  return (e === Un ? " " : "	").repeat(t);
}
n(CP, "makeIndentString");
function Ff(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  let t = pE(e, !0);
  t.size === 0 && (t = pE(e, !1));
  let r = EP(t), i, s = 0, o = "";
  return r !== void 0 && ({ type: i, amount: s } = _P(r), o = CP(i, s)), {
    amount: s,
    type: i,
    indent: o
  };
}
n(Ff, "detectIndent");

// src/cli/eslintPlugin.ts
var yi = G(qa(), 1), mE = G(os(), 1), yE = G(vf(), 1);
var gE = ["js", "cjs", "json"], FP = ["yaml", "yml"], bE = /* @__PURE__ */ n(() => {
  let e = ".eslintrc", t = FP.find(
    (i) => (0, xf.existsSync)(`${e}.${i}`)
  );
  if (t)
    throw new Error(t);
  let r = gE.find(
    (i) => (0, xf.existsSync)(`${e}.${i}`)
  );
  return r ? `${e}.${r}` : null;
}, "findEslintFile");
async function xP(e) {
  let t = await e.getAllDependencies(), r = await e.retrievePackageJson(), i = null;
  try {
    i = bE();
  } catch {
  }
  let s = !!t["eslint-plugin-storybook"];
  return { hasEslint: t.eslint || i || r.eslintConfig, isStorybookPluginInstalled: s, eslintConfigFile: i };
}
n(xP, "extractEslintInfo");
var ru = /* @__PURE__ */ n((e) => {
  if (!e)
    return [];
  if (typeof e == "string")
    return [e];
  if (Array.isArray(e))
    return e;
  throw new Error(`Invalid eslint extends ${e}`);
}, "normalizeExtends");
async function SP(e, t) {
  if (e)
    if ((0, Sf.paddedLog)(`Configuring Storybook ESLint plugin at ${e}`), e.endsWith("json")) {
      let r = await (0, yi.readJson)(e), i = ru(r.extends).filter(Boolean);
      r.extends = [...i, "plugin:storybook/recommended"];
      let s = await (0, yi.readFile)(e, "utf8"), o = Ff(s).amount || 2;
      await (0, yi.writeJson)(e, r, { spaces: o });
    } else {
      let r = await (0, iu.readConfig)(e), i = ru(r.getFieldValue(["extends"])).filter(Boolean);
      r.setFieldValue(["extends"], [...i, "plugin:storybook/recommended"]), await (0, iu.writeConfig)(r);
    }
  else {
    (0, Sf.paddedLog)("Configuring eslint-plugin-storybook in your package.json");
    let r = await t.retrievePackageJson(), i = ru(r.eslintConfig?.extends).filter(Boolean);
    await t.writePackageJson({
      ...r,
      eslintConfig: {
        ...r.eslintConfig,
        extends: [...i, "plugin:storybook/recommended"]
      }
    });
  }
}
n(SP, "configureEslintPlugin");
var AP = /* @__PURE__ */ n(async () => {
  let { shouldInstall: e } = await (0, mE.default)({
    type: "confirm",
    name: "shouldInstall",
    message: yE.dedent`
        We have detected that you're using ESLint. Storybook provides a plugin that gives the best experience with Storybook and helps follow best practices: ${cs.
    yellow(
      "https://github.com/storybookjs/eslint-plugin-storybook#readme"
    )}

        Would you like to install it?
      `,
    initial: !0
  });
  return e;
}, "suggestESLintPlugin");
